라우팅 우선순위

핸들러나 미들웨어는 등록된 순서대로 실행됩니다.

```javascript
app.get('/book/a', (c) => c.text('a')) // 'a' 핸들러
app.get('/book/:slug', (c) => c.text('common')) // 'common' 핸들러

// GET /book/a 요청 시 ---> `a` 응답 (더 구체적인 '/book/a'가 먼저 매칭)
// GET /book/b 요청 시 ---> `common` 응답 (':slug'에 'b'가 매칭)
```

하나의 핸들러가 실행되면, 그 뒤의 과정은 멈춥니다. (즉, 해당 요청에 대해 더 이상 다른 라우트를 찾지 않음)

```javascript
app.get('*', (c) => c.text('common')) // 모든 경로를 잡는 'common' 핸들러
app.get('/foo', (c) => c.text('foo')) // '/foo' 경로를 잡는 'foo' 핸들러

// GET /foo 요청 시 ---> `common` 응답 ('*'가 먼저 등록되어 '/foo'를 가로챔. 'foo' 핸들러는 실행 안 됨)
```

만약 특정 핸들러보다 먼저 실행하고 싶은 미들웨어가 있다면, 그 핸들러 코드보다 위에 작성하세요.

```javascript
app.use(logger()) // 로거 미들웨어
app.get('/foo', (c) => c.text('foo')) // '/foo' 핸들러 (logger 실행 후 foo 핸들러 실행)
```

만약 다른 모든 핸들러가 매칭되지 않았을 때 실행될 "대체(fallback)" 핸들러를 두고 싶다면, 다른 핸들러들보다 아래에 작성하세요.

```javascript
app.get('/bar', (c) => c.text('bar')) // 'bar' 핸들러
app.get('*', (c) => c.text('fallback')) // 대체 'fallback' 핸들러

// GET /bar 요청 시 ---> `bar` 응답
// GET /foo 요청 시 ---> `fallback` 응답 (다른 특정 라우트가 없으므로 '*'가 매칭)
```

---

**얘 뭐 하는 애냐?**
라우팅 우선순위는 Hono 앱에 여러 개의 라우트(경로 규칙)를 등록했을 때, 특정 URL 요청이 들어오면 "어떤 놈이 이 요청을 처리해야 하는가?"를 결정하는 규칙입니다. 쉽게 말해, 길거리에서 손님(요청)이 왔을 때 여러 가게(라우트) 중 누가 먼저 호객 행위(처리)를 할 수 있는지 정하는 거죠. Hono는 기본적으로 "먼저 등록한 놈이 임자" + "더 구체적인 놈이 임자" 이 두 가지 원칙을 섞어서 씁니다.

**왜 중요한데?**
1.  **예측 가능한 동작**: 우선순위 규칙을 알아야 "왜 내 요청이 저쪽 핸들러로 가지?" 하는 삽질을 안 합니다. 코드가 의도한 대로 동작하게 만들려면 필수죠.
2.  **효율적인 라우팅**: 자주 쓰이거나 더 구체적인 경로를 앞에 배치하면 불필요한 라우트 검사를 줄일 수 있습니다 (물론 Hono 내부 라우터 최적화에 따라 다를 수 있지만, 일반적인 원칙입니다).
3.  **미들웨어 및 폴백(Fallback) 처리**: 특정 경로 그룹에만 미들웨어를 적용하거나, 아무 데도 해당 안 되는 요청을 위한 "404 페이지" 같은 폴백 처리를 제대로 구현하려면 이 우선순위를 잘 이용해야 합니다.

**어떻게 정해지냐?**
Hono의 라우팅 우선순위는 크게 다음과 같은 규칙을 따릅니다 (Hono가 사용하는 라우터 종류에 따라 약간의 차이는 있을 수 있지만, 일반적인 SmartRouter 기준입니다):

1.  **등록 순서 (위에서 아래로)**: 기본적으로 코드에 작성된 순서대로 라우트를 확인합니다. 위에 있는 놈이 먼저 검사받을 기회를 얻죠.
    *   `app.get('/user/all', ...)`
    *   `app.get('/user/:id', ...)`
    *   만약 `/user/all` 요청이 오면, 첫 번째 라우트가 먼저 매칭되어 처리됩니다.
2.  **정적 경로 > 동적 경로 (더 구체적인 놈 우선)**: 같은 레벨에서 비교할 때, `:id` 같은 파라미터가 없는 고정된 경로(정적 경로)가 파라미터가 있는 경로(동적 경로)보다 우선합니다.
    *   `app.get('/book/a', ...)`
    *   `app.get('/book/:slug', ...)`
    *   `/book/a` 요청 시, 첫 번째 `/book/a`가 `:slug`에 `a`를 넣는 것보다 더 구체적이므로 우선 처리됩니다.
3.  **와일드카드 (`*`)는 최후순위**: `app.get('*', ...)`처럼 모든 경로를 다 잡는 와일드카드 라우트는 가장 마지막에 검사됩니다. 그래서 보통 404 핸들러 같은 걸로 쓰죠.
    *   `app.get('/specific', ...)`
    *   `app.get('*', ...)`
    *   `/specific` 요청은 첫 번째에, 그 외 모든 요청은 두 번째 `*`에 걸립니다.

**쓸 때 꿀팁 및 주의사항:**
*   **구체적인 것부터 일반적인 순으로**: 가장 확실한 규칙은 "제일 좁은 범위(구체적인 경로)부터 넓은 범위(일반적인 경로, 와일드카드) 순으로 등록한다"입니다. 이게 헷갈림을 줄이는 최고의 방법입니다.
    *   나쁜 예: `app.get('/:page', ...)` 다음에 `app.get('/about', ...)`를 두면, `/about` 요청도 `/:page`에 먼저 걸려서 `page` 파라미터에 `about`이 들어가 버립니다. "어? 난 /about 핸들러 불렀는데 왜 쟤가 받지?" 되는 거죠.
    *   좋은 예: `app.get('/about', ...)` 다음에 `app.get('/:page', ...)`를 두세요.
*   **미들웨어 순서도 중요**: `app.use(미들웨어)`도 등록 순서대로 실행됩니다. 특정 경로 그룹에만 적용하고 싶다면 해당 경로들 바로 위에 `app.use('/admin', adminMiddleware)`처럼 경로와 함께 미들웨어를 등록하거나, 아니면 전역 미들웨어라면 가장 상단에 배치하세요.
*   **한 번 걸리면 끝**: 일단 요청 URL과 매칭되는 라우트를 찾아서 해당 핸들러가 실행되면, Hono는 그 요청에 대한 처리를 거기서 끝냅니다. (Express의 `next()`처럼 다음 라우트로 넘기는 기능은 Hono의 기본 동작 방식이 아닙니다. 미들웨어 체인 내에서 `next()`를 호출하는 것과는 다른 개념입니다.) "내 차례 왔으면 게임 끝!"
*   **라우터 종류에 따른 미묘한 차이**: Hono는 `RegExpRouter`, `TrieRouter`, `SmartRouter` 등 여러 라우팅 전략을 제공합니다. `SmartRouter`(기본값)는 대부분의 경우 똑똑하게 잘 처리해주지만, 아주 복잡하거나 특수한 라우팅 규칙을 사용한다면 선택한 라우터의 특성을 한번 확인해보는 게 좋습니다. "우리 집안 내력은 좀 달라요" 할 수도 있으니까요.
*   **테스트는 필수**: 라우팅 로직이 조금이라도 복잡해지면, 예상대로 동작하는지 반드시 테스트 코드를 작성해서 확인하세요. `app.request()` 같은 걸로 콕콕 찔러보면 됩니다. "백문이 불여일견, 백견이 불여일타!"