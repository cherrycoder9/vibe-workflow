정규표현식 (Regexp)

```javascript
app.get('/post/:date{[0-9]+}/:title{[a-z]+}', async (c) => {
  const { date, title } = c.req.param()
  // ... 뭔가 하겠죠 ...
})
```

---

**얘 뭐 하는 애냐?**
경로 매개변수에 정규표현식(RegExp)을 결합해서, URL의 특정 부분이 우리가 원하는 형식일 때만 해당 라우트가 응답하도록 만드는 기능입니다. 위 예시에서 `/:date{[0-9]+}`는 "date라는 파라미터는 반드시 하나 이상의 숫자로만 이루어져야 한다"는 뜻이고, `/:title{[a-z]+}`는 "title 파라미터는 반드시 하나 이상의 소문자 알파벳으로만 이루어져야 한다"는 뜻이죠. 한마디로, "아무나 오지 말고, 숫자 아이디랑 알파벳 제목 가진 놈만 와라!" 하고 문지기 세우는 겁니다.

**왜 쓰는데?**
1.  **엄격한 유효성 검사 (Early Validation)**: 요청이 핸들러 함수에 도달하기 전에 Hono 라우터 레벨에서 미리 형식을 검사합니다. 만약 `/post/오늘날짜/한글제목` 같은 요청이 오면, 정규식 조건에 안 맞으니 아예 404 (Not Found)로 처리해버리죠. 핸들러 안에서 "이거 숫자인가? 알파벳인가?" 하고 일일이 확인할 필요가 줄어듭니다. "입구컷 당하셨습니다, 손님."
2.  **라우트 충돌 방지 및 명확성 증대**: 비슷한 URL 구조를 가졌지만 파라미터의 성격이 다른 여러 라우트를 구분할 때 유용합니다. 예를 들어, `/items/:id(\\d+)` (ID는 숫자)와 `/items/:slug([a-z-]+)` (slug는 소문자 알파벳과 하이픈)를 명확히 구분해서 각각 다른 핸들러로 보낼 수 있죠. "넌 이쪽 줄, 걘 저쪽 줄!"
3.  **보안 강화 (약간)**: 예상치 못한 형식의 입력값이 핸들러로 넘어오는 것을 1차적으로 막아줘서, 잠재적인 입력값 관련 버그나 취약점을 줄이는 데 아주 약간 기여할 수 있습니다. 물론 이걸로 모든 보안이 해결되는 건 절대 아니니 "방탄조끼 입었다고 총알 맞아도 괜찮은 건 아니다" 정신을 잊으면 안 됩니다.

**언제 불려 나오냐? (언제 정규식이 검사되냐?)**
Hono 애플리케이션이 HTTP 요청을 받으면, 등록된 라우트들을 순서대로 살펴보면서 현재 요청 URL과 매칭되는 놈을 찾습니다. 이때 경로 매개변수에 정규표현식이 지정되어 있다면, 해당 URL 부분이 정규식 패턴과 일치하는지 즉시 검사합니다. 일치하면 해당 라우트의 핸들러를 실행하고, 일치하지 않으면 다음 라우트를 찾거나 결국 404를 반환하죠.

**쓸 때 꿀팁 및 주의사항:**
*   **문법: `/:paramName{regexp}`**: 콜론으로 시작하는 파라미터 이름 뒤에 중괄호 `{}`를 쓰고, 그 안에 자바스크립트 정규표현식 리터럴에서 슬래시(`/`)와 플래그(g, i 등)를 뺀 알맹이만 넣습니다. `{[0-9]+}`처럼요.
*   **이스케이프 문자 주의**: 정규식 내에서 특별한 의미를 가지는 문자(예: `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `\` `^` `$`)를 문자 그대로 매칭하고 싶다면 백슬래시(`\`)로 이스케이프 처리해야 합니다. 예를 들어 마침표(`.`)를 매칭하려면 `{\\.}` 이런 식으로 써야죠. 안 그러면 "어? 왜 점이 다 매칭되지?" 할 수 있습니다.
*   **캡처 그룹은 파라미터 값에 영향 없음**: 정규식 안에 캡처 그룹 `()`을 써도, `c.req.param('paramName')`으로 가져오는 값은 정규식 전체가 매칭된 부분입니다. 캡처 그룹별로 값을 따로 뽑아주진 않아요. "통째로 가져간다, 부분은 안 줘."
*   **복잡한 정규식은 가독성 저해**: 너무 길고 복잡한 정규식을 URL에 박아 넣으면 라우트 정의가 지저분해지고 이해하기 어려워집니다. 이럴 땐 차라리 핸들러 안에서 별도의 유효성 검사 로직을 두는 게 나을 수도 있습니다. "해독 불가 암호문 만들지 말자."
*   **성능 영향은 미미**: 대부분의 경우 정규식 매칭으로 인한 성능 저하는 거의 무시할 수준입니다. 하지만 수백, 수천 개의 라우트에 아주 복잡한 정규식을 남발한다면 티끌 모아 태산이 될 수도 있으니, "이 정도면 괜찮겠지?" 하고 한 번쯤은 생각해보는 게 좋습니다.
*   **Hono의 내장 정규식 활용**: Hono는 몇 가지 자주 사용되는 패턴에 대해 미리 정의된 정규식을 제공할 수도 있습니다 (문서 확인 필요). 예를 들어 숫자만 매칭하는 `:id<\\d+>` 같은 단축 표현이 있을 수 있죠. 이런 게 있다면 적극 활용하는 게 코드도 깔끔해지고 좋습니다.
*   **테스트는 필수**: 정규식은 생각보다 실수하기 쉬운 부분입니다. "이 정도면 되겠지?" 하고 넘어가지 말고, 의도한 대로 잘 작동하는지, 엣지 케이스는 없는지 테스트 코드로 꼭 검증하세요. "믿는 정규식에 발등 찍힌다."