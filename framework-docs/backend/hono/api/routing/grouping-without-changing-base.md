베이스 경로는 그대로 두고 그룹화하기

여러 인스턴스를 그룹화하면서도 베이스 경로는 유지할 수 있습니다.

```javascript
const book = new Hono()
book.get('/book', (c) => c.text('책 목록')) // GET /book
book.post('/book', (c) => c.text('책 생성')) // POST /book

const user = new Hono().basePath('/user')
user.get('/', (c) => c.text('사용자 목록')) // GET /user
user.post('/', (c) => c.text('사용자 생성')) // POST /user

const app = new Hono()
app.route('/', book) // /book 경로 처리
app.route('/', user) // /user 경로 처리
```

---

**얘 뭐 하는 애냐?**
`app.route()`는 여러 조각으로 나눠 만든 Hono 애플리케이션(인스턴스)들을 하나의 큰 Hono 앱 아래로 깔끔하게 합쳐주는 기능입니다. 마치 여러 팀이 각자 만든 레고 블록들을 가져와서 최종적으로 하나의 거대한 작품으로 조립하는 것과 비슷하죠. 이때 메인 앱의 기본 경로(`basePath`)는 건드리지 않고, 합쳐지는 앱들의 경로를 그대로 가져다 붙입니다.

**왜 쓰는데?**
1.  **코드 모듈화 끝판왕**: 기능별로 Hono 인스턴스를 분리해서 개발하면 각자 독립적으로 관리하기 편하고, 나중에 `app.route()`로 쓱 합치기만 하면 되니 전체 구조가 명확해집니다. "각개전투 후 본진 합류!"
2.  **유지보수 개꿀**: 특정 기능에 문제가 생기거나 수정할 일이 있을 때, 해당 Hono 인스턴스만 들여다보면 되니 디버깅이나 기능 확장이 훨씬 수월해집니다. "내 파트는 내가 책임진다!"
3.  **기존 Hono 앱 재활용**: 이미 잘 만들어둔 Hono 앱(예: 인증 전용 앱, 로깅 전용 앱)이 있다면, 다른 프로젝트에서도 `app.route()`로 손쉽게 가져다 붙여 쓸 수 있습니다. "잘 만든 부품, 여기저기 돌려쓰자!"

**언제 불려 나오냐?**
주로 애플리케이션의 초기 설정 단계에서, 여러 Hono 인스턴스에 정의된 라우트들을 메인 애플리케이션에 등록하고 싶을 때 개발자가 직접 호출합니다. `app.route('/api', adminRoutes)` 이런 식으로 말이죠.

**쓸 때 꿀팁 및 주의사항:**
*   **첫 번째 인자는 접두사 경로, 두 번째는 Hono 인스턴스**: `app.route('/prefix', subApp)` 형태로 사용합니다. `subApp`에 정의된 모든 경로는 `/prefix` 뒤에 붙게 됩니다. 예제처럼 접두사로 `/`를 사용하면, `subApp`의 `basePath`나 자체 경로가 메인 앱의 루트 레벨에 그대로 적용됩니다.
*   **`basePath`와의 콜라보**: 만약 `app.route('/admin', userRoutes)`를 호출했는데, `userRoutes` 인스턴스가 내부적으로 `userRoutes.basePath('/users')`를 가지고 있고, 그 안에 `/list`라는 경로가 있다면, 최종적으로 접근 가능한 경로는 `/admin/users/list`가 됩니다. "족보 잘 따져야 길 안 잃는다."
*   **`app.mount()`랑 뭐가 달라?**: `app.mount('/path', handlerFn)`는 특정 경로를 *단일 핸들러 함수*(다른 프레임워크 핸들러 포함)에 연결하는 반면, `app.route('/path', honoInstance)`는 특정 경로를 *다른 Hono 인스턴스에 정의된 모든 라우트들*에 연결합니다. `mount`는 외부 라이브러리나 커스텀 로직 붙일 때, `route`는 Hono 앱끼리 합칠 때 더 적합합니다. "망치랑 드라이버 용도가 다르듯이, 얘네도 그렇다."
*   **라우트 경로 중복되면 골치 아픔**: 여러 Hono 인스턴스를 `route`로 합칠 때, 최종적으로 완성되는 전체 경로가 겹치지 않도록 주의해야 합니다. 경로가 중복되면 어떤 놈이 처리될지 예측하기 어렵거나, 먼저 등록된 놈이 우선권을 갖거나, 최악의 경우 에러가 날 수도 있습니다. "교통정리 안 하면 대형사고 난다."
*   **미들웨어 상속 관계**: 부모 앱(`app`)에 `app.use()`로 등록된 미들웨어는 `app.route()`로 합쳐진 자식 앱의 라우트에도 기본적으로 적용됩니다. "부모가 깔아둔 장판, 자식도 쓴다." 하지만 자식 앱에서 자체적으로 미들웨어를 어떻게 설정하느냐에 따라 동작이 달라질 수 있으니, 복잡한 구조에서는 테스트가 필수입니다.