`Host` 헤더 값으로 라우팅하기

Hono 생성자에 `getPath()` 함수를 설정하면, Hono가 `Host` 헤더 값을 처리할 수 있게 됩니다.

```javascript
const app = new Hono({
  getPath: (req) =>
    '/' + // 맨 앞에 슬래시 추가
    req.headers.get('host') + // 호스트 헤더 값 (예: 'www1.example.com')
    req.url.replace(/^https?:\/\/[^/]+(\/[^?]*).*/, '$1'), // URL에서 호스트 부분 빼고 경로만 추출 (예: '/hello')
    // 결과적으로 '/www1.example.com/hello' 같은 문자열이 만들어짐
})

app.get('/www1.example.com/hello', (c) => c.text('hello www1'))

// 다음 요청은 위 라우트와 매칭됩니다:
// new Request('http://www1.example.com/hello', {
//  headers: { host: 'www1.example.com' },
// })
```

이걸 응용하면, 예를 들어 `User-Agent` 헤더 값에 따라 라우팅을 다르게 할 수도 있습니다.

---

**얘 뭐 하는 애냐?**
Hono 앱이 라우팅 규칙을 정할 때, 단순히 URL 경로뿐만 아니라 요청의 `Host` 헤더 값까지 고려해서 "이 요청은 www1.example.com으로 온 거니까 이리 가고, 저 요청은 api.example.com으로 온 거니까 저리 가!" 하고 다르게 처리할 수 있게 해주는 고급 설정입니다. `getPath` 함수를 커스텀해서 Hono가 내부적으로 사용하는 "라우팅용 경로 문자열" 자체를 조작하는 거죠. "간판 보고 다른 문으로 안내하는 격"이라고나 할까요.

**왜 쓰는데?**
1.  **서브도메인 기반 라우팅**: `www.example.com`, `api.example.com`, `blog.example.com`처럼 여러 서브도메인을 하나의 Hono 앱에서 각기 다른 로직으로 처리하고 싶을 때 씁니다. 각 서브도메인마다 별도의 앱을 띄우는 것보다 리소스 관리가 효율적일 수 있죠.
2.  **특정 호스트 전용 기능**: 특정 호스트 이름으로 들어온 요청에만 특별한 기능을 제공하거나 다른 미들웨어를 적용하고 싶을 때 유용합니다.
3.  **유연한 요청 매칭**: 예시처럼 `User-Agent` 헤더 같은 다른 요청 정보를 조합해서 라우팅 경로를 동적으로 구성할 수도 있습니다. "모바일 유저는 이쪽, 데스크톱 유저는 저쪽!" 이런 식으로요. (물론 이건 좀 과한 예시고, 보통은 미들웨어에서 처리하는 게 더 깔끔할 수 있습니다.)

**언제 불려 나오냐? (언제 `getPath`가 실행되냐?)**
Hono 앱에 HTTP 요청이 들어올 때마다, Hono 라우터가 어떤 핸들러를 실행할지 결정하기 *직전에* 이 `getPath` 함수가 호출됩니다. 이 함수가 반환하는 문자열을 기준으로 라우팅 매칭이 이루어지는 거죠. 즉, 모든 요청 처리의 맨 앞에서 "이 요청의 진짜 경로는 이거야!" 하고 정의해주는 역할을 합니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`getPath` 함수의 역할**: 이 함수는 반드시 `Request` 객체를 인자로 받아서, 라우팅에 사용될 "경로 문자열"을 반환해야 합니다. 예시 코드에서는 `/${호스트명}${원래경로}` 형태로 조합했죠.
*   **URL 정규화의 중요성**: `req.url`에는 `http://host.com/path?query=string` 같은 전체 URL이 들어옵니다. 여기서 실제 경로 부분만 정확히 추출하는 게 중요합니다. 예시의 `req.url.replace(/^https?:\/\/[^/]+(\/[^?]*).*/, '$1')` 부분이 그 역할을 하는데, 정규표현식이 좀 복잡하죠? 간단히 말해 "http(s)://호스트부분/" 까지는 날리고, 그 뒤 경로 부분만 쏙 빼오는 겁니다. 쿼리 스트링은 라우팅 경로에 포함되지 않도록 주의해야 하고요.
*   **라우트 정의도 일치시켜야**: `getPath`에서 `/www1.example.com/hello` 같은 경로를 만들었다면, 라우트 정의도 `app.get('/www1.example.com/hello', ...)`처럼 똑같이 맞춰줘야 합니다. 안 그러면 "주소는 있는데 집이 없네?" 상황이 됩니다.
*   **`Host` 헤더는 위조 가능성**: `Host` 헤더는 클라이언트가 보낸 값이라서 얼마든지 위조될 수 있습니다. 이걸 기반으로 중요한 보안 결정을 내리는 건 위험할 수 있습니다. "손님이 주는 명함, 100% 믿으면 곤란하다."
*   **대안: 미들웨어 활용**: 단순히 특정 호스트에 따라 다른 로직을 태우고 싶다면, `getPath`를 건드리는 것보다 특정 경로에 미들웨어를 걸고 그 안에서 `req.headers.get('host')` 값을 확인해서 분기 처리하는 게 더 직관적이고 관리하기 편할 수도 있습니다. `getPath`는 라우팅 시스템의 근간을 바꾸는 거라 좀 더 신중하게 접근해야 합니다.
*   **성능 영향 미미**: `getPath` 함수가 매 요청마다 실행되긴 하지만, 보통 문자열 처리 몇 번 하는 정도라 성능에 큰 부담을 주진 않습니다. 그래도 너무 복잡한 로직을 넣으면 느려질 수 있으니 "간단 명료하게!"가 중요합니다.
*   **다른 헤더 활용 시 주의**: 예시처럼 `User-Agent` 같은 다른 헤더를 `getPath`에 활용하면 라우팅 경로가 너무 다양해져서 관리 포인트가 늘어날 수 있습니다. 캐싱 전략에도 영향을 줄 수 있고요. "이거 정말 `getPath`에서 해야 할 일인가?" 한번 더 생각해보는 게 좋습니다.