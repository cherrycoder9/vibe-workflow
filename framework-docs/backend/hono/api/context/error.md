핸들러에서 에러를 던지면, 그 에러 객체가 `c.error`에 담깁니다. 미들웨어에서 접근할 수 있죠.

```javascript
app.use(async (c, next) => {
  await next()
  if (c.error) {
    // 뭔가 하겠죠...
  }
})
```

---

**얘 뭐 하는 애냐?**
`c.error`는 Hono의 컨텍스트 객체(`c`) 안에 있는 속성으로, 라우트 핸들러나 그 이전에 실행된 미들웨어에서 `next()`를 호출한 이후, 그 `next()` 호출 체인 어딘가에서 예외(error)가 발생했을 때 그 에러 객체를 고이 모셔두는 곳입니다. 주로 `await next()` 다음에 오는 미들웨어, 즉 후처리 미들웨어에서 "어이쿠, 요청 처리하다가 일 터졌네?" 하고 상황을 파악하고 대응하기 위해 사용됩니다.

**왜 쓰는데?**
1.  **에러 탐지 및 로깅**: `await next()` 이후에 `c.error`가 있는지 슬쩍 보고, 만약 있다면 "야, 여기서 에러 터졌다!" 하고 로그를 남기거나 Sentry, Datadog 같은 에러 모니터링 시스템에 꼰지르는 용도로 씁니다. 일종의 블랙박스 기록 장치죠.
2.  **조건부 후처리 작업**: 정상적으로 처리됐을 때와 에러가 발생했을 때 각각 다른 뒷정리 작업을 해야 할 경우, `c.error` 유무를 보고 분기 처리할 수 있습니다. 예를 들어, 에러 시에만 특정 리소스를 롤백하거나 알림을 보내는 등의 작업을 할 수 있죠.
3.  **`app.onError` 전초전**: `app.onError`라는 최종 에러 처리 보스가 등판하기 전에, 미들웨어 레벨에서 에러 상황을 미리 캐치해서 부가적인 작업을 할 기회를 줍니다.

**언제 `c.error`에 값이 찍히냐?**
미들웨어에서 `await next()`를 호출했는데, 그 `next()`를 통해 실행된 다음 순서의 미들웨어나 최종 라우트 핸들러에서 `throw new Error()` 등으로 예외가 냅다 던져지고, 그 예외가 해당 호출 스택 내에서 `try...catch`로 잡히지 않았을 때 발생합니다. 즉, `await next()` 호출이 끝나고 제어권이 돌아왔을 때, 만약 그 과정에서 처리되지 않은 에러가 있었다면 `c.error`에 그 에러 객체가 할당되는 거죠.

**쓸 때 꿀팁 및 주의사항:**
*   **`app.onError`와의 관계**: `c.error`는 주로 "사고 접수 및 기록" 단계에 가깝고, `app.onError`는 "사고 처리 및 최종 보고"를 담당하는 최종 보스 격입니다. `c.error`를 통해 미들웨어에서 로깅 등의 작업을 할 수 있지만, 사용자에게 보여줄 최종 에러 응답(예: "죄송합니다, 서버에서 문제가 발생했습니다" 페이지)은 보통 `app.onError`가 맡아서 처리합니다.
    *   **중요**: 만약 미들웨어에서 `c.error`를 확인하고 `c.res = c.text('내가 직접 에러 처리함!', 500)`처럼 응답 객체(`c.res`)를 직접 만들어 할당해버리면, 그 응답이 최종 응답이 되고 `app.onError`는 "어? 내 할 일이 없네?" 하고 실행되지 않을 수 있습니다. "선수 치면 뒷사람 할 일 없어진다!"
*   **`await next()`는 필수 조건**: `c.error`는 `await next()` 호출 *이후에* 의미가 있습니다. `next()`를 호출하기 전에는 당연히 `c.error`는 `undefined` 상태입니다. "미래를 볼 순 없잖아?"
*   **`try...catch`로 잡으면 안 와요**: 만약 미들웨어나 핸들러에서 `await next()` 호출 부분을 `try...catch` 블록으로 감싸서 에러를 거기서 직접 잡아버리면, 그 에러는 `c.error`까지 전달되지 않습니다. `c.error`는 기본적으로 "처리되지 않고 흘러나온" 에러들을 위한 자리입니다.
*   **타입 체크는 습관처럼**: `c.error`에 담긴 값은 `unknown` 타입일 수 있으므로, `if (c.error instanceof Error)`처럼 타입 가드를 사용해서 실제 `Error` 객체인지 확인하고 속성(예: `c.error.message`)에 접근하는 것이 안전합니다. 안 그러면 런타임에 "얘 정체가 뭐냐?" 하면서 에러 터질 수 있습니다.
*   **주 용도는 관찰 및 로깅**: `c.error`를 이용해서 너무 복잡한 에러 처리 로직을 미들웨어에 꾸겨 넣기 시작하면 코드가 지저분해지고 이해하기 어려워질 수 있습니다. 가능하면 에러 응답 생성 및 전송은 `app.onError`로 일원화하고, `c.error`는 상황 관찰, 로깅, 또는 간단한 플래그 설정 정도로 활용하는 것이 코드 구조를 깔끔하게 유지하는 데 도움이 됩니다.