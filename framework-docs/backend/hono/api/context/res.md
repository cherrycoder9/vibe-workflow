`res`
반환될 `Response` 객체에 접근할 수 있습니다.

```javascript
// Response 객체
app.use('/', async (c, next) => {
  await next() // 다음 핸들러나 미들웨어가 작업을 마칠 때까지 기다립니다.
  // 이제 c.res는 다음 핸들러가 생성했거나 수정한 Response 객체를 가리킵니다.
  c.res.headers.append('X-Debug', '디버그 메시지') // 여기에 헤더를 추가합니다.
})
```

---

**얘 뭐 하는 애냐?**
`c.res`는 Hono 컨텍스트(`c`)를 통해 접근할 수 있는, 최종적으로 클라이언트에게 날아갈 **표준 `Response` 객체 그 자체**입니다. Hono의 편리한 응답 헬퍼들(`c.text()`, `c.json()`, `c.header()` 등)도 결국 내부에서는 이 `c.res`를 만들거나 주무르는 방식으로 동작하죠. `c.res`를 직접 건드린다는 건, Hono가 차려준 밥상에 내가 직접 수저를 놓거나 반찬을 더하는 것과 비슷합니다.

**왜 쓰는데?**
1.  **세밀한 응답 제어**: Hono 헬퍼만으로는 부족할 때, `Response` 객체의 온갖 속성(status, statusText, headers, body 등)을 날것 그대로 직접 조작하고 싶을 때 씁니다. 예를 들어, `ReadableStream`을 응답 본문으로 쓴다거나, 아주 특이한 헤더 조합을 만들어야 할 때 유용하죠.
2.  **미들웨어에서의 후처리 (Post-processing)**: 이게 핵심 용도 중 하나입니다. 위 예시처럼 `app.use()` 같은 미들웨어 안에서 `await next()`로 뒤따르는 라우트 핸들러나 다른 미들웨어들이 응답을 다 만들고 나면, 그 최종 결과물인 `c.res`를 가져와서 헤더를 추가하거나, 특정 조건에 따라 내용을 살짝 바꾸는 등의 "마무리 작업"을 할 수 있습니다. "요리 다 끝내고 상 차리기 직전에, '아 참, 깨소금 좀 뿌려야지!' 하는 느낌"이죠.
3.  **표준 API 활용**: 이미 표준 `Response` API에 익숙하다면, Hono 헬퍼를 거치지 않고 `c.res = new Response(...)`처럼 직접 `Response` 객체를 만들어 할당하는 게 더 직관적일 수 있습니다.

**언제 불려 나오냐? (언제 접근/수정하냐?)**
*   **미들웨어에서**: `await next()` 호출 *이후*에 `c.res`에 접근해서 수정합니다. `next()`를 통해 다음 로직들이 `c.res`를 완성시키면, 그 이후에 건드려야 의미가 있습니다. 만약 `next()` *전에* `c.res`를 수정해도, 뒤에서 `c.json()` 같은 걸로 `c.res`를 새로 덮어써버리면 말짱 도루묵이죠.
*   **라우트 핸들러에서**: `return c.text(...)` 등으로 응답을 반환하기 *직전에* `c.res.headers.set(...)`처럼 살짝 수정할 수 있습니다. 또는 아예 `const myRes = new Response('직접 만든 응답'); c.res = myRes; return c.res;` 와 같이 `c.res`에 직접 할당하고 반환할 수도 있습니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`c.res`는 참조다!**: `c.res`는 `Response` 객체의 복사본이 아니라 원본을 직접 가리키는 참조입니다. 그래서 `c.res.headers.append(...)`처럼 바로 객체의 메서드를 호출해서 내용을 바꿀 수 있습니다.
*   **`c.res`는 교체 가능**: `c.res = new Response('새로운 응답!', { status: 418 })` 이런 식으로 아예 다른 `Response` 객체로 갈아치울 수도 있습니다. 미들웨어에서 특정 조건에 따라 완전히 다른 응답을 내려보내고 싶을 때 유용합니다.
*   **응답 전송 후엔 무쓸모**: 일단 응답의 첫 바이트라도 클라이언트로 전송되기 시작하면 (특히 스트리밍 응답), 그 이후에 `c.res`를 아무리 만져봤자 이미 떠난 버스입니다. 헤더 수정 같은 건 전송 시작 전에만 가능해요.
*   **Hono 헬퍼와의 관계**: `c.text('안녕')`은 대략 `c.res = new Response('안녕', { headers: c.res?.headers ?? new Headers() })` 와 비슷하게 동작합니다. 즉, 기존 `c.res`에 이미 설정된 헤더가 있다면 그걸 유지하면서 새로운 본문으로 `Response` 객체를 만들어 `c.res`를 업데이트하죠. (정확한 내부 구현은 조금 다를 수 있지만, 개념은 이렇습니다.)
*   **`c.res`가 `null`이나 `undefined`일 수도 있나?**: Hono는 요청 처리 초기에 `c.res`를 기본적인 `Response` 객체 (예: `new Response(null)`)로 초기화해둡니다. 그래서 핸들러가 명시적으로 응답을 반환하지 않거나 `c.res`를 설정하지 않으면 이 기본값이 사용됩니다. 따라서 `c.res`가 아예 `null`이나 `undefined`인 경우는 거의 없다고 봐도 됩니다. (물론 개발자가 고의로 `c.res = null` 같은 코드를 넣지 않는 이상 말이죠.)