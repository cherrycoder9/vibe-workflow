`var`
`c.var`를 사용해서 (미들웨어 등에서 설정된) 변수 값에 접근할 수도 있습니다.

```javascript
const result = c.var.client.oneMethod() // c.var.client에 뭔가 객체가 있고, 그 객체의 메서드를 호출하는 예시
```

만약 커스텀 메서드를 제공하는 미들웨어를 만들고 싶다면, 아래처럼 작성하세요:

```typescript
// Env 타입 정의: c.var를 통해 접근할 변수들의 타입을 명시
type Env = {
  Variables: {
    echo: (str: string) => string // echo라는 이름의 함수가 있고, 문자열을 받아 문자열을 반환
  }
}

const app = new Hono() // Env를 아직 적용 안 한 Hono 인스턴스

// 미들웨어 만들기 (echo 함수를 컨텍스트에 설정)
const echoMiddleware = createMiddleware<Env>(async (c, next) => {
  c.set('echo', (str) => str) // 'echo'라는 키로 함수를 컨텍스트에 저장
  await next() // 다음 미들웨어나 핸들러로 제어권 넘김
})

// 특정 라우트에 미들웨어 적용
app.get('/echo', echoMiddleware, (c) => {
  // c.var를 통해 'echo' 함수에 접근하고 실행
  return c.text(c.var.echo('Hello!'))
})
```

만약 여러 핸들러에서 이 미들웨어를 사용하고 싶다면, `app.use()`를 쓸 수 있습니다. 그럴 땐 타입 안전성을 위해 Hono 생성자에 `Env`를 제네릭으로 전달해야 합니다.

```typescript
const app = new Hono<Env>() // Env 타입을 적용한 Hono 인스턴스

app.use(echoMiddleware) // 모든 라우트에 echoMiddleware 적용

app.get('/echo', (c) => {
  // 이제 어떤 핸들러에서든 c.var.echo를 타입 안전하게 사용 가능
  return c.text(c.var.echo('Hello!'))
})
```

---

**얘 뭐 하는 애냐?**
`c.set('키', 값)`과 `c.var.키`는 Hono의 미들웨어와 핸들러 사이에서 데이터를 주고받는 방법입니다. `c.set`은 컨텍스트(c)에 "야, 이 데이터 좀 맡아줘!" 하고 값을 저장하는 창고지기 역할이고, `c.var`는 그 창고에서 "아까 맡긴 거 내놔!" 하고 값을 꺼내 쓰는 열쇠 같은 놈이죠. 주로 미들웨어에서 처리한 결과(예: 인증된 사용자 정보, 데이터베이스 커넥션)를 다음 미들웨어나 최종 핸들러에게 전달할 때 써먹습니다.

**왜 쓰는데?**
1.  **미들웨어 간 데이터 공유**: 인증 미들웨어에서 사용자 정보를 `c.set('user', userInfo)`로 저장하면, 뒤따르는 로깅 미들웨어나 API 핸들러에서 `c.var.user`로 해당 정보를 꺼내 쓸 수 있습니다. "정보 돌려막기"가 가능해지는 거죠.
2.  **타입스크립트와의 환상 궁합**: `type Env = { Variables: { myValue: string } }`처럼 `Env` 타입을 정의하고 `new Hono<Env>()`로 Hono 앱을 만들면, `c.var.myValue`를 쓸 때 타입스크립트가 "어, 그거 문자열 타입인데 숫자 넣으려고 하네?" 하고 미리 알려줍니다. 자동완성은 덤이고요. 개발하다가 "이거 타입 뭐였지?" 하고 머리 쥐어뜯는 일 방지용입니다.
3.  **코드 깔끔 & 재사용성 UP**: 자주 쓰는 유틸리티 함수나 초기화된 클라이언트 객체(예: DB 클라이언트)를 미들웨어에서 `c.set`으로 한번 등록해두면, 여러 핸들러에서 `c.var`로 쉽게 가져다 쓸 수 있습니다. "한번 준비해두고 계속 우려먹자!"

**언제 불려 나오냐? (언제 값을 설정하고 가져오냐?)**
*   `c.set('키', 값)`: 주로 미들웨어 안에서, `await next()`를 호출하기 *전에* 컨텍스트에 값을 세팅합니다. "다음 놈한테 이거 들려 보내!" 하는 거죠.
*   `c.var.키` (또는 `c.get('키')`): `c.set`으로 값이 설정된 이후에, 해당 값을 필요로 하는 미들웨어나 라우트 핸들러 안에서 호출해서 값을 가져옵니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`Env`와 `Variables`는 국룰**: 타입스크립트 쓸 때 `c.var`를 타입 안전하게 쓰려면 `Hono<Env>()` 형태로 `Env` 타입을 지정하고, 그 `Env` 타입 안에는 반드시 `Variables`라는 이름의 프로퍼티를 만들어서 그 안에 `c.var`로 접근할 변수들의 타입을 정의해야 합니다. `type Env = { Variables: { user: UserType, db: DBClient } }` 이런 식으로요. 안 지키면 타입 체크 제대로 안 됩니다.
*   **`c.set`은 그냥 설정만**: `c.set()`은 값을 설정하고 아무것도 반환하지 않습니다 (void).
*   **덮어쓰기 가능**: `c.set('name', '철수')` 해놓고 나중에 `c.set('name', '영희')` 하면 `c.var.name`은 '영희'가 됩니다. 마지막에 넣은 놈이 장땡.
*   **`c.get('키')` vs `c.var.키`**:
    *   `c.get('키')`: `c.set`으로 설정된 값을 가져오는 기본적인 방법입니다. `Env`에 타입이 정의되어 있으면 타입 추론도 잘 됩니다.
    *   `c.var.키`: `c.get('키')`를 좀 더 객체지향적으로(?) 쓸 수 있게 해주는 프록시 객체입니다. `c.var.user`처럼 쓰면 내부적으로 `c.get('user')`를 호출하는 거죠. 가독성이 좋고, 타입스크립트 환경에서 `Env`와 함께 쓰면 빛을 발합니다.
*   **미들웨어 순서가 생명**: `c.set`을 하는 미DL웨어가 `c.var`를 사용하는 핸들러나 미들웨어보다 *반드시* 먼저 실행되어야 합니다. 순서 꼬이면 `undefined` 만나고 "왜 값이 없지? 버그인가?" 하며 삽질 시작합니다.
*   **`c.var`는 읽기 전용 (처럼 쓰세요)**: `c.var.user = newUser` 이런 식으로 `c.var`에 직접 값을 할당하려고 하면 안 됩니다. 값 설정은 무조건 `c.set('user', newUser)`를 통해서 해야 합니다. `c.var`는 꺼내 쓰는 용도!
*   **뭘 저장할까?**: 사용자 객체, DB 커넥션 풀, 설정 값, 자주 쓰는 유틸리티 함수 등등 미들웨어 체인 전체에서 공유하고 싶은 건 뭐든 넣을 수 있습니다. 하지만 너무 크고 아름다운 객체를 계속 넘기면 아주 미세하게나마 성능에 영향을 줄 수 있으니, 꼭 필요한 정보만 담는 게 좋습니다. "너무 많이 담으면 무거워서 느려진다!"