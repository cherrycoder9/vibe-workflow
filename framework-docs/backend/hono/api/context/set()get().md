`set()` / `get()`
현재 요청 생명주기 동안만 유효한 임의의 키-값 쌍을 가져오고 설정합니다. 이걸로 미들웨어나 라우트 핸들러 사이에서 특정 값을 주고받을 수 있습니다.

```javascript
app.use(async (c, next) => {
  c.set('message', 'Hono는 멋져!!')
  await next()
})

app.get('/', (c) => {
  const message = c.get('message')
  return c.text(`메시지는 "${message}" 입니다`)
})
```

타입 안전성을 확보하려면, Hono 생성자에 제네릭으로 Variables를 넘겨주세요.

```typescript
type Variables = {
  message: string
}

const app = new Hono<{ Variables: Variables }>()
```

`c.set` / `c.get`으로 설정된 값은 동일한 요청 내에서만 유지됩니다. 서로 다른 요청 간에 공유되거나 영속화될 수 없습니다.

---

**얘 뭐 하는 애냐?**
`c.set('키', '값')`과 `c.get('키')`는 Hono의 컨텍스트(`c`) 객체에다가 현재 처리 중인 *단일 요청* 안에서만 쓸 수 있는 임시 저장 공간을 만들고 데이터를 넣었다 뺐다 하는 기능입니다. 미들웨어에서 뭔가 계산하거나 검증한 결과를 뒤이어 실행될 다른 미들웨어나 최종 라우트 핸들러에게 "야, 이거 내가 처리해놨으니까 너 가져다 써!" 하고 전달하는 용도죠. 일종의 요청 한정판 비밀 쪽지함 같은 겁니다.

**왜 쓰는데?**
1.  **미들웨어 간 데이터 전달**: 예를 들어, 첫 번째 미들웨어에서 사용자 인증하고 사용자 정보를 가져왔다고 칩시다. 이 정보를 `c.set('user', userInfo)` 이렇게 저장해두면, 그 뒤에 오는 미들웨어나 라우트 핸들러에서 `c.get('user')`로 바로 꺼내 쓸 수 있습니다. 매번 DB 조회하거나 토큰 또 깔 필요 없으니 효율적이죠. "앞에서 밑 작업 다 해놨으니, 넌 편하게 써!"
2.  **코드 깔끔 & 책임 분리**: 특정 로직(예: 요청 유효성 검사, 데이터 가공)을 미들웨어로 빼고, 그 결과만 `c.set`으로 넘겨주면 라우트 핸들러는 핵심 비즈니스 로직에만 집중할 수 있습니다. 코드가 훨씬 깨끗해지고 각자 맡은 일만 잘하게 되죠.
3.  **반복 작업 회피**: 요청 처리 초반에 한 번만 수행하면 되는 작업을 미들웨어에서 처리하고 `c.set`으로 결과를 저장해두면, 뒤쪽 로직에서 같은 작업을 반복할 필요가 없습니다.

**언제 불려 나오냐? (언제 값을 쓰고 읽냐?)**
*   `c.set('키', 값)`: 주로 미들웨어 안에서, 다음 미들웨어나 핸들러에게 전달할 데이터를 저장할 때 호출합니다.
*   `c.get('키')`: 주로 `c.set`이 호출된 이후의 미들웨어나 라우트 핸들러 안에서, 이전에 저장된 데이터를 꺼내 쓸 때 호출합니다.

**쓸 때 꿀팁 및 주의사항:**
*   **생명주기는 딱 한 요청!**: `c.set`으로 저장한 데이터는 해당 HTTP 요청이 끝나면 그냥 사라집니다. 다음 요청 오면 깨끗한 새 컨텍스트로 시작해요. "이번 판 끝나면 리셋이다!" 다른 요청이랑 데이터 공유하고 싶으면 데이터베이스, 캐시, 세션 같은 걸 써야 합니다.
*   **타입스크립트 + 제네릭 = 꿀조합**:
    ```typescript
    type MyVariables = {
      userId?: number; // 물음표는 선택적 프로퍼티
      isAdmin: boolean;
      processedData: string;
    }

    const app = new Hono<{ Variables: MyVariables }>();

    app.use(async (c, next) => {
      c.set('userId', 123);
      c.set('isAdmin', true);
      await next();
      // c.set('nonExistentVar', '이건 에러!'); // MyVariables에 없으면 컴파일 에러!
    });

    app.get('/', (c) => {
      const userId = c.get('userId'); // userId는 number | undefined 타입으로 추론됨
      const isAdmin = c.get('isAdmin'); // isAdmin은 boolean 타입으로 추론됨
      // const typoData = c.get('proceSsedData'); // 오타나면 컴파일 에러!
      return c.json({ userId, isAdmin });
    });
    ```
    이렇게 `Hono<{ Variables: ... }>()` 형태로 제네릭을 지정해주면, `c.set` 할 때 정해진 키만 쓸 수 있고 `c.get` 할 때도 해당 키 값의 타입을 정확히 알 수 있어서 오타나 타입 관련 버그를 컴파일 시점에 미리 잡을 수 있습니다. "타입스크립트 안 쓰면 손해!"
*   **키 이름은 신중하게**: 여러 미들웨어에서 `c.set/get`을 막 쓰다 보면 키 이름이 겹치거나 헷갈릴 수 있습니다. 일관성 있는 네이밍 규칙을 정하거나, 심볼(Symbol)을 키로 쓰는 것도 방법입니다.
*   **너무 많이 담지는 말자**: 컨텍스트는 임시 저장소일 뿐, 온갖 데이터를 다 때려 박는 용도가 아닙니다. 정말 필요한 최소한의 데이터만 전달하는 게 좋습니다. "이삿짐 싸냐? 간단히 챙겨!"
*   **`c.get`은 값이 없으면 `undefined`**: `c.set`으로 해당 키에 아무것도 저장 안 했거나, 오타 등으로 잘못된 키를 `c.get`으로 부르면 `undefined`가 나옵니다. 그래서 타입스크립트에서 제네릭으로 타입을 명시해도, 선택적 프로퍼티(`?`)가 아니면 `c.get`의 반환 타입은 `YourType | undefined`가 될 수 있다는 점을 인지하고 방어 코드를 짜는 게 좋습니다. "혹시 빈손으로 올 수도 있다!"