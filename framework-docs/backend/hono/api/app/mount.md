`mount()`는 다른 프레임워크로 만든 앱을 당신의 Hono 앱에 붙여넣을 수 있게 해줍니다.

```javascript
import { Router as IttyRouter } from 'itty-router'
import { Hono } from 'hono'

// itty-router 앱 만들기
const ittyRouter = IttyRouter()

// `GET /itty-router/hello` 처리
ittyRouter.get('/hello', () => new Response('Hello from itty-router'))

// Hono 앱
const app = new Hono()

// 붙여넣기!
app.mount('/itty-router', ittyRouter.handle)
```

---

**얘 뭐 하는 애냐?**
`app.mount()`는 Hono 앱 안에다가 다른 웹 프레임워크(예: IttyRouter, Express 등)로 만든 애플리케이션이나 라우터를 통째로 "끼워 넣는" 기능입니다. 특정 경로로 들어오는 요청들을 Hono가 직접 처리하는 대신, 마운트된 다른 앱에게 "야, 이건 네 담당이니까 네가 알아서 해" 하고 넘겨주는 거죠. 레고 블록처럼 서로 다른 앱 조각들을 합체시키는 그림을 생각하면 쉽습니다.

**왜 쓰는데?**
1.  **점진적 마이그레이션**: 기존에 다른 프레임워크로 잘 돌아가던 서비스를 Hono로 옮기고 싶은데 한방에 다 바꾸기 부담스러울 때 씁니다. "/api/v1"은 기존 Express 앱이 계속 처리하고, 새로 만드는 "/api/v2"부터 Hono로 개발하는 식으로 점진적으로 전환할 수 있죠. "일단 급한 불부터 끄고, 나머진 천천히 하자" 전략입니다.
2.  **특정 기능 전문 앱 활용**: 예를 들어, 이미지 처리나 복잡한 인증 로직처럼 특정 기능에 특화된 작은 앱(마이크로서비스까진 아니더라도)을 다른 프레임워크로 만들어뒀다면, 그걸 Hono 앱의 특정 경로에 `mount`해서 재활용할 수 있습니다. "잘 만든 바퀴, 또 만들 필요 있나?" 마인드죠.
3.  **모듈성 증대**: 큰 애플리케이션을 여러 개의 작은 앱으로 쪼개서 개발하고, 메인 Hono 앱에서 이들을 `mount` 방식으로 조합하면 코드 관리나 팀별 작업 분담이 용이해질 수 있습니다. 물론, 이건 너무 잘게 쪼개면 오히려 복잡도만 늘어나니 "과유불급"을 명심해야 합니다.

**언제 불려 나오냐?**
Hono 애플리케이션을 설정하는 단계에서, 특정 경로를 다른 애플리케이션의 핸들러 함수에 매핑하고 싶을 때 개발자가 직접 호출합니다. `app.mount('/admin', adminApp.handle)` 이런 식으로요. 일단 마운트가 완료되면, `/admin`으로 시작하는 모든 요청은 `adminApp`이 받아서 처리하게 됩니다.

**쓸 때 꿀팁 및 주의사항:**
*   **첫 번째 인자는 경로 접두사(prefix)**: `/admin`, `/legacy-api`처럼 이 경로로 시작하는 모든 요청이 마운트된 앱으로 전달됩니다. 경로 끝에 `/`는 보통 자동으로 처리되지만, 일관성을 위해 붙이거나 빼거나 한쪽으로 통일하는 게 좋습니다.
*   **두 번째 인자는 `(request, ...args) => Promise<Response>` 시그니처를 가진 함수**: 마운트할 앱은 결국 HTTP 요청을 받아서 `Response` (또는 `Promise<Response>`)를 반환하는 함수 형태여야 합니다. 대부분의 경량 프레임워크는 이런 핸들러 함수나 미들웨어 체인을 익스포트하는 방법을 제공합니다 (예: IttyRouter의 `router.handle`, Express의 `app` 객체 자체 등).
    *   **Express 앱 마운트 시 주의**: Express 앱을 직접 마운트하려면 약간의 어댑터 함수가 필요할 수 있습니다. 왜냐하면 Express 핸들러는 `(req, res, next)` 시그니처를 쓰고, Hono(및 표준 Fetch API)는 `(request) => Response`를 기대하기 때문이죠. `hono/adapter` 같은 라이브러리가 이런 변환을 도와줄 수 있습니다. "어? 플러그 모양이 다른데?" 싶으면 어댑터 찾아봐야 합니다.
*   **경로 충돌 조심**: Hono 앱 자체에 정의된 라우트와 `mount`된 앱 내부의 라우트가 겹치지 않도록 주의해야 합니다. 예를 들어 Hono 앱에 `/app/foo`가 있고, `/app` 경로에 마운트된 앱 내부에 `/foo` 라우트가 있다면 의도치 않은 동작이 발생할 수 있습니다. "내 구역 확실히 하자!" 정신이 필요합니다.
*   **미들웨어 적용 범위**: Hono의 `app.use()`로 등록된 전역 미들웨어는 `mount`된 경로로 요청이 가기 *전에* 실행됩니다. 하지만 `mount`된 앱 내부의 미들웨어는 그 앱 안에서만 작동하겠죠. 미들웨어 체인을 잘 이해하고 있어야 "왜 이 미들웨어가 안 먹지?" 하는 삽질을 피할 수 있습니다.
*   **성능 고려**: 요청이 들어올 때마다 다른 앱의 핸들러를 호출하는 과정에서 약간의 오버헤드가 발생할 수 있습니다. 아주 민감한 고성능이 요구되는 경로라면 `mount`보다는 Hono 네이티브 기능으로 직접 구현하는 게 나을 수도 있습니다. 물론 대부분의 경우엔 "이 정도는 떡을 친다" 수준이겠지만요.
*   **`env`와 `ctx` 전달**: Hono의 컨텍스트(`c.env`, `c.executionCtx`)를 마운트된 앱으로 전달하려면, 마운트할 핸들러 함수를 래핑해서 명시적으로 넘겨줘야 할 수 있습니다. `app.mount('/path', (request, env, ctx) => mountedApp.handle(request, env, ctx))` 이런 식으로요. 프레임워크마다 이 부분을 처리하는 방식이 다를 수 있으니, "쟤네 집 살림살이는 어떻게 전달해야 하나?" 확인이 필요합니다.