`matchedRoutes()` (정확히는 `c.req.matchedRoutes`)
핸들러 내에서 현재 요청과 매칭된 라우트들의 목록을 반환합니다. 디버깅할 때 유용하죠.

```javascript
app.use(async function logger(c, next) {
  await next() // 다음 핸들러나 미들웨어가 실행될 때까지 기다렸다가
  // 매칭된 라우트들 정보 뽑아보기
  c.req.matchedRoutes.forEach(({ handler, method, path }, i) => {
    // 핸들러 함수 이름이 있으면 쓰고, 없으면 핸들러/미들웨어 구분해서 표시
    const name =
      handler.name || // 함수 이름 있으면 그거 쓰고
      (handler.length < 2 ? '[핸들러]' : '[미들웨어]') // 인자 개수로 대충 구분 (c, next면 미들웨어)
    console.log(
      method, // HTTP 메서드 (GET, POST 등)
      ' ',
      path, // 라우트 경로 패턴
      ' '.repeat(Math.max(10 - path.length, 0)), // 경로 길이에 따라 공백 추가 (줄 맞춤용)
      name, // 핸들러/미들웨어 이름
      i === c.req.routeIndex ? '<- 여기서 응답함' : '' // 현재 실행 중인 라우트면 표시
    )
  })
})
```

---

**얘 뭐 하는 애냐?**
`c.req.matchedRoutes`는 현재 들어온 요청에 대해 Hono 라우터가 "어, 이놈이랑 이놈이랑 이놈이 이 요청이랑 관련 있네?" 하고 찾아낸 라우트(미들웨어 포함)들의 목록을 담고 있는 배열입니다. 그리고 `c.req.routeIndex`는 그 목록 중에서 지금 *딱* 이 요청을 최종적으로 처리해서 응답을 보낸 놈이 몇 번째 녀석인지 알려주는 숫자고요. 쉽게 말해, "오늘 손님한테 서빙한 직원들 명단이랑, 그중에서 계산서 끊어준 직원이 누군지" 알려주는 겁니다.

**왜 쓰는데?**
1.  **디버깅 끝판왕**: 요청 하나가 들어왔을 때 어떤 미들웨어들을 거쳐서 어떤 핸들러에서 최종 응답이 나갔는지 한눈에 파악할 수 있습니다. "요청이 어디로 새는 거야?" 또는 "이 미들웨어 진짜 실행된 거 맞아?" 싶을 때 까보면 속 시원하죠. 특히 복잡한 미들웨어 체인이 얽혀있을 때 빛을 발합니다.
2.  **로깅/모니터링**: 요청 처리 경로를 상세하게 로그로 남겨서 나중에 문제 추적하거나 성능 분석할 때 써먹을 수 있습니다. "손님, 이런 코스로 서비스 받으셨습니다~" 하고 기록 남기는 거죠.
3.  **고급 라우팅 분석 (매우 드묾)**: 아주 특수한 경우, 현재 요청이 어떤 라우트 패턴들과 매칭되었는지 동적으로 알아내서 뭔가 다른 작업을 해야 할 때 쓸 수도 있겠지만... 이건 거의 쓸 일 없는 기능입니다. 그냥 디버깅용이라고 생각하는 게 속 편합니다.

**언제 불려 나오냐? (언제 값이 채워지냐?)**
`c.req.matchedRoutes`와 `c.req.routeIndex`는 Hono가 요청을 받아서 라우팅을 *마친 후*, 그리고 최종 핸들러가 응답을 생성한 *이후*에 정확한 값을 가집니다. 그래서 위 예제 코드처럼 `await next()` 호출 이후, 즉 모든 내부 처리가 끝나고 응답이 결정된 시점에 이 값들을 확인해야 의미가 있습니다. `next()` 호출 전에 보면 아직 라우팅 정보가 덜 채워졌거나 `routeIndex`가 부정확할 수 있습니다.

**쓸 때 꿀팁 및 주의사항:**
*   **주 용도는 디버깅**: 이 기능은 프로덕션 환경에서 핵심 로직으로 쓰기보다는 개발 중에 "흐름이 어떻게 되지?" 하고 내부를 들여다보는 용도로 쓰는 게 좋습니다. 성능에 미미하게나마 영향을 줄 수도 있고요.
*   **`handler.name`의 한계**: 익명 함수(`() => {}`)나 화살표 함수로 핸들러를 만들면 `handler.name`이 빈 문자열일 수 있습니다. 그래서 예제 코드에서도 `handler.length` (함수의 인자 개수)를 보고 대충 미들웨어인지 핸들러인지 추측하는 꼼수를 썼죠.
*   **`routeIndex`는 최종 응답자**: `matchedRoutes`에는 여러 미들웨어가 포함될 수 있지만, `routeIndex`가 가리키는 놈이 바로 `c.text()`, `c.json()` 등으로 실제 응답을 만들어 보낸 그 녀석입니다.
*   **Hono 내부 구조 의존**: 이 값들은 Hono의 라우팅 메커니즘에 깊이 연관되어 있습니다. Hono 버전이 크게 바뀌면 이 부분의 동작 방식이나 제공되는 정보가 달라질 수도 있으니, 너무 맹신하기보다는 "아, 대충 이렇게 돌아가는구나" 정도로 참고하는 게 좋습니다.
*   **`console.log` 말고 제대로 된 로거**: 예제는 `console.log`지만, 실제 로깅할 때는 Pino, Winston 같은 전문 로깅 라이브러리 쓰는 게 국룰입니다. 그래야 로그 레벨 관리, 포맷팅, 외부 저장소 연동 등이 편해집니다.