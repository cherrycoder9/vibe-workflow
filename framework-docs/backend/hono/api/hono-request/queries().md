`queries()`
여러 개의 쿼리스트링 매개변수 값을 가져옵니다. 예를 들어 `/search?tags=A&tags=B` 같은 경우죠.

```javascript
app.get('/search', async (c) => {
  // tags는 string[] (문자열 배열)이 됩니다.
  const tags = c.req.queries('tags')
  // ... 뭔가 하겠죠 ...
})
```

---

**얘 뭐 하는 애냐?**
`c.req.queries('키')`는 URL의 물음표(`?`) 뒤에 붙는 쿼리 파라미터 중에서, 똑같은 이름으로 여러 번 등장하는 값들을 배열로 쏙 뽑아주는 녀석입니다. 예를 들어 `?category=A&category=B&category=C` 이렇게 요청이 오면, `c.req.queries('category')`는 `['A', 'B', 'C']`라는 아름다운 배열을 돌려주죠. "같은 이름표 달고 온 놈들 다 모여!" 하는 겁니다.

**왜 쓰는데?**
1.  **다중 선택 값 처리**: 사용자가 검색 필터에서 여러 카테고리를 선택하거나, 여러 태그를 동시에 조회하고 싶을 때 씁니다. `?tags=js&tags=hono&tags=awesome` 같은 요청을 깔끔하게 처리할 수 있죠.
2.  **배열 형태 데이터 전송**: 클라이언트에서 서버로 배열 형태의 데이터를 쿼리 파라미터로 넘겨야 할 때, 서버 쪽에서 이걸 손쉽게 배열로 받을 수 있게 해줍니다. 일일이 콤마(`,`)로 구분된 문자열 받아서 `split(',')` 하는 것보다 훨씬 우아하죠.
3.  **API 유연성**: API 설계할 때 특정 파라미터가 단일 값일 수도 있고 여러 값일 수도 있는 상황에서, `queries()`를 사용하면 클라이언트가 값을 하나만 보내든 여러 개 보내든 서버는 일관되게 배열로 처리할 수 있습니다. (물론, 하나만 올 때는 길이가 1인 배열이 되겠죠.)

**언제 불려 나오냐?**
Hono 라우트 핸들러 안에서, 클라이언트 요청 URL에 동일한 이름의 쿼리 파라미터가 여러 개 포함되어 있을 것으로 예상될 때 `c.req.queries('파라미터이름')` 형태로 호출해서 사용합니다.

**쓸 때 꿀팁 및 주의사항:**
*   **리턴 값은 항상 배열 (string[])**: 해당 이름의 쿼리 파라미터가 하나만 있어도, 아예 없어도 `c.req.queries()`는 항상 배열을 반환합니다.
    *   `?tags=A&tags=B` → `['A', 'B']`
    *   `?tags=A` → `['A']`
    *   `?user=hono` (tags 파라미터 없음) → `[]` (빈 배열)
    이 일관성 덕분에 "어? 이거 배열이야, 단일 값이야?" 하고 헷갈릴 필요 없이 그냥 배열처럼 다루면 됩니다. "묻지도 따지지도 않고 배열 드립니다!"
*   **단일 값 원하면 `c.req.query('키')`**: 만약 같은 이름으로 여러 값이 오는 경우가 절대 없고, 딱 하나의 값만 기대한다면 `c.req.query('키')`를 쓰는 게 낫습니다. 걔는 여러 값이 와도 첫 번째 값만 문자열로 줍니다. `queries()`는 "혹시 여러 개일까 봐" 준비하는 녀석이죠.
*   **대소문자 구분**: 쿼리 파라미터의 키 이름은 대소문자를 구분합니다. `?Tags=A`랑 `?tags=B`는 다른 놈으로 취급되니 주의하세요.
*   **URL 인코딩**: 쿼리 파라미터 값에 특수문자(공백, 한글 등)가 포함되어 있다면 당연히 URL 인코딩(예: `%20`, `%ED%95%9C%EA%B8%80`)된 상태로 넘어옵니다. Hono가 알아서 디코딩해주니 핸들러에서는 그냥 평범한 문자열처럼 쓰면 됩니다.
*   **빈 값 처리**: `?tags=A&tags=&tags=C`처럼 중간에 빈 값이 껴있으면, `['A', '', 'C']` 이런 식으로 빈 문자열도 배열에 포함돼서 넘어옵니다. 필요하면 나중에 필터링해서 쓰세요. "빈손으로 온 놈도 일단 줄은 세운다."