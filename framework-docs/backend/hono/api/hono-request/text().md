`text()`
`text/plain` 타입의 요청 본문(body)을 파싱합니다.

```javascript
app.post('/entry', async (c) => {
  const body = await c.req.text()
  // ... 뭔가 하겠죠 ...
})
```

---

**얘 뭐 하는 애냐?**
`c.req.text()`는 클라이언트가 HTTP 요청에 실어 보낸 본문(payload)을 순수한 텍스트 문자열로 끄집어내는 녀석입니다. 주로 `Content-Type` 헤더가 `text/plain`으로 지정된 요청을 처리할 때 써먹죠. "데이터 왔는데, 이거 글자로 좀 풀어줘봐!" 하는 역할입니다.

**왜 쓰는데?**
1.  **간단한 텍스트 데이터 처리**: 복잡한 구조 없이 그냥 일반 텍스트, 예를 들어 짧은 메시지, 로그 데이터, 간단한 설정 값 같은 걸 받을 때 아주 간편합니다. "JSON 파싱? 폼 데이터? 됐고, 그냥 텍스트로 줘!" 할 때 딱이죠.
2.  **다른 텍스트 기반 형식의 기초 작업**: XML이나 CSV처럼 텍스트 기반이지만 Hono에 전용 파서가 없는 데이터를 받을 때, 일단 `c.req.text()`로 전체를 문자열로 읽어들인 다음 직접 파싱하는 용도로도 쓸 수 있습니다. (물론, JSON은 `c.req.json()`, 폼 데이터는 `c.req.formData()` 쓰는 게 국룰입니다. 괜히 돌아가지 마세요.)

**언제 불려 나오냐?**
`POST`, `PUT`, `PATCH`처럼 요청 본문을 가질 수 있는 HTTP 메서드의 핸들러 함수 안에서, 클라이언트가 보낸 데이터를 텍스트 형태로 사용하고 싶을 때 `await c.req.text()`와 같이 호출합니다. 요청 본문을 읽는 작업은 비동기적으로 처리되므로 `await` 키워드가 필수입니다. 안 쓰면 프로미스 객체만 덩그러니 받게 되니 "내용물은 어디 갔어?" 하고 당황하게 됩니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`await`는 생명**: `c.req.text()`는 프로미스(Promise)를 반환합니다. `await` 안 붙이면 "배달은 왔는데 문 안 열어주는 격"입니다. 내용물을 보려면 반드시 `await`을 쓰세요.
*   **`Content-Type`은 거들 뿐 (하지만 중요)**: 이 메서드는 `text/plain` 콘텐츠 타입을 가정하지만, 다른 타입(예: `application/json`)으로 온 요청에 사용해도 일단 문자열로 읽어줍니다. 다만, `{"key":"value"}` 같은 JSON 문자열을 `c.req.text()`로 읽으면 진짜 그냥 그 문자열 자체를 받는 거지, 자바스크립트 객체로 자동 변환해주진 않습니다. JSON 객체가 필요하면 `c.req.json()`을 쓰세요. "옷은 맞춰 입고 와야 대접받는다."
*   **빈 본문은 빈 문자열**: 요청 본문이 아예 비어있으면, `c.req.text()`는 `null`이나 `undefined` 대신 빈 문자열(`""`)을 반환합니다. "없으면 없는 대로 빈 봉투라도 준다."
*   **대용량 데이터는 조심**: 이 메서드는 요청 본문 전체를 메모리에 한 번에 올립니다. 수십 메가바이트짜리 텍스트 폭탄을 보내면 서버 메모리가 터질 수도 있습니다. (일반적인 웹 요청에서는 드문 경우지만, "혹시나 하는 마음에 노파심"입니다.)
*   **인코딩 문제**: 요청 헤더의 `Content-Type`에 `charset=utf-8`처럼 문자 인코딩 정보가 명시되어 있으면 Hono가 알아서 해당 인코딩으로 디코딩하려고 시도합니다. 만약 클라이언트가 이상한 인코딩으로 보내놓고 `charset` 정보도 안 주면 글자가 깨져서 "외계어 해독반"이 출동해야 할 수도 있습니다. UTF-8 쓰는 게 정신 건강에 이롭습니다.
*   **본문은 한 번만**: 요청 본문 스트림은 한 번 읽으면 소모됩니다. `c.req.text()`를 호출한 후에 같은 요청에 대해 `c.req.json()`이나 `c.req.formData()`를 또 호출하면, 이미 스트림이 다 읽힌 상태라 에러가 발생하거나 빈 데이터를 얻게 됩니다. "뷔페 음식은 한 번만 담으세요!" (Hono는 이런 상황을 일부 방지하기 위해 파싱된 본문을 내부적으로 캐시하기도 하지만, 기본 원칙은 스트림은 한 번만 읽는다는 것입니다.)