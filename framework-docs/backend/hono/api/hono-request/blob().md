`blob()`
요청 본문을 Blob으로 파싱합니다.

```javascript
app.post('/entry', async (c) => {
  const body = await c.req.blob()
  // ... 뭔가 하겠죠 ...
})
```

---

**얘 뭐 하는 애냐?**
`c.req.blob()`은 클라이언트가 HTTP 요청 본문(body)에 담아 보낸 데이터를 `Blob` (Binary Large Object) 형태로 바꿔주는 녀석입니다. `Blob`은 이미지, 오디오, 비디오 파일 같은 바이너리 데이터나 혹은 그냥 텍스트 덩어리를 다룰 때 쓰는 자바스크립트 객체죠. 한마디로 "요청으로 온 데이터 덩어리, 일단 Blob으로 뭉쳐!" 하는 겁니다.

**왜 쓰는데?**
1.  **파일 업로드 처리**: 클라이언트가 `<input type="file">`이나 `FormData`를 통해 이미지, 영상, 문서 파일 등을 서버로 올릴 때, 그 파일 데이터를 `Blob` 형태로 받아서 다루기 편합니다. "손님이 파일 보냈는데, 일단 덩어리째로 받아두자."
2.  **바이너리 데이터 직접 핸들링**: 파일이 아니더라도, 순수한 바이너리 스트림이나 큰 텍스트 데이터를 원시적인 형태로 받아 처리해야 할 때 유용합니다. 예를 들어, 암호화된 데이터 청크를 받거나, 특정 형식의 바이너리 프로토콜 데이터를 직접 파싱해야 할 때 쓸 수 있죠.
3.  **메모리 효율성 (상황에 따라)**: 아주 큰 데이터를 다룰 때, 문자열로 바로 변환하는 것보다 `Blob`으로 먼저 받는 것이 메모리 사용 측면에서 유리할 *수도* 있습니다. (물론 이건 데이터 크기나 처리 방식에 따라 다릅니다. 무조건적인 건 아니에요.)

**언제 불려 나오냐?**
Hono 라우트 핸들러 안에서, 클라이언트가 보낸 요청의 본문을 `Blob` 형태로 읽고 싶을 때 `await c.req.blob()` 형태로 호출합니다. `POST`, `PUT`, `PATCH`처럼 요청 본문을 가질 수 있는 HTTP 메서드와 함께 쓰이겠죠. `await` 키워드가 붙는 걸 보면 알 수 있듯이, 본문을 읽어오는 작업은 비동기적으로 처리됩니다. "데이터 오는 중이니 잠시만요~"

**쓸 때 꿀팁 및 주의사항:**
*   **`await` 필수**: `c.req.blob()`은 프로미스(`Promise<Blob>`)를 반환합니다. 그래서 반드시 `await`를 붙여서 실제 `Blob` 객체를 받아야 합니다. 안 그러면 프로미스 객체만 덩그러니 남아서 "이게 왜 Blob이 아니지?" 하게 됩니다.
*   **`Content-Type` 헤더는 참고만**: 브라우저가 파일을 업로드할 때 보통 `Content-Type` 헤더에 파일 종류(MIME 타입)를 담아 보냅니다. `Blob` 객체 자체도 `type` 속성으로 이 MIME 타입을 가질 수 있지만, `c.req.blob()`이 이 헤더를 보고 `Blob`의 `type`을 자동으로 설정해주는지는 Hono의 내부 구현이나 해당 런타임의 `Request` 객체 구현에 따라 다를 수 있습니다. 중요한 건, `Blob`으로 받았다고 해서 그 내용이 항상 헤더에 명시된 타입이라고 맹신하면 안 된다는 겁니다. 필요하면 직접 검증해야죠. "겉과 속이 다를 수 있다!"
*   **한 번만 읽을 수 있음 (Generally)**: 표준 `Request` 객체의 본문(body)은 스트림 기반이라 한 번 읽으면 다시 읽을 수 없는 경우가 많습니다. `c.req.json()`, `c.req.text()`, `c.req.formData()`, `c.req.blob()` 등을 같은 요청에 대해 여러 번 호출하면 두 번째부터는 빈 데이터를 받거나 에러가 날 수 있습니다. "한 번 맛보면 끝!" 만약 여러 형태로 써야 한다면, 처음 `blob()`으로 받은 후 그 `Blob` 객체를 가지고 `text()`, `arrayBuffer()` 등으로 변환해서 쓰는 게 안전합니다.
*   **`Blob`에서 실제 데이터 뽑아 쓰기**:
    *   `await blob.text()`: Blob 내용을 UTF-8 텍스트로 읽어옵니다.
    *   `await blob.arrayBuffer()`: Blob 내용을 `ArrayBuffer` (바이너리 데이터 버퍼)로 읽어옵니다. 이걸로 `Uint8Array` 등을 만들어서 바이트 단위로 조작할 수 있죠.
    *   `blob.stream()`: Blob 내용을 읽을 수 있는 `ReadableStream`을 반환합니다. 큰 데이터를 조각내서 처리할 때 유용합니다.
    *   `blob.slice(start, end, contentType)`: Blob의 특정 부분을 잘라내서 새로운 Blob을 만듭니다.
*   **파일 저장 시**: `Blob` 데이터를 서버 파일 시스템에 저장하려면, 해당 런타임(Node.js, Deno, Bun 등)이 제공하는 파일 시스템 API를 사용해야 합니다. 예를 들어 Node.js에서는 `fs.writeFile`에 `await blob.arrayBuffer()`로 얻은 `Buffer`를 넘겨줄 수 있겠죠.
*   **메모리 주의**: 아무리 `Blob`이라도 너무 큰 데이터를 한꺼번에 메모리에 올리면 "메모리 터졌어요 ㅠㅠ" 할 수 있습니다. 진짜진짜 큰 파일(몇 GB 단위)은 스트리밍 방식으로 처리하는 게 정석입니다. `blob.stream()`이 이럴 때 친구가 되어줄 수 있습니다.