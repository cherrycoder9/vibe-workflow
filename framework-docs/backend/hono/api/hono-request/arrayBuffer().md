`arrayBuffer()`
요청 본문을 `ArrayBuffer`로 파싱합니다.

```javascript
app.post('/entry', async (c) => {
  const body = await c.req.arrayBuffer()
  // ... 뭔가 하겠죠 ...
})
```

---

**얘 뭐 하는 애냐?**
`c.req.arrayBuffer()`는 클라이언트가 HTTP 요청 본문(body)에 담아 보낸 데이터를 순수한 바이너리 데이터 덩어리, 즉 `ArrayBuffer` 형태로 뽑아내는 녀석입니다. 이미지 파일, 오디오 파일, 압축 파일, 또는 그냥 일반 텍스트가 아닌 모든 종류의 "날것 그대로의 데이터"를 다룰 때 사용되죠. "택배 상자 뜯어서 내용물(바이너리)만 쏙 꺼내는 작업"이라고 생각하면 됩니다.

**왜 쓰는데?**
1.  **파일 업로드 처리**: 사용자가 웹사이트를 통해 이미지나 동영상 같은 파일을 올리면, 서버에서는 이 파일 데이터를 바이너리 형태로 받아야 합니다. `c.req.arrayBuffer()`가 바로 그 역할을 해줍니다.
2.  **바이너리 프로토콜 통신**: 웹소켓(WebSocket)이나 WebRTC처럼 텍스트 기반이 아닌 바이너리 데이터를 주고받는 프로토콜과 연동할 때, 또는 Protobuf(Protocol Buffers)나 MessagePack 같은 바이너리 직렬화 포맷을 사용할 때 필요합니다. "우리끼리는 암호(바이너리)로 대화하자!"
3.  **저수준 데이터 조작**: 받은 바이너리 데이터를 직접 바이트 단위로 읽거나 수정해야 하는 특수한 경우 (예: 이미지 픽셀 정보 변경, 암호화/복호화 작업)에 `ArrayBuffer`는 필수적입니다.

**언제 불려 나오냐?**
주로 `POST`, `PUT`, `PATCH` 같이 요청 본문에 데이터를 실어 보낼 수 있는 HTTP 메서드의 핸들러 함수 안에서 호출됩니다. 클라이언트가 보낸 요청 본문을 바이너리 데이터로 해석해서 사용해야 할 때 `await c.req.arrayBuffer()`를 쓰는 거죠.

**쓸 때 꿀팁 및 주의사항:**
*   **`await`는 필수**: `c.req.arrayBuffer()`는 프로미스(`Promise`)를 반환합니다. 요청 본문을 읽고 파싱하는 작업은 비동기로 이루어지기 때문이죠. 그래서 반드시 `await` 키워드를 붙여서 실제 `ArrayBuffer` 데이터를 받을 때까지 기다려야 합니다. 안 그러면 "데이터 아직 안 왔는데 뭘 하려는 거야?" 하고 에러 납니다.
*   **한 번만 읽을 수 있음 (Generally)**: `Request` 객체의 본문(body)은 스트림(stream) 기반이라 기본적으로 한 번만 읽을 수 있습니다. `c.req.arrayBuffer()`를 호출해서 본문을 읽었다면, 그 뒤에 `c.req.json()`, `c.req.text()` 같은 다른 본문 읽기 메서드를 또 호출하면 보통 빈 값을 얻거나 에러가 발생합니다. "뷔페 음식은 한 번만 담으세요!" (물론, Hono 내부적으로 캐싱을 하거나 특정 상황에서는 다를 수 있지만, 기본 원칙은 그렇습니다.)
*   **`Content-Type` 헤더와는 별개**: `c.req.arrayBuffer()`는 `Content-Type` 헤더가 뭐든 간에 요청 본문을 그냥 바이너리 덩어리로 읽으려고 시도합니다. 물론, 클라이언트가 `Content-Type: image/png` 같이 올바른 정보를 보내주면 좋겠지만, 이 메서드 자체는 그 헤더에 크게 의존하지 않고 "일단 다 가져와 봐!" 하는 스타일입니다.
*   **큰 데이터 주의**: 매우 큰 파일을 `ArrayBuffer`로 한 번에 메모리에 올리면 서버 메모리가 부족해질 수 있습니다. 이런 경우에는 스트림 API (`c.req.body`를 직접 사용)를 활용해서 데이터를 조각조각 처리하는 것이 더 안전하고 효율적입니다. "코끼리를 통째로 삼키려 하지 마세요."
*   **`ArrayBuffer` 다음 단계**: `ArrayBuffer`는 그냥 "바이트 덩어리"일 뿐, 그 자체로는 내용을 들여다보거나 조작하기 어렵습니다. 보통은 `TypedArray` (예: `Uint8Array`, `Float32Array`)나 `DataView`를 사용해서 `ArrayBuffer`의 특정 부분을 읽거나 씁니다. "원석(ArrayBuffer)을 가공해야 보석(의미 있는 데이터)이 됩니다."
*   **파일 이름 등 메타데이터는 별도 처리**: `c.req.arrayBuffer()`는 순수 파일 내용(바이트)만 가져옵니다. 파일 이름, 원래 `Content-Type` 같은 메타데이터는 `multipart/form-data` 형식을 사용할 경우 다른 파트에서 가져오거나, `Content-Disposition` 헤더 등을 파싱해서 얻어야 합니다. "내용물만 있고, 포장지 정보는 따로 찾아야 해요."