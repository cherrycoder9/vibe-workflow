`raw`
날것 그대로의 `Request` 객체입니다.

```javascript
// 클라우드플레어 워커의 경우
app.post('/', async (c) => {
  const metadata = c.req.raw.cf?.hostMetadata // cf 객체는 클라우드플레어 워커 환경에서만 제공됩니다.
  // ... 뭔가 하겠죠 ...
})
```

---

**얘 뭐 하는 애냐?**
`c.req.raw`는 Hono가 한번 감싸기 전의, 진짜 "쌩" `Request` 객체를 꺼내 쓸 수 있게 해주는 창구입니다. Hono의 `c.req`는 여러 자바스크립트 환경(클라우드플레어 워커, Deno, Bun, Node.js 등)에서 일관된 방식으로 요청 정보를 다룰 수 있도록 표준 `Request` 인터페이스를 기반으로 몇 가지 편의 기능을 추가한 버전이죠. 반면 `c.req.raw`는 Hono가 손대기 전의, 해당 실행 환경이 제공하는 원본 `Request` 객체 그 자체를 가리킵니다. "포장 뜯기 전 내용물"이라고 생각하면 됩니다.

**왜 쓰는데?**
1.  **플랫폼 고유 기능 접근**: 이게 주된 용도입니다. 클라우드플레어 워커에서 제공하는 `cf` 객체(요청이 들어온 데이터센터 정보, TLS 암호화 버전, IP 정보 등 담고 있음)처럼 특정 플랫폼이나 런타임에서만 제공하는 특별한 정보나 기능에 접근해야 할 때 씁니다. Hono의 `c.req`는 표준적인 부분만 다루기 때문에 이런 "지역 특산물"까지는 커버하지 못하거든요. 예시의 `c.req.raw.cf?.hostMetadata`가 바로 이런 경우죠.
2.  **Hono가 아직 지원 안 하는 속성/메서드 사용**: 혹시라도 Hono의 `c.req`가 표준 `Request` 객체의 특정 속성이나 메서드를 (아직) 직접적으로 제공하지 않을 때, `raw` 객체를 통해 우회적으로 접근할 수 있습니다. (물론 Hono는 표준을 잘 따르려고 해서 이런 경우가 흔치는 않습니다.)
3.  **깊은 디버깅**: 요청 객체의 아주 밑바닥 정보까지 들여다봐야 할 때, 원본 객체를 직접 살펴보는 것이 도움이 될 수 있습니다.

**언제 불려 나오냐? (언제 값을 가져오냐?)**
Hono의 라우트 핸들러 함수 안에서 `c.req.raw` 프로퍼티를 참조하는 순간, Hono는 현재 처리 중인 요청의 원본 `Request` 객체를 반환합니다. `c.req` 객체가 만들어질 때 이미 내부적으로 이 원본 객체를 가지고 있기 때문에, `raw`는 그 원본을 그대로 보여주는 거죠.

**쓸 때 꿀팁 및 주의사항:**
*   **환경 의존성 UP! 이식성 DOWN!**: `c.req.raw`를 쓰는 순간, 그 코드는 특정 자바스크립트 환경(예: 클라우드플레어 워커)에 강하게 묶입니다. 나중에 앱을 다른 환경(예: Deno나 Node.js)으로 옮기려고 하면 `c.req.raw`에서 접근하던 속성(예: `cf`)이 없어서 코드가 터질 수 있습니다. "이 코드는 우리 동네에서만 통해요~" 딱지가 붙는 셈이니, 정말 필요할 때만 쓰세요.
*   **타입스크립트 사용자라면 타입 단언 필수**: `c.req.raw`의 타입은 실행 환경마다 다릅니다. 클라우드플레어 워커에서 `cf` 객체를 쓰려면 `(c.req.raw as CfRequest).cf`처럼 타입 단언을 해줘야 타입스크립트 컴파일러가 "아, `cf`가 있는 애구나!" 하고 알아먹습니다. (실제 타입 이름은 `@cloudflare/workers-types`의 `IncomingRequestCfProperties` 등을 조합해서 만듭니다). 안 그러면 `any` 취급받거나 타입 에러 맞기 십상입니다.
*   **옵셔널 체이닝은 습관처럼**: 예시 코드의 `c.req.raw.cf?.hostMetadata`처럼 옵셔널 체이닝(`?.`)을 적극 활용하세요. `cf` 객체나 그 안의 속성들이 항상 존재한다는 보장이 없습니다. 예를 들어 로컬 개발 환경에서 Hono를 돌릴 때는 `cf` 객체가 없을 테니까요. "없으면 말고~" 정신으로 안전하게 코딩해야 합니다.
*   **Hono의 `c.req`와 헷갈리지 말자**: `c.req`는 Hono가 제공하는 편리한 래퍼(wrapper)고, `c.req.raw`는 그 속의 알맹이입니다. 둘 다 `headers`, `method`, `url` 같은 표준 속성을 가지고 있지만, `raw`에는 해당 환경 고유의 "플러스 알파"가 있을 수 있다는 점을 기억하세요.
*   **"최후의 수단"으로 생각**: 가능하면 Hono가 제공하는 `c.req`의 표준적인 방법 (`c.req.json()`, `c.req.param()`, `c.req.header()`, `c.req.url` 등)으로 해결하고, 정말 어쩔 수 없이 플랫폼 특정 기능에 손대야 할 때만 `c.req.raw`를 고려하는 것이 좋습니다. 그래야 코드가 깔끔하고 여러 환경에서 잘 돌아가는 앱을 만들 수 있습니다.