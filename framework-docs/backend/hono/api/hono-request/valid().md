`valid()`
유효성 검사를 통과한 데이터를 가져옵니다.

```javascript
app.post('/posts', async (c) => {
  const { title, body } = c.req.valid('form')
  // ... 뭔가 하겠죠 ...
})
```

사용 가능한 대상은 아래와 같습니다.

*   `form` (폼 데이터)
*   `json` (JSON 바디)
*   `query` (쿼리 파라미터)
*   `header` (요청 헤더)
*   `cookie` (쿠키)
*   `param` (경로 파라미터)

사용 예시는 "유효성 검사(Validation)" 섹션을 참고하세요.

---

**얘 뭐 하는 애냐?**
`c.req.valid()`는 Hono의 유효성 검사 미들웨어(예: `zodValidator`, `joiValidator` 등)를 통과한, 깨끗하고 믿을 수 있는 데이터만 쏙 골라 가져오는 기능입니다. "이거 완전 안전하고 확실한 정품 데이터만 주세요!" 하는 거죠. 핸들러 함수 안에서 `c.req.query()`, `c.req.json()` 대신 이걸 쓰면, 이미 한차례 검증 샤워를 마친 데이터를 바로 쓸 수 있습니다.

**왜 쓰는데?**
1.  **데이터 신뢰도 UP**: "아무거나 막 받지 않겠다!" 사용자가 보낸 데이터가 내가 정한 규칙(스키마)에 맞는지 미리 싹 검사하고, 통과한 놈들만 핸들러로 넘겨줍니다. 이상한 데이터 때문에 서버 터지거나 로직 꼬이는 불상사를 막아주죠.
2.  **보안 강화**: 악의적인 입력값(SQL 인젝션, XSS 등)이나 예상치 못한 타입의 데이터가 시스템 내부로 흘러 들어오는 걸 1차 방어선에서 차단합니다. "수상한 놈들은 여기서부터 입장 불가!"
3.  **코드 간결화 & 가독성 향상**: 핸들러 함수마다 덕지덕지 붙어있던 유효성 검사 코드를 미들웨어로 싹 빼버리니까 핸들러가 깔끔해집니다. "핵심 로직에만 집중하자!"
4.  **타입스크립트랑 찰떡궁합**: Zod 같은 스키마 라이브러리랑 같이 쓰면, `c.req.valid()`로 가져온 데이터는 이미 타입이 딱 정해져 있어서 자동완성도 잘 되고 타입 걱정 없이 개발할 수 있습니다. "이거 타입 뭐였더라?" 고민 끝!

**언제 불려 나오냐?**
반드시 해당 데이터 소스(form, json, query 등)에 대한 유효성 검사 미들웨어가 먼저 실행된 *후에*, 라우트 핸들러 안에서 호출됩니다. 예를 들어 `app.post('/submit', zValidator('form', schema), (c) => { const data = c.req.valid('form'); ... })` 이런 식이죠. 미들웨어가 "검증 완료! 합격!" 도장 찍어준 데이터만 얘가 가져오는 겁니다.

**쓸 때 꿀팁 및 주의사항:**
*   **미들웨어 선행은 국룰**: `c.req.valid()` 쓰기 전에 반드시 해당 타겟에 대한 유효성 검사 미들웨어(예: `zValidator('json', ...)`)를 먼저 등록해야 합니다. 안 그러면 "검증된 데이터가 없는데요?" 하고 에러 나거나 빈 객체만 덩그러니 나올 겁니다. 순서가 생명!
*   **타겟 명시 필수**: `c.req.valid('form')`, `c.req.valid('json')`처럼 어떤 종류의 데이터를 가져올 건지 정확히 알려줘야 합니다. "어떤 데이터 검증한 거 말하는 건데?" 하고 Hono가 되묻지 않게요.
*   **유효성 검사 실패 시?**: 만약 유효성 검사 미들웨어에서 데이터가 규칙에 안 맞는다고 판단하면, 보통 미들웨어가 알아서 에러 응답(예: 400 Bad Request)을 보내고 핸들러는 실행되지도 않습니다. `c.req.valid()`를 호출하는 시점에는 이미 "검증 통과"가 전제된 상황인 거죠.
*   **구조 분해 할당으로 편하게**: `const { name, email } = c.req.valid('json')`처럼 객체 구조 분해 할당을 쓰면 필요한 값만 쏙쏙 뽑아 쓰기 편합니다.
*   **여러 타겟 데이터 가져오기**: 만약 요청 하나에 쿼리 파라미터도 검증하고, JSON 바디도 검증했다면, 핸들러에서 `const queryData = c.req.valid('query')`랑 `const jsonData = c.req.valid('json')` 이렇게 각각 따로 가져올 수 있습니다.
*   **반환값은 검증된 데이터**: `c.req.valid()`는 유효성 검사 스키마에 따라 변환되거나 기본값이 채워진, 최종적으로 "안전하고 올바른" 데이터 객체를 반환합니다. 날것 그대로의 데이터가 아니라는 점!