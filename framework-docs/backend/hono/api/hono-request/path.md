`path`
요청 경로 이름입니다.

```javascript
app.get('/about/me', async (c) => {
  const pathname = c.req.path // '/about/me'가 됩니다.
  // ... 뭔가 하겠죠 ...
})
```

---

**얘 뭐 하는 애냐?**
`c.req.path`는 현재 Hono 앱으로 들어온 HTTP 요청의 URL에서 도메인 뒷부분, 즉 순수한 '경로(path)' 부분만 똑 떼어주는 녀석입니다. 쿼리 스트링(`?name=Hono&version=4`)이나 해시(`#section1`) 같은 군더더기는 다 빼고, 딱 `/about/me`처럼 슬래시로 시작하는 그 경로 정보만 알려주죠. "그래서 손님이 정확히 어느 문으로 들어오셨다고?"를 알려주는 안내원 같은 겁니다.

**왜 쓰는데?**
1.  **정확한 요청 경로 파악**: Hono의 라우터가 이미 `/users/:id` 같은 패턴으로 요청을 잡아줬더라도, 핸들러 안에서 "그래서 지금 들어온 전체 경로가 정확히 뭐였지?" 하고 확인할 때 씁니다. 특히 와일드카드 라우트 (`/files/*`) 같은 걸 쓸 때 유용하죠.
2.  **로깅 및 분석**: 어떤 경로로 요청이 많이 들어오는지, 혹은 특정 경로에서 에러가 자주 나는지 등을 기록하고 분석할 때 핵심 정보로 사용됩니다. "장부에 적어놔! 이 길로 손님 또 오셨네!"
3.  **동적 컨텐츠 제공**: 요청 경로에 따라 다른 리소스를 보여주거나, 경로 자체를 파일 시스템의 경로와 연결 지어 파일을 제공할 때 활용할 수 있습니다.
4.  **조건부 로직**: 특정 경로 또는 경로 패턴에 따라 핸들러 내에서 다른 로직을 수행해야 할 때 `if (c.req.path.startsWith('/admin')) { ... }`처럼 조건을 걸 수 있습니다.

**언제 불려 나오냐?**
Hono의 라우트 핸들러 함수나 미들웨어 함수 안에서 `c` (컨텍스트 객체)를 통해 `c.req.path`를 호출하면, 해당 요청의 경로 문자열을 바로 얻을 수 있습니다. 요청이 Hono 앱에 도착해서 라우팅 과정을 거쳐 특정 핸들러가 실행되는 시점에 이미 확정된 값이죠.

**쓸 때 꿀팁 및 주의사항:**
*   **쿼리 스트링은 없다, 친구야**: `c.req.path`에는 물음표(`?`) 뒤에 오는 쿼리 파라미터가 포함되지 않습니다. 걔네는 `c.req.query('파라미터명')`이나 `c.req.queries()`로 따로 조회해야 합니다. "경로만 드립니다, 옵션은 별도 구매!"
*   **항상 슬래시(`/`)로 시작**: 반환되는 경로는 웹 표준에 따라 항상 슬래시로 시작합니다. 만약 요청이 루트 경로(`http://example.com/`)였다면 `c.req.path`는 그냥 `/`가 됩니다.
*   **URL 디코딩은 기본**: 경로에 `%20`(공백)이나 `%C3%A9`(é)처럼 URL 인코딩된 문자가 포함되어 있었다면, `c.req.path`는 보통 이들이 디코딩된 값(예: 공백, é)으로 나옵니다. "외계어 번역기 기본 탑재!" (대부분의 경우 그렇지만, 아주 특수한 케이스나 원본 그대로 필요하면 `c.req.raw.url` 같은 더 로우레벨 접근이 필요할 수도 있습니다.)
*   **`app.basePath()` 설정 시 주의**: 만약 `app.basePath('/api')`처럼 Hono 앱에 기본 경로를 설정했더라도, `c.req.path`는 전체 요청 경로(예: `/api/users`)를 반환합니다. 베이스 경로를 제외한 상대 경로(`/users`)가 아니라는 점을 기억하세요. "출발점은 항상 서버 루트 기준!"
*   **라우팅 결정 후 참조용**: `c.req.path` 값 자체가 Hono의 라우팅 결정에 직접 쓰인다기보다는, 이미 라우터에 의해 특정 핸들러로 연결된 *후에* 그 핸들러 안에서 "내가 처리 중인 요청의 전체 경로가 뭐였더라?" 하고 참조하는 용도로 더 많이 쓰입니다. 라우팅 매칭은 Hono가 알아서 잘 해줍니다.