`json()`
`application/json` 타입의 요청 본문을 파싱합니다.

```javascript
app.post('/entry', async (c) => {
  const body = await c.req.json() // 요청 본문을 JSON으로 파싱해서 body 변수에 저장
  // ... 뭔가 하겠죠 ...
})
```

---

**얘 뭐 하는 애냐?**
`c.req.json()`은 클라이언트가 HTTP 요청 본문(body)에 담아 보낸 JSON 데이터를 자바스크립트 객체나 배열로 뿅하고 변환시켜주는 마법 같은 녀석입니다. "클라이언트가 보낸 JSON 택배, 내용물 확인!" 딱 이거죠.

**왜 쓰는데?**
1.  **데이터 취급 용이성**: API 서버 만들 때 클라이언트가 보낸 JSON 데이터를 받아서 써야 하는데, 이걸 문자열 그대로 다루려면 골치 아픕니다. `c.req.json()` 쓰면 바로 자바스크립트 객체로 바꿔주니 `body.name`, `body.items` 이런 식으로 바로 써먹을 수 있습니다. 개발자 삶의 질 향상템이죠.
2.  **귀찮은 작업 자동화**: 원래는 요청의 `Content-Type` 헤더가 `application/json`인지 확인하고, 문자열로 된 본문을 `JSON.parse()`로 직접 변환해야 합니다. `c.req.json()`은 이 과정을 알아서 해줍니다. "잔말 말고 데이터나 내놔!" 시전 가능.

**언제 불려 나오냐?**
주로 `POST`, `PUT`, `PATCH`처럼 클라이언트가 서버로 데이터를 전송하는 HTTP 메서드의 요청을 처리할 때, 그 데이터가 JSON 형식으로 온다고 약속된 경우에 핸들러 함수 안에서 `await c.req.json()` 형태로 호출합니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`await`은 필수, 안 쓰면 프로미스 폭탄**: `c.req.json()`은 비동기 함수라 `await` 안 붙이면 결과물 대신 "나중에 줄게~" 하는 프로미스 객체만 덩그러니 받게 됩니다. 데이터는 없고 약속만 있는 거죠. "기다림의 미학을 실천하세요."
*   **`Content-Type` 헤더 확인은 기본**: 클라이언트가 요청 보낼 때 `Content-Type: application/json` 헤더를 빼먹거나 엉뚱한 걸 보내면, `c.req.json()`은 "이거 JSON 아닌데?" 하고 에러를 뱉을 수 있습니다. (Hono는 보통 400 Bad Request로 응답합니다.) "명찰(Content-Type) 똑바로 달고 오세요!"
*   **본문이 비었거나 JSON 형식이 아니면? 에러!**: 클라이언트가 빈 본문을 보내거나, JSON 문법에 안 맞는 문자열(예: 쉼표 빠뜨림, 따옴표 잘못 씀)을 보내면 파싱하다가 에러가 터집니다. 이때 `try...catch`로 감싸서 "손님, 보내신 데이터가 좀 이상한데요?" 하고 친절하게 (또는 안 친절하게) 알려주는 게 좋습니다.
*   **요청 본문은 일회용**: `await c.req.json()`으로 본문을 한 번 읽고 나면, 그 요청의 본문 스트림은 이미 소모된 상태입니다. 그 뒤에 `await c.req.text()`나 다른 본문 파싱 메서드를 또 호출하면 "이미 다 먹고 없는데요?" 하면서 에러가 나거나 빈 값을 돌려줍니다. 뷔페 접시는 한 번만 쓰는 겁니다.
*   **타입스크립트 쓰면 개꿀**: `const body = await c.req.json<UserPayload>()`처럼 제네릭으로 예상되는 데이터 타입을 싹 지정해주면, `body` 변수 쓸 때 자동완성도 되고 타입 체크도 돼서 개발 능률이 쭉쭉 오릅니다. "이름표(타입) 붙여주면 찾기도 쉽고 쓰기도 편하죠."
*   **너무 큰 JSON은 부담스러워**: 클라이언트가 악의적으로 엄청나게 큰 JSON 데이터를 보내면 서버가 파싱하다가 메모리 부족으로 뻗을 수 있습니다. 실제 서비스에서는 요청 크기 제한 같은 안전장치를 마련해두는 게 좋습니다. "과식은 금물!"