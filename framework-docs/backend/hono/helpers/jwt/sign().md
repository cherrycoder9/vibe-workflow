`sign()`
이 함수는 페이로드(payload)를 암호화하고 지정된 알고리즘과 비밀 키(secret)를 사용해서 서명한 뒤, JWT(JSON Web Token)를 생성합니다. "디지털 서명된 비밀 쪽지 만들기"라고 생각하면 쉽습니다.

```typescript
sign(
  payload: unknown, // 서명할 내용물 (아무거나 가능하지만 보통 객체)
  secret: string,   // 나만 아는 비밀 키
  alg?: 'HS256'     // 서명 방식 (기본값은 'HS256')
): Promise<string>; // 비동기 작업 후 문자열 형태의 토큰을 돌려줌
```

**예시**

```typescript
// hono/jwt 에서 sign 함수를 불러온다.
import { sign } from 'hono/jwt'

// 토큰에 담을 정보 (페이로드)
const payload = {
  sub: 'user123', // 토큰 주인 (subject)
  role: 'admin',  // 사용자의 역할
  exp: Math.floor(Date.now() / 1000) + 60 * 5, // 토큰 만료 시간 (지금부터 5분 뒤)
}
const secret = 'mySecretKey' // 서명에 사용할 비밀 키 (절대 노출 금지!)
// 페이로드와 비밀 키로 토큰을 생성! (await 키워드 주목! 비동기 함수임)
const token = await sign(payload, secret)
```

**옵션 상세 설명**

*   **`payload: unknown` (필수)**
    JWT에 담아서 서명할 내용물입니다. 사용자 ID, 역할, 만료 시간 등 원하는 정보를 넣을 수 있습니다. "페이로드 유효성 검사" 부분에서 언급된 다른 클레임(claim)들도 포함할 수 있습니다. (이 쪽지에 뭘 적을 거냐?)
*   **`secret: string` (필수)**
    JWT를 서명하거나 검증할 때 사용하는 비밀 키입니다. 이 키가 노출되면 아무나 유효한 토큰을 만들어낼 수 있으니 절대 안전하게 보관해야 합니다. (이 쪽지 봉인할 때 쓰는 나만의 도장 인주 색깔 같은 거)
*   **`alg: AlgorithmTypes` (선택)**
    JWT 서명 또는 검증에 사용할 알고리즘입니다. 기본값은 `HS256` (HMAC SHA256)입니다. 현재 `hono/jwt`의 `sign` 함수는 `HS256`만 명시적으로 지원하는 것처럼 보입니다. (어떤 방식으로 암호화 서명할 거냐? 기본은 HS256이다.)

---

**얘 뭐 하는 애냐?**
`sign()` 함수는 한마디로 "디지털 신분증 발급기"입니다. 사용자 정보(페이로드)와 비밀 키를 가지고 암호화된 문자열(JWT 토큰)을 뿅 하고 만들어냅니다. 이 토큰은 나중에 서버에 요청 보낼 때 "나 이런 사람인데, 통과시켜줘!" 하는 인증서처럼 쓰입니다. 서버는 이 토큰을 보고 "어, 이거 우리가 발급한 거 맞네? 유효기간도 안 지났고. 오케이, 들어와!" 하고 판단하는 거죠.

**왜 쓰는데?**
1.  **인증 (Authentication)**: 사용자가 로그인 성공하면 서버가 이 JWT 토큰을 발급해줍니다. 사용자는 다음 요청부터 이 토큰을 헤더에 실어 보내고, 서버는 토큰을 검증해서 "아, 아까 그 유저 맞구나!" 하고 인증 처리합니다. 매번 아이디/비번 물어보는 귀찮음을 덜 수 있죠. "클럽 입장 팔찌 같은 거."
2.  **인가 (Authorization)**: 토큰 안의 페이로드에 사용자 역할(예: `role: 'admin'`) 같은 정보를 담아두면, 특정 API에 접근할 때 "너 관리자 권한 없으면 못 들어와!" 하고 권한 체크하는 데 쓸 수 있습니다.
3.  **정보 교환 (Information Exchange)**: 두 시스템 간에 안전하게 정보를 주고받을 때도 씁니다. 토큰 자체가 서명되어 있어서 중간에 누가 내용을 위변조했는지 바로 알 수 있거든요.

**언제 불려 나오냐?**
주로 사용자가 로그인을 성공했을 때, 서버에서 해당 사용자를 위한 JWT 토큰을 생성해서 클라이언트에게 전달해줄 때 호출됩니다. 또는 OAuth 2.0 같은 인증 흐름에서 다른 서비스로부터 받은 정보를 바탕으로 우리 시스템용 토큰을 만들 때도 쓰입니다.

**쓸 때 꿀팁 및 주의사항:**
*   **비밀 키(Secret)는 생명!**: `secret` 값은 절대 코드에 하드코딩하거나 버전 관리 시스템(Git 등)에 올리면 안 됩니다. 환경 변수로 빼서 안전하게 관리해야 합니다. "집 열쇠 아무 데나 던져두면 도둑 드는 거랑 똑같다!" 이게 털리면 시스템 전체가 위험해집니다.
*   **만료 시간(exp)은 필수**: 페이로드에 `exp` (expiration time) 클레임을 꼭 넣어서 토큰의 유효 기간을 설정하세요. 만료 없는 토큰은 보안상 매우 위험합니다. 탈취당하면 영원히 악용될 수 있으니까요. "유통기한 없는 음식은 위험하다."
*   **페이로드에는 민감 정보 최소화**: JWT 페이로드는 Base64로 인코딩된 것뿐이라, 비밀 키를 모르면 내용을 바꿀 순 없지만 누구나 디코딩해서 볼 수는 있습니다. 비밀번호 같은 진짜 민감한 정보는 절대 넣지 마세요. 사용자 ID, 역할, 만료 시간 정도가 적당합니다. "지갑에 주민등록증은 넣어도, 집문서까지 넣고 다니진 않잖아?"
*   **HTTPS는 기본 중의 기본**: JWT 토큰은 HTTP 헤더(주로 `Authorization: Bearer <token>`)를 통해 전송되는데, HTTP로 보내면 중간에 가로채기(스니핑) 당해서 토큰이 털릴 수 있습니다. 반드시 HTTPS를 사용해서 통신 채널 자체를 암호화해야 합니다.
*   **알고리즘 선택**: `HS256`은 대칭키 알고리즘이라 서명과 검증에 같은 비밀 키를 씁니다. 만약 비대칭키(공개키/개인키) 방식인 `RS256` 같은 걸 쓰고 싶다면, `hono/jwt`가 해당 알고리즘과 키 형식을 지원하는지, 그리고 키 관리를 어떻게 할지 추가로 고민해야 합니다. (현재 Hono 문서상 `sign`은 `HS256`만 명시)
*   **토큰 저장 위치 (클라이언트)**: 발급된 토큰을 클라이언트 어디에 저장할지도 중요합니다. 웹 브라우저라면 `localStorage`, `sessionStorage`, `HttpOnly` 쿠키 등이 있는데, 각각 장단점과 보안 고려사항이 다릅니다. XSS 공격 등을 고려해서 안전한 방법을 선택해야 합니다.
*   **토큰 탈취 및 재사용 방지**: 만료 시간을 짧게 가져가고, 리프레시 토큰(Refresh Token) 메커니즘을 도입하거나, 중요 작업 시에는 토큰 외 추가 인증을 요구하는 등 토큰이 탈취되어도 피해를 최소화할 방안을 고민해야 합니다. "팔찌 잃어버려도 바로 입장 못 하게 조치하는 센스!"