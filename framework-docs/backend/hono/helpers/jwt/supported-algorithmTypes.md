이 모듈은 다음과 같은 JWT (JSON Web Token) 암호화 알고리즘을 지원합니다:

*   **HS256**: SHA-256을 사용하는 HMAC (HMAC + SHA256 = HS256, 대칭키 알고리즘계의 국밥)
*   **HS384**: SHA-384를 사용하는 HMAC
*   **HS512**: SHA-512를 사용하는 HMAC
*   **RS256**: SHA-256을 사용하는 RSASSA-PKCS1-v1\_5 (RSA 암호화 + SHA256, 비대칭키 알고리즘계의 스테디셀러)
*   **RS384**: SHA-384를 사용하는 RSASSA-PKCS1-v1\_5
*   **RS512**: SHA-512를 사용하는 RSASSA-PKCS1-v1\_5
*   **PS256**: SHA-256 및 MGF1 (SHA-256 사용)을 사용하는 RSASSA-PSS (RSA-PSS라고도 하며, RS 계열보다 좀 더 최신 보안 권장 사항을 따름)
*   **PS384**: SHA-384 및 MGF1 (SHA-384 사용)을 사용하는 RSASSA-PSS
*   **PS512**: SHA-512 및 MGF1 (SHA-512 사용)을 사용하는 RSASSA-PSS
*   **ES256**: P-256 및 SHA-256을 사용하는 ECDSA (타원 곡선 암호, RSA보다 짧은 키로 비슷한 보안 강도를 제공하는 효율 끝판왕)
*   **ES384**: P-384 및 SHA-384를 사용하는 ECDSA
*   **ES512**: P-521 및 SHA-512를 사용하는 ECDSA
*   **EdDSA**: Ed25519 커브를 사용하는 EdDSA (또 다른 타원 곡선 기반 알고리즘, 빠르고 안전해서 요즘 핫함)

---

**얘네 뭐 하는 애들이냐?**
JWT라는 디지털 신분증(토큰)을 만들거나(서명) 진짜인지 확인할 때(검증) 쓰는 암호화 기술 목록이야. 이 기술들이 있어야 "이 신분증은 위조된 게 아니고, 중간에 누가 내용을 바꾸지도 않았어!" 하고 보증할 수 있거든. 크게 비밀번호 하나만 쓰는 대칭키 방식(HS 계열)이랑, 자물쇠-열쇠 세트처럼 공개키-개인키 쓰는 비대칭키 방식(RS, PS, ES, EdDSA 계열)으로 나눌 수 있어.

**왜 쓰는데?**
1.  **인증 (Authentication)**: 사용자가 로그인하면 서버가 JWT를 발급해주고, 사용자는 다음 요청부터 이 JWT를 제시해. 서버는 JWT가 유효한지 이 알고리즘들로 검증해서 "아, 너 아까 걔 맞구나!" 하고 인증 처리하는 거지. "매번 아이디/비번 물어보기 귀찮으니까, 통행증 하나 발급해줄게!"
2.  **정보 교환 (Information Exchange)**: JWT 안에는 사용자 정보나 권한 같은 데이터를 담을 수 있어. 이 정보가 암호화 알고리즘으로 보호되니까, 중간에 누가 훔쳐보거나 위변조하는 걸 막을 수 있지. "우리끼리만 알아볼 수 있는 암호로 쪽지 주고받기."
3.  **무상태(Stateless) 서버**: 서버가 사용자 세션 정보를 일일이 기억할 필요 없이, 클라이언트가 보내주는 JWT만 검증하면 되니까 서버 확장이 훨씬 쉬워져. "서버는 기억상실증 걸려도 괜찮아, 네가 누군지 네 토큰이 말해주니까!"

**언제 불려 나오냐?**
*   **토큰 발급 시 (Sign)**: 사용자가 로그인 성공했을 때, 또는 다른 서비스에 접근 권한을 부여할 때, 서버에서 JWT를 생성하면서 이 알고리즘 중 하나를 골라 비밀키(HS 계열)나 개인키(RS, PS, ES, EdDSA 계열)로 서명(암호화)하는 데 쓰여.
*   **토큰 검증 시 (Verify)**: 클라이언트가 API 요청 시 JWT를 헤더에 담아 보내면, 서버는 해당 JWT를 발급할 때 사용했던 알고리즘과 공개키(또는 비밀키)를 사용해서 "이거 진짜 우리가 발급한 거 맞나? 유효기간은 안 지났나? 누가 중간에 장난친 건 없나?" 하고 검증하는 데 쓰이지.

**쓸 때 꿀팁 및 주의사항:**
*   **알고리즘 선택은 신중하게**:
    *   **HS 계열 (HMAC + SHA)**: 구현은 간단하지만, 서명과 검증에 같은 비밀키를 써야 해. 그래서 키 관리가 중요하고, 여러 서비스 간에 토큰을 공유할 땐 키 유출 위험이 커. "우리 집 열쇠 아무한테나 맡기면 안 되잖아?" 보통 단일 서비스 내부에서 쓰거나, 키 관리가 확실할 때 선택.
    *   **RS/PS/ES/EdDSA 계열 (비대칭키)**: 개인키는 서버만 안전하게 보관하고, 공개키는 외부에 공개해서 검증에 사용해. 그래서 여러 서비스에서 토큰을 검증해야 할 때 더 안전하고 유연해. 하지만 키 생성/관리가 HS 계열보다 복잡하고, 서명/검증 속도도 일반적으로 느린 편이야. "은행 OTP 생성기처럼, 만드는 놈이랑 쓰는 놈이 달라도 되는 시스템."
*   **키 길이와 보안 강도**: SHA-256, 384, 512 숫자가 클수록, P-256, P-384, P-521 숫자가 클수록 보안 강도가 높아지지만, 그만큼 계산량도 늘어나. 서비스의 보안 요구 수준과 성능 사이에서 적절한 타협점을 찾아야 해. "너무 튼튼한 자물쇠는 열고 닫기도 힘들다."
*   **`none` 알고리즘은 절대 금물**: JWT 스펙에는 `alg: "none"`이라고 해서 서명 안 하는 옵션도 있는데, 이건 테스트 목적 외에는 절대 쓰면 안 돼. "문 열어놓고 도둑맞길 기다리는 격." 라이브러리에서 이 옵션을 기본으로 막아두는 경우가 많지만, 항상 조심해야 해.
*   **라이브러리 최신 버전 유지**: 암호화 알고리즘 자체의 취약점이나 구현상의 버그가 발견될 수 있으니, 사용하는 JWT 라이브러리는 항상 최신 안정 버전을 쓰는 게 좋아. "보안 패치는 나오자마자 바로바로!"
*   **키 관리, 키 관리, 키 관리!**: 어떤 알고리즘을 쓰든, 비밀키나 개인키가 유출되면 모든 게 끝장이야. 안전한 곳에 보관하고, 주기적으로 교체하는 등 키 관리에 만전을 기해야 해. "모든 보안의 시작과 끝은 키 관리."
*   **알고리즘 혼용 주의**: 토큰 발급자와 검증자 간에 사용할 알고리즘을 명확히 합의해야 해. 발급은 HS256으로 해놓고 RS256으로 검증하려고 하면 당연히 실패하겠지? "서로 다른 언어로 대화하면 못 알아듣는다."