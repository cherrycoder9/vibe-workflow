JWT 관련 커스텀 에러 타입들. 이건 `hono/jwt` 같은 JWT(JSON Web Token) 처리 라이브러리에서 주로 볼 수 있는 녀석들이야. 사용자가 어떤 삽질을 했는지, 아니면 토큰 자체가 맛이 갔는지 좀 더 명확하게 알려주려고 미리 정의해둔 에러 종류들이라고 보면 돼.

*   **`JwtAlgorithmNotImplemented`**: "야, 네가 요청한 JWT 알고리즘(예: ES384, PS256)은 우리가 지원 안 하는 거야. 다른 거 써." 라는 뜻. 서버가 특정 암호화 알고리즘만 지원하는데 클라이언트가 듣도 보도 못한 알고리즘으로 만든 토큰을 들이밀 때 발생해.
*   **`JwtTokenInvalid`**: "이 토큰, 뭔가 이상한데? 구조가 깨졌거나, 내용이 말도 안 되거나, 아무튼 정상적인 토큰이 아니야." 토큰 자체가 JWT 표준 규격에 안 맞거나 파싱할 수 없을 때 던져지는 에러. 그냥 "토큰 맛 갔음"의 포괄적인 표현이야.
*   **`JwtTokenNotBefore`**: "이 토큰 아직 사용 시작일 안 됐거든? 김칫국 마시지 마." 토큰에 `nbf` (Not Before) 클레임이 있어서 특정 시간 이후부터 유효한데, 그 시간 전에 사용하려고 할 때 발생. "오픈 시간 전에는 입장 불가!"
*   **`JwtTokenExpired`**: "이 토큰 유효기간 끝났어. 새로 받아와." 토큰에 `exp` (Expiration Time) 클레임으로 지정된 만료 시간을 넘겨서 사용하려고 할 때 발생. 가장 흔하게 볼 수 있는 JWT 에러 중 하나지. "유통기한 지난 우유는 배탈나!"
*   **`JwtTokenIssuedAt`**: "토큰 발급 시간(`iat` 클레임)이 뭔가 이상한데? 미래에서 발급했냐, 아니면 시간이 꼬였냐?" `iat` (Issued At) 클레임 값이 현재 시간보다 미래로 되어 있거나, 시스템적으로 말이 안 되는 시간일 때 발생할 수 있어. (사실 이건 `JwtTokenNotBefore`랑 겹치는 면도 있고, 라이브러리마다 처리 방식이 좀 다를 수 있어.)
*   **`JwtTokenSignatureMismatched`**: "이 토큰 서명, 우리가 아는 거랑 다른데? 누가 중간에 장난쳤거나, 키가 안 맞거나, 아무튼 위조된 것 같아." 토큰의 내용이 변경되었거나, 서명할 때 사용한 비밀키가 검증할 때 사용한 키와 다를 경우 발생. 보안상 가장 중요한 에러 중 하나야. "위조지폐는 사용 불가!"

---

**얘네 뭐 하는 애들이냐?**
이 에러 타입들은 JWT를 검증하는 과정에서 "뭔가 잘못됐다!" 싶을 때, 그냥 "에러!" 하고 뭉뚱그려 알려주는 대신 "정확히 뭐가 문제인지" 콕 집어 알려주는 역할을 해. 개발자 입장에서는 "아, 토큰이 만료된 거구나" 또는 "서명이 안 맞네, 키 확인해봐야겠다" 같이 원인 파악을 훨씬 쉽게 할 수 있지. "의사가 '아프시네요' 대신 '감기몸살입니다'라고 진단해주는 격."

**왜 쓰는데?**
1.  **정확한 오류 진단**: 뭐가 문제인지 알아야 해결도 빠르지. 만료된 건지, 서명이 틀린 건지, 아직 쓸 수 없는 토큰인지에 따라 클라이언트에게 다른 안내를 하거나 서버에서 다른 후속 조치를 취할 수 있어.
2.  **체계적인 예외 처리**: `try...catch` 블록에서 에러 객체의 타입을 확인해서(`if (error instanceof JwtTokenExpired)`), 각 에러 상황에 맞는 맞춤형 처리가 가능해져. 예를 들어, 토큰 만료 시에는 "로그인 세션이 만료되었습니다. 다시 로그인해주세요." 라는 메시지를 보내고 로그인 페이지로 리다이렉트 시킬 수 있지.
3.  **보안 강화**: 특히 `JwtTokenSignatureMismatched` 같은 에러는 잠재적인 보안 위협을 감지하는 신호가 될 수 있어. 이런 에러가 자주 발생한다면 누군가 시스템을 공격하려고 시도하고 있을 가능성도 염두에 둬야 해.
4.  **디버깅 효율 증가**: 로그에 구체적인 에러 타입이 남으면, 나중에 문제 추적할 때 "대체 왜 인증이 안 됐던 거야?" 하고 머리 싸맬 필요 없이 "아, 이때 `JwtTokenNotBefore` 에러가 잔뜩 났었네. 배포 전에 시간 설정 잘못했나 보다." 하고 빠르게 원인을 유추할 수 있어.

**언제 불려 나오냐?**
주로 JWT를 사용하는 미들웨어나 인증 로직 안에서, 클라이언트가 보낸 JWT를 서버가 검증(verify)하는 단계에서 조건에 안 맞으면 해당 에러 객체가 `throw` 돼. 예를 들어 `jwt.verify(token, secret)` 같은 함수를 호출했을 때, 그 결과로 정상적인 디코딩된 페이로드가 나오지 않고 이런 에러들이 튀어나오는 거지.

**쓸 때 꿀팁 및 주의사항:**
*   **에러 메시지는 사용자 친화적으로**: 서버에서 발생한 `JwtTokenExpired` 에러를 클라이언트에게 그대로 보여주면 사용자는 "이게 뭔 소리야?" 할 수 있어. 실제 사용자에게 보여줄 때는 "세션이 만료되었습니다."처럼 쉽고 명확하게 바꿔서 안내해야 해. "개발자용 에러 메시지랑 사용자용 안내는 다르다!"
*   **로깅은 상세하게**: 서버 로그에는 어떤 종류의 JWT 에러가 발생했는지, 가능하다면 어떤 토큰(일부 정보) 때문에 발생했는지 등을 기록해두는 게 좋아. 물론 토큰 전체를 로그에 남기는 건 보안상 위험할 수 있으니 사용자 ID나 토큰 ID 정도만 기록하는 게 안전빵.
*   **클라이언트와의 약속**: API 문서 등을 통해 어떤 경우에 어떤 종류의 에러 응답(HTTP 상태 코드, 에러 코드, 메시지 등)을 주는지 클라이언트 개발자에게 명확히 알려줘야 해. 그래야 클라이언트에서도 상황에 맞게 적절히 대응(예: 토큰 갱신 요청, 로그아웃 처리)할 수 있지.
*   **모든 에러를 다 직접 처리할 필요는 없을 수도**: 프레임워크나 라이브러리가 기본적인 JWT 에러 처리를 이미 해주는 경우도 있어. 예를 들어, Hono 미들웨어에서 JWT 검증 실패 시 알아서 401 Unauthorized 응답을 보내주는 것처럼 말이지. 하지만 특정 에러에 대해 더 세밀한 제어가 필요할 때 이런 커스텀 에러 타입을 활용하는 거야. "자동차가 알아서 잘 굴러가면 그냥 타면 되지만, 튜닝하고 싶을 땐 내부를 알아야 한다."
*   **라이브러리마다 이름은 다를 수 있음**: 여기서 언급된 에러 이름들은 일반적인 예시이고, 실제 사용하는 JWT 라이브러리(예: `jsonwebtoken`, `jose`, Hono 내장 기능 등)에 따라 에러 클래스 이름이나 종류가 조금씩 다를 수 있으니 해당 라이브러리 문서를 꼭 확인해야 해. "같은 기능이라도 제조사마다 모델명이 다른 법."