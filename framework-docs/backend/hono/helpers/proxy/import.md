`hono/proxy`에서 `proxy`를 가져옵니다.

```typescript
import { Hono } from 'hono'
import { proxy } from 'hono/proxy'
```
Proxy Helper는 Hono 애플리케이션을 (리버스) 프록시로 사용할 때 유용한 함수들을 제공합니다.

---

**얘 뭐 하는 애냐?**
`hono/proxy`는 Hono 앱을 다른 서버로 요청을 전달하고 그 응답을 다시 클라이언트에게 돌려주는 "프록시 서버"로 변신시켜주는 도구야. 쉽게 말해, "손님, 저쪽 가게 물건인데 제가 대신 주문해 드릴게요!" 하는 중간상인 역할이지. 클라이언트 요청을 받아서 지정된 다른 서버(백엔드 API 서버, 외부 서비스 등)로 그대로 토스하고, 그 서버가 주는 응답을 받아서 다시 클라이언트한테 전달해주는 거야.

**왜 쓰는데?**
1.  **CORS 문제 해결의 구원투수**: 프론트엔드에서 외부 API 호출하려는데 CORS(Cross-Origin Resource Sharing) 에러 때문에 "접근 불가!" 뜨면 환장하지? 이때 Hono 프록시 서버를 중간에 두면, 브라우저는 같은 출처(Hono 서버)로 요청 보내는 셈이라 CORS 걱정 없이 외부 API 데이터를 가져올 수 있어. "출입증 없이는 못 들어가는 건물, 경비 아저씨(프록시)한테 부탁해서 대신 들어갔다 나오는 격!"
2.  **API 게이트웨이 역할**: 여러 마이크로서비스나 외부 API들을 Hono 프록시 뒤로 숨기고, 클라이언트에게는 단일 진입점(/api/users, /api/products 등)만 제공할 수 있어. 이러면 내부 아키텍처가 바뀌어도 클라이언트는 영향 안 받고, 인증/로깅 같은 공통 기능도 프록시에서 한 방에 처리 가능해. "여러 가게 물건을 한 곳에서 주문받는 백화점 안내데스크!"
3.  **요청/응답 변형**: 클라이언트 요청을 백엔드로 보내기 전이나, 백엔드 응답을 클라이언트로 보내기 전에 내용을 살짝 바꾸거나 헤더를 추가/삭제하는 등의 가공이 필요할 때 프록시에서 처리할 수 있어. (물론 `hono/proxy` 자체 기능보다는 Hono의 다른 미들웨어랑 조합해서 쓰겠지)
4.  **캐싱 또는 로드 밸런싱 (고급)**: 프록시 서버에서 자주 요청되는 응답을 캐싱해뒀다가 바로바로 주거나, 여러 백엔드 서버로 요청을 분산시키는 로드 밸런싱 기능의 기초로도 활용될 수 있어. (이건 `hono/proxy`만으로는 부족하고 추가적인 구현이 필요하겠지만!)

**언제 불려 나오냐?**
Hono 라우트 핸들러 안에서 특정 경로로 오는 요청을 다른 서버로 전달하고 싶을 때 호출해. `proxy()` 함수에 타겟 서버 정보를 넘겨주면 돼.

```typescript
const app = new Hono()

// 예: /api/* 로 오는 모든 요청을 https://api.example.com 으로 프록시
app.all('/api/*', proxy({
  // 타겟 서버 주소 (필수!)
  target: 'https://api.example.com',

  // 옵션: 경로 재작성 (예: /api/users -> /users)
  rewrite: (path) => path.replace(/^\/api/, ''),

  // 옵션: 요청 헤더 수정
  // headers: (headers, req) => {
  //   headers.set('X-My-Custom-Header', 'Hono-Proxy')
  //   return headers
  // },

  // 옵션: 응답 헤더 수정
  // onResponse: (res, c) => {
  //   res.headers.set('X-Powered-By', 'Hono Proxy')
  //   return res
  // }
}))

// 예: 특정 경로만 다른 서비스로
app.get('/weather', proxy({
  target: 'https://weather.service.com/today'
}))
```
위 코드에서 `/api/*`로 시작하는 모든 요청은 `https://api.example.com`으로 전달되고, 필요하면 경로를 다시 쓰거나 헤더를 조작할 수도 있어.

**쓸 때 꿀팁 및 주의사항:**
*   **`target`은 필수, 나머지는 옵션**: `proxy({ target: '여기로보내주세요.com' })` 이게 기본이야. `target` URL에는 프로토콜(http/https)까지 정확하게 적어줘야 해.
*   **경로 재작성(`rewrite`)의 마법**: 클라이언트가 요청한 경로랑 실제 백엔드 서버가 기대하는 경로가 다를 때 `rewrite` 함수로 살짝 바꿔줄 수 있어. 정규표현식 쓰면 더 유연하게 변환 가능! "손님이 '짜장면' 시켰는데, 주방엔 '자장면'으로 주문 넣어야 할 때."
*   **헤더 컨트롤도 가능**: `headers` 옵션으로 백엔드로 가는 요청 헤더를 만지거나, `onResponse` 콜백으로 백엔드에서 온 응답 헤더를 클라이언트에게 보내기 전에 수정할 수 있어. 민감한 내부 정보 헤더를 숨기거나, 프록시 식별 헤더를 추가할 때 유용하지.
*   **에러 처리 및 타임아웃**: 백엔드 서버가 죽었거나 응답이 너무 느릴 때 프록시 서버가 하염없이 기다리거나 에러를 그대로 뱉으면 안 되겠지? Hono의 에러 핸들링 기능이나, 필요하면 `fetch`의 타임아웃 설정을 활용해서 견고하게 만들어야 해. "중간에서 문제 생기면 나라도 정신 차려야지!"
*   **성능 저하는 필연적**: 요청을 한 번 더 거쳐가니까 당연히 응답 속도는 살짝 느려질 수밖에 없어. 아주 민감한 성능이 요구되는 곳에는 신중하게 써야 해. "직거래보다 택배가 하루 더 걸리는 건 당연지사."
*   **보안, 보안, 보안!**: 아무 데로나 프록시 요청을 열어두면 SSRF(Server-Side Request Forgery) 공격에 취약해질 수 있어. 프록시할 수 있는 `target`을 화이트리스트 방식으로 제한하거나, 사용자 입력값을 `target` URL에 직접 쓰지 않도록 각별히 주의해야 해. "아무나 우리 집 전화 빌려 쓰게 하면 안 되잖아?"
*   **스트리밍 응답 지원 여부**: 백엔드가 큰 파일이나 실시간 데이터를 스트리밍으로 보내줄 때, 프록시도 이걸 잘 처리해서 클라이언트에게 스트리밍으로 전달해줘야 해. `hono/proxy`가 기본적인 스트리밍은 지원하겠지만, 복잡한 시나리오에서는 테스트가 필요할 수 있어.