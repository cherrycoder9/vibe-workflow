`proxy()`
`proxy()`는 프록시(proxy)를 위한 `fetch()` API 래퍼(wrapper)야. 파라미터랑 반환값은 `fetch()`랑 똑같다고 보면 돼 (프록시 전용 옵션 몇 개 빼고).

`Accept-Encoding` 헤더는 현재 런타임이 처리할 수 있는 인코딩으로 교체돼. 불필요한 응답 헤더는 삭제되고, 핸들러에서 바로 응답으로 반환할 수 있는 `Response` 객체가 날아올 거야.

**예시**

간단한 사용법:
```typescript
app.get('/proxy/:path', (c) => {
  // originServer에 있는 :path로 요청을 중계한다!
  return proxy(`http://${originServer}/${c.req.param('path')}`)
})
```

좀 복잡한 사용법:
```typescript
app.get('/proxy/:path', async (c) => {
  const res = await proxy(
    `http://${originServer}/${c.req.param('path')}`,
    {
      headers: {
        ...c.req.header(), // 옵션: 모든 요청 데이터를 전달할 때만 (인증 정보 포함)
        'X-Forwarded-For': '127.0.0.1', // 클라이언트 IP 위조 (혹은 명시)
        'X-Forwarded-Host': c.req.header('host'), // 원래 요청받은 호스트 정보 전달
        Authorization: undefined, // 원본 요청의 Authorization 헤더는 전달 안 함! (보안상 중요)
      },
    }
  )
  // 응답 헤더에서 Set-Cookie는 지워버리자 (프록시가 쿠키를 가로채거나 설정하면 곤란하니까)
  res.headers.delete('Set-Cookie')
  return res
})
```

아니면 `c.req` 객체를 통째로 넘길 수도 있어.
```typescript
app.all('/proxy/:path', (c) => {
  return proxy(`http://${originServer}/${c.req.param('path')}`, {
    ...c.req, // 옵션: 모든 요청 데이터를 전달할 때만 (인증 정보 포함)
    headers: {
      ...c.req.header(),
      'X-Forwarded-For': '127.0.0.1',
      'X-Forwarded-Host': c.req.header('host'),
      Authorization: undefined,
    },
  })
})
```

---

**얘 뭐 하는 애냐?**
`proxy()`는 Hono 서버를 중간 다리 삼아서 다른 서버(목표 서버, `originServer`)로 요청을 대신 보내고, 그 응답을 다시 클라이언트에게 전달해주는 역할을 해. "손님, 저쪽 가게 물건 필요하세요? 제가 대신 가서 사다 드릴게요!" 하는 심부름꾼 같은 녀석이지. 웹 표준 `fetch()` API랑 사용법이 거의 똑같아서 배우기 쉬운 게 장점이야.

**왜 쓰는데?**
1.  **CORS 문제 우회**: 브라우저에서 다른 도메인으로 API 요청 보낼 때 CORS(Cross-Origin Resource Sharing) 정책 때문에 막히는 경우가 많은데, 내 서버(Hono)를 프록시로 쓰면 이 문제를 깔끔하게 해결할 수 있어. 브라우저는 내 서버랑만 통신하고, 내 서버가 대신 다른 서버랑 통신하니까 CORS 걱정 끝! "담벼락 넘기 힘들면, 담 안쪽 사람한테 부탁하면 된다."
2.  **API 키 숨기기**: 클라이언트 코드에 외부 API 키를 직접 넣으면 보안상 위험하잖아? 프록시 서버(Hono)에서 API 요청을 대신 보내면서 API 키를 헤더에 살짝 넣어주면 클라이언트는 API 키 존재 자체를 모르게 할 수 있어. "비밀번호는 나만 알고 있을게, 넌 그냥 요청만 해."
3.  **요청/응답 변형**: 목표 서버로 요청 보내기 전에 헤더를 추가/수정하거나, 목표 서버에서 받은 응답을 클라이언트에게 전달하기 전에 내용을 살짝 바꾸는 것도 가능해. 예를 들어, 특정 헤더를 지우거나(`Authorization: undefined`, `res.headers.delete('Set-Cookie')`), 응답 데이터 형식을 바꾸거나 할 수 있지. "배달음식 받아서 내가 만든 것처럼 그릇에 예쁘게 담아주는 센스!"
4.  **캐싱 또는 로깅**: 프록시 서버에서 자주 요청되는 응답을 캐싱해뒀다가 다음 요청에 바로 써먹거나, 모든 요청/응답을 로그로 남겨서 분석하는 용도로도 활용 가능해.
5.  **마이크로서비스 아키텍처**: 여러 개의 작은 서비스(마이크로서비스)로 구성된 시스템에서 API 게이트웨이 역할을 Hono 프록시가 담당할 수도 있어. 클라이언트는 하나의 진입점(Hono)만 바라보고, Hono가 알아서 적절한 마이크로서비스로 요청을 분배하는 거지.

**언제 불려 나오냐?**
Hono 라우트 핸들러 안에서 호출돼. 클라이언트 요청을 받아서, 그 요청을 기반으로 다른 서버에 `fetch` 요청을 날려야 할 때 `proxy()`를 쓰는 거야. `async/await`랑 같이 써서 비동기 처리를 하는 경우가 많아.

**쓸 때 꿀팁 및 주의사항:**
*   **헤더 관리는 신중하게**:
    *   `...c.req.header()`: 클라이언트가 보낸 헤더를 그대로 다 넘기는 건 편하지만, `Cookie`나 `Authorization` 같은 민감한 정보도 같이 넘어갈 수 있으니 조심해야 해. "아무 생각 없이 남의 신분증 통째로 복사해서 주면 큰일 난다!"
    *   `Authorization: undefined`: 원본 요청의 인증 헤더를 목표 서버로 전달하지 않으려면 명시적으로 `undefined`로 설정해서 지워주는 게 좋아. 프록시가 중간에서 인증 정보를 가로채거나 오용하는 걸 막기 위해서지.
    *   `X-Forwarded-For`, `X-Forwarded-Host`: 이런 헤더들은 목표 서버가 "아, 이 요청은 프록시를 거쳐서 왔고, 원래 클라이언트 IP는 이거고, 원래 요청했던 호스트는 이거구나" 하고 알 수 있게 도와주는 표준적인 헤더들이야. 필요에 따라 잘 챙겨 넣어주자.
*   **응답 헤더도 신경 써**: `res.headers.delete('Set-Cookie')`처럼 목표 서버가 설정한 쿠키를 프록시가 중간에서 날려버릴 수도 있고, 반대로 프록시가 새로운 쿠키를 추가할 수도 있어. 의도치 않게 세션이 꼬이거나 보안 문제가 생기지 않도록 응답 헤더도 잘 살펴봐야 해.
*   **에러 처리**: 목표 서버가 에러를 뱉거나 네트워크 문제로 접속이 안 될 수도 있어. `try...catch`로 감싸서 에러 상황에 대한 적절한 처리를 해줘야 클라이언트가 마냥 기다리거나 이상한 화면을 보는 불상사를 막을 수 있어. "심부름 갔는데 가게 문 닫았으면, 손님한테 바로 알려줘야지."
*   **성능**: 모든 요청이 프록시 서버를 한 번 더 거치게 되니까 약간의 지연 시간(latency)이 추가될 수밖에 없어. 아주 민감한 성능이 요구되는 서비스라면 이 점을 고려해야 해.
*   **`c.req` 통째로 넘기기**: `proxy(url, { ...c.req, headers: { ... } })`처럼 `c.req` 객체를 스프레드 연산자로 넘기면 요청 메서드(GET, POST 등), 본문(body) 같은 걸 한 방에 전달할 수 있어서 편하긴 한데, 역시나 불필요하거나 민감한 정보까지 넘어가지 않도록 `headers` 등은 한 번 더 신경 써서 덮어쓰거나 제외하는 게 좋아. "편하다고 막 쓰면 탈 난다."