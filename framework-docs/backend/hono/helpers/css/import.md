`hono/css`에서 `css`, `cx`, `keyframes`, `Style`을 가져옵니다.

```typescript
import { Hono } from 'hono'
import { css, cx, keyframes, Style } from 'hono/css'
```

`css` 헬퍼(`hono/css`)는 Hono에 내장된 CSS-in-JS(X) 기능입니다. `css`라는 이름의 자바스크립트 템플릿 리터럴 안에 JSX 형태로 CSS를 작성할 수 있습니다. `css` 함수의 반환값은 클래스 이름이 되며, 이 값은 `class` 속성의 값으로 설정됩니다. 그러면 `<Style />` 컴포넌트가 해당 CSS의 실제 내용을 담게 됩니다.

---

**얘 뭐 하는 애냐?**
`hono/css`는 자바스크립트 코드 안에서 CSS 스타일을 직접 만들고 적용할 수 있게 해주는 마법 도구 세트입니다. HTML 구조 짜는 JSX 안에서 스타일까지 한 방에 해결하는 거죠. "스타일 시트 파일 따로 만들고 연결하고... 아 귀찮아! 그냥 여기서 다 해버리자!" 하는 개발자들을 위한 기능입니다.

*   `css`: 템플릿 리터럴을 사용해서 CSS 코드를 작성하면, 고유한 클래스 이름을 뱉어냅니다. 이 클래스 이름을 HTML 태그에 `class` 속성으로 넣어주면 스타일이 적용됩니다.
*   `cx`: 여러 개의 클래스 이름을 조건부로 합치거나 그냥 쭉 나열해서 한 번에 적용하고 싶을 때 씁니다. "이 클래스도 넣고, 저 클래스도 넣고, 상황 봐서 요 클래스도 추가!"
*   `keyframes`: CSS 애니메이션 만들 때 쓰는 `@keyframes` 규칙을 자바스크립트 안에서 정의할 수 있게 해줍니다. "버튼이 스르륵 나타나거나 반짝이는 효과, 여기서 뚝딱!"
*   `<Style />`: `css`나 `keyframes`로 만들어진 모든 스타일 규칙들을 모아서 실제로 HTML 문서의 `<head>` 태그 안에 `<style>` 태그 형태로 찍어주는 역할을 합니다. 이게 없으면 `css`로 아무리 클래스 만들어봤자 브라우저는 "이게 뭔데?" 합니다.

**왜 쓰는데?**
1.  **컴포넌트 기반 스타일링**: 스타일을 해당 스타일이 적용될 컴포넌트와 같은 파일에 둘 수 있어서 관리가 편해집니다. "이 버튼 스타일 어디 갔지?" 하고 여러 파일 뒤질 필요 없이 한 곳에서 보고 수정할 수 있죠.
2.  **동적 스타일링 용이**: 자바스크립트 변수나 상태에 따라 스타일을 쉽게 바꿀 수 있습니다. 예를 들어, `props.primary ? 'blue' : 'gray'`처럼 조건에 따라 버튼 색깔을 다르게 하는 게 아주 간편해집니다. "상황 따라 변하는 카멜레온 스타일!"
3.  **스코프 자동 관리 (대부분의 CSS-in-JS 라이브러리 특징)**: `css` 함수가 만들어주는 클래스 이름은 보통 고유한 해시값을 포함해서 다른 컴포넌트의 스타일과 겹칠 걱정이 줄어듭니다. "내 스타일은 나만 쓴다! 옆집이랑 똑같은 옷 입을 일 없음!" (Hono의 `hono/css`는 이 부분이 다른 라이브러리만큼 강력하진 않을 수 있으니 주의는 필요합니다. 주로 전역 스타일을 생성하는 방식에 가깝습니다.)
4.  **자바스크립트 생태계 활용**: CSS 전처리기(Sass, Less) 없이도 자바스크립트의 강력한 기능(함수, 맵, 필터 등)을 활용해서 스타일 로직을 짤 수 있습니다.

**언제 불려 나오냐?**
주로 Hono의 JSX 기반 렌더링을 사용할 때, HTML 구조와 스타일을 한 파일 안에서 같이 정의하고 싶을 때 등장합니다.

```typescript
// 예시 코드 (실제 Hono 앱 구조에 맞게 조정 필요)
const app = new Hono()

// css 함수로 스타일 정의 -> titleClass 라는 클래스 이름 생성
const titleClass = css`
  font-size: 2rem;
  color: blue;
  &:hover { // 가상 클래스도 이렇게!
    color: navy;
  }
`

// keyframes로 애니메이션 정의
const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`

// 애니메이션을 사용하는 클래스
const animatedBoxClass = css`
  width: 100px;
  height: 100px;
  background-color: lightgreen;
  animation: ${fadeIn} 2s ease-in-out;
`

app.get('/', (c) => {
  return c.html(
    <html>
      <head>
        <title>Hono CSS Demo</title>
        {/* Style 컴포넌트가 모든 스타일을 모아서 <style> 태그로 출력 */}
        <Style />
      </head>
      <body>
        {/* 생성된 클래스 이름을 적용 */}
        <h1 class={titleClass}>Hello Hono CSS!</h1>
        <div class={cx(animatedBoxClass, css`border: 2px solid green;`)}>Animated Box</div>
      </body>
    </html>
  )
})
```
위 코드에서 `css`로 `titleClass`, `animatedBoxClass`를 만들고, `keyframes`로 `fadeIn` 애니메이션을 정의했습니다. `<Style />` 컴포넌트가 이 모든 스타일 정보를 `<head>` 안에 넣어줍니다. `cx`는 여러 클래스를 조합할 때 유용합니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`<Style />`은 필수**: `css`나 `keyframes`로 아무리 스타일을 정의해도, 최종적으로 `<Style />` 컴포넌트를 JSX 어딘가(보통 `<head>` 안)에 렌더링해야 실제로 스타일이 적용됩니다. "레시피만 있고 요리사가 없으면 음식이 안 나오는 법."
*   **서버 사이드 렌더링(SSR)과의 궁합**: Hono는 서버 사이드 렌더링에 강점이 있는데, `hono/css`도 SSR 환경에서 잘 돌아갑니다. 서버에서 HTML과 함께 필요한 최소한의 CSS를 생성해서 보내주므로 초기 로딩 성능에 이점이 있을 수 있습니다.
*   **성능 고려**: 자바스크립트로 CSS를 만들고 주입하는 방식이라, 아주 복잡하고 많은 스타일을 전부 CSS-in-JS로 처리하면 런타임 오버헤드가 발생할 수 있습니다. "모든 걸 망치로 해결하려 들면 안 된다." 정적이고 공통적인 스타일은 그냥 전통적인 CSS 파일을 쓰는 게 나을 수도 있습니다.
*   **CSS 표준 문법 준수**: 템플릿 리터럴 안에 들어가는 건 결국 CSS 코드입니다. 오타 나거나 잘못된 속성 쓰면 당연히 스타일 깨집니다. 자동완성이나 린팅 기능이 일반 CSS 파일만큼 강력하지 않을 수 있으니 주의해야 합니다.
*   **다른 CSS-in-JS 라이브러리와의 차이점 인지**: Styled Components, Emotion 같은 전문 CSS-in-JS 라이브러리들은 더 많은 기능(테마, 동적 프롭 기반 스타일링 고급 기능 등)과 최적화 기법을 제공합니다. `hono/css`는 Hono에 내장된 가벼운 대안으로 생각하는 게 좋습니다. "만능 맥가이버 칼은 아니지만, 간단한 작업엔 충분하다."
*   **클래스 이름 디버깅**: 생성되는 클래스 이름이 `css-xxxxxx` 같은 해시 형태로 나오기 때문에, 개발자 도구에서 스타일 디버깅할 때 어떤 스타일이 어디서 왔는지 추적하기 조금 더 번거로울 수 있습니다. (일부 라이브러리는 개발 모드에서 컴포넌트 이름을 포함시켜주기도 합니다.)