`keyframes` (실험적 기능)
`keyframes`를 사용하면 `@keyframes`의 내용을 작성할 수 있습니다. 이 경우, `fadeInAnimation`은 애니메이션의 이름이 됩니다.

```typescript
// keyframes로 애니메이션 정의: "fadeInAnimation"이라는 이름표가 붙는다.
const fadeInAnimation = keyframes`
  from {
    opacity: 0; /* 처음엔 투명하게 */
  }
  to {
    opacity: 1; /* 점점 진하게 나타나라! */
  }
`

// css 헬퍼로 클래스 정의: 위에서 만든 애니메이션 이름을 가져다 쓴다.
const headerClass = css`
  animation-name: ${fadeInAnimation}; /* 애니메이션 이름 지정 */
  animation-duration: 2s;           /* 2초 동안 재생 */
`

// JSX 컴포넌트: 이 클래스를 적용하면 애니메이션이 뿅!
const Header = () => <a class={headerClass}>Hello!</a>
```

---

**얘 뭐 하는 애냐?**
`keyframes`는 CSS 애니메이션의 핵심인 `@keyframes` 규칙을 자바스크립트 코드 안에서 정의할 수 있게 해주는 녀석이야. 복잡한 애니메이션 효과를 만들 때, CSS 파일을 따로 열 필요 없이 컴포넌트 코드 근처에서 바로 만들 수 있게 해주지. "움짤 제조기"라고 생각하면 편해.

**왜 쓰는데?**
1.  **CSS 애니메이션의 재료**: `keyframes`로 애니메이션의 시작(`from` 또는 `0%`)부터 끝(`to` 또는 `100%`), 그리고 중간 단계별 스타일 변화를 정의해. 이렇게 만들어진 애니메이션 이름(위 예제에서는 `fadeInAnimation`)을 `css` 헬퍼 안에서 `animation-name` 속성에 쏙 넣어주면, 해당 HTML 요소가 정의된 대로 움직이거나 변하게 돼.
2.  **가독성 및 관리 용이성**: 애니메이션 로직이 사용되는 컴포넌트와 가까이 있으니 "이 애니메이션은 어떤 효과였더라?" 하고 찾아다닐 필요가 줄어들어. 특히 자바스크립트 변수를 활용해서 동적으로 애니메이션 값을 조절해야 할 때 빛을 발하지. (물론 `hono/css`의 `keyframes`가 어디까지 동적 값을 지원하는지는 확인해봐야 해.)
3.  **CSS-in-JS 생태계의 일관성**: `hono/css`를 써서 스타일을 관리하고 있다면, 애니메이션까지 같은 방식으로 처리해서 코드 스타일의 통일성을 유지할 수 있어.

**언제 불려 나오냐?**
웹 페이지에 동적인 움직임이나 시각적 효과를 주고 싶을 때, 예를 들어 요소가 스르륵 나타나거나, 색깔이 변하거나, 빙글빙글 도는 등의 효과를 구현할 때 `keyframes`를 호출해서 애니메이션 규칙을 만들어. 그리고 그 결과물(애니메이션 이름)을 `css` 헬퍼를 통해 특정 클래스에 `animation-name`으로 할당하는 거지.

**쓸 때 꿀팁 및 주의사항:**
*   **"실험적(Experimental)" 딱지 기억하기**: 공식 문서에서 "Experimental"이라고 명시했다는 건, 아직 기능이 완벽하지 않거나 나중에 바뀔 수도 있다는 뜻이야. 중요한 프로젝트에 막 쓰기 전에 충분히 테스트해보고, 업데이트 소식도 잘 챙겨봐야 해. "얼리어답터는 좋지만, 마루타는 되지 말자."
*   **애니메이션 이름은 변수명**: ``const myAnimation = keyframes`...` `` 이렇게 정의하면, `myAnimation` 변수 자체가 애니메이션 이름(문자열)이 돼. 이걸 `css` 안에서 `${myAnimation}`처럼 템플릿 리터럴로 넣어주면 돼.
*   **`animation-*` 속성들과 짝꿍**: `keyframes`로 애니메이션 내용물만 만드는 거고, 실제로 어떻게 얼마나 오래 재생할지 등은 `animation-duration`, `animation-timing-function`, `animation-iteration-count` 같은 CSS 속성들로 `css` 헬퍼 안에서 따로 지정해줘야 해. "재료(keyframes)만 있다고 요리가 완성되진 않아, 조리법(animation 속성)도 필요해."
*   **브라우저 호환성**: 기본적인 CSS 애니메이션은 대부분의 모던 브라우저에서 잘 돌아가지만, 너무 복잡하거나 최신 스펙을 사용한 애니메이션은 구형 브라우저에서 말썽을 일으킬 수 있어. Can I use 같은 사이트에서 호환성 체크는 필수!
*   **성능 생각하기**: 애니메이션은 잘못 쓰면 웹 페이지 성능을 확 떨어뜨리는 주범이 될 수 있어. 특히 `opacity`나 `transform` 속성 위주로 애니메이션을 만들면 브라우저가 렌더링하기 수월해서 좀 더 부드럽게 돌아가. (이걸 '하드웨어 가속'이라고도 하지.) "화려함도 좋지만, 버벅거리면 다 꽝이다."
*   **`<Style />` 컴포넌트는 여전히 필수**: `keyframes`로 만든 애니메이션도 결국 CSS 규칙의 일부야. `hono/css`를 쓴다면 `<Style />` 컴포넌트가 HTML 어딘가에 반드시 있어야 이 애니메이션 정의가 실제로 페이지에 적용돼.