`hono/streaming`에서 `stream`, `streamText`, `streamSSE`를 가져옵니다.

```typescript
import { Hono } from 'hono'
import { stream, streamText, streamSSE } from 'hono/streaming'
```

스트리밍 헬퍼는 응답을 스트리밍 방식으로 제공하는 메서드들을 지원합니다. 쉽게 말해, 데이터를 한 방에 다 만들어서 보내는 게 아니라, 조금씩 쪼개서 실시간으로 보내주는 거죠. 유튜브 영상 로딩될 때나 챗GPT 답변 생성될 때처럼 말입니다.

---

**얘네 뭐 하는 애들이냐?**
스트리밍 헬퍼 삼총사는 서버에서 클라이언트로 데이터를 실시간으로 쭉쭉 흘려보낼 때 쓰는 특수 배관공들입니다.

*   `stream(c, (stream) => { ... })`: 가장 기본적인 스트리밍 파이프라인입니다. `stream` 객체를 통해 `write()`, `close()` 같은 메서드로 데이터 조각(바이너리 데이터 포함 가능)을 직접 제어하면서 보낼 수 있습니다. "내가 직접 물 양 조절하면서 조금씩 흘려보낼게!" 하는 정교한 작업에 쓰입니다.
*   `streamText(c, async (stream) => { ... })`: 텍스트 데이터를 스트리밍할 때 특화된 버전입니다. 비동기적으로 텍스트 조각들을 생성해서 `stream.write()`로 보내면 됩니다. 주로 긴 텍스트 파일이나, 실시간 로그, AI가 생성하는 텍스트처럼 줄줄이 이어지는 텍스트에 적합합니다. "소설 한 편을 한 글자씩 실시간으로 타이핑해서 보여주는 느낌!"
*   `streamSSE(c, async (stream) => { ... })`: Server-Sent Events (SSE) 규격에 맞춰 데이터를 스트리밍합니다. SSE는 서버가 클라이언트에게 단방향으로 업데이트를 계속 보낼 수 있는 HTML5 표준 기술입니다. 실시간 알림, 주식 시세 업데이트, 라이브 채팅 메시지 같은 곳에 딱이죠. `stream.writeSSE({ data: '메시지', event: '커스텀이벤트', id: '유니크ID' })` 형태로 정해진 포맷에 맞춰 데이터를 보냅니다. "서버가 계속해서 속삭여주는 라디오 방송국!"

**왜 쓰는데?**
1.  **초기 응답 속도 개선 (TTFB 감소)**: 전체 데이터를 다 준비하고 보내려면 사용자는 한참 기다려야 합니다. 스트리밍은 일단 연결되면 뭐라도 먼저 보내주기 시작하니까 사용자가 "어? 뭔가 되고 있네?" 하고 덜 지루해합니다. 특히 용량이 크거나 생성에 오래 걸리는 응답에 효과적입니다. "음식 다 나올 때까지 굶기지 않고 애피타이저 먼저 주는 센스!"
2.  **메모리 효율성 증대**: 거대한 파일이나 데이터를 한 번에 메모리에 다 올려놓고 처리하려면 서버가 힘들어합니다. 스트리밍은 필요한 만큼만 조금씩 처리해서 보내니까 서버 메모리를 아낄 수 있습니다. "창고에 물건 다 쌓아두지 않고, 들어오는 대로 바로바로 내보내는 물류센터."
3.  **실시간 데이터 전송**: 말 그대로 데이터가 생성되는 대로 즉시 클라이언트에게 전달해야 하는 서비스(라이브 스코어, 실시간 대시보드, AI 챗봇 응답 등)에 필수적입니다. "축구 경기 골 들어가는 순간 바로 알려줘야지, 경기 끝나고 알려주면 무슨 소용?"
4.  **무한 스트림 또는 매우 긴 응답 처리**: 이론적으로는 끝나지 않는 데이터 스트림(예: 센서 데이터)을 보내거나, 응답이 언제 끝날지 모르는 경우에도 유용합니다.

**언제 불려 나오냐?**
Hono 라우트 핸들러 안에서 `c` (컨텍스트 객체)와 함께 호출됩니다. 핸들러는 이 스트리밍 함수 중 하나를 `return` 해야 합니다. 스트리밍 함수 내부의 콜백 함수 안에서 `stream` 객체를 통해 데이터를 조금씩 `write`하고, 모든 데이터 전송이 끝나면 `close` (또는 자동으로 닫히도록) 합니다.

```typescript
const app = new Hono()

// streamText 예시: 1초마다 숫자 세기
app.get('/counter', (c) => {
  return streamText(c, async (stream) => {
    for (let i = 0; i < 5; i++) {
      await stream.writeln(`Count: ${i}`) // 줄바꿈과 함께 텍스트 쓰기
      await stream.sleep(1000) // 1초 대기 (실제론 stream.sleep 없음, new Promise(setTimeout) 써야함)
    }
  })
})

// streamSSE 예시: 1초마다 시간 정보 보내기
app.get('/sse', (c) => {
  return streamSSE(c, async (stream) => {
    while (true) {
      const message = `현재 시간: ${new Date().toLocaleTimeString()}`
      await stream.writeSSE({ data: message, event: 'time-update', id: String(Date.now()) })
      // 실제 streamSSE에는 sleep이 없으므로, 외부 Promise를 사용해야 합니다.
      // 예시를 위해 개념적으로만 표현합니다.
      await new Promise(resolve => setTimeout(resolve, 1000)); 
      // 연결이 끊어졌는지 확인하는 로직도 실제로는 필요합니다.
      // 예를 들어, c.req.signal.aborted 등을 확인할 수 있습니다.
      if (c.req.raw.signal.aborted) { // Hono v3 기준, 실제로는 더 복잡할 수 있음
        console.log('Client disconnected');
        break;
      }
    }
  })
})
```
*주의: 위 코드의 `stream.sleep`은 Hono v3 기준으로는 `hono/streaming`에 직접 제공되지 않습니다. `new Promise(r => setTimeout(r, 1000))` 같은 표준 JavaScript 방식을 사용해야 합니다. 또한, SSE 예제에서 `while(true)` 루프는 클라이언트 연결 종료를 감지하고 중단하는 로직이 반드시 필요합니다.*

**쓸 때 꿀팁 및 주의사항:**
*   **`Content-Type` 헤더는 알아서**: `streamText`는 `text/plain`, `streamSSE`는 `text/event-stream`으로 `Content-Type` 헤더를 자동으로 설정해줍니다. `stream`을 직접 쓸 때는 필요하면 수동으로 설정해야 할 수도 있습니다.
*   **에러 처리 꼼꼼하게**: 스트리밍 도중에 에러가 발생하면 클라이언트는 데이터가 중간에 끊긴 채로 멈춰버릴 수 있습니다. `try...catch` 등으로 스트리밍 콜백 내부의 에러를 잘 잡아서 적절히 처리(예: 에러 메시지 스트리밍 또는 연결 종료)해야 합니다. "배관 터지면 물난리 나는 거랑 똑같다."
*   **클라이언트 연결 종료 감지**: 특히 `streamSSE`처럼 오랫동안 연결을 유지하는 경우, 클라이언트가 브라우저를 _닫거나 네트워크가 끊겼을 때 서버 쪽 스트림도 같이 정리해줘야 리소스 낭비를 막을 수 있습니다. `c.req.signal.aborted` (Hono v3 기준, 또는 해당 런타임의 요청 중단 신호)를 주기적으로 확인해서 루프를 빠져나오거나 리소스를 해제해야 합니다. "손님 갔는데 계속 음식 내놓으면 안 되잖아."
*   **압축과의 관계**: 스트리밍 응답은 보통 청크(조각) 단위로 전송되는데, HTTP 압축(gzip, brotli)이 스트리밍과 어떻게 상호작용하는지 이해해두면 좋습니다. 대부분의 경우 잘 동작하지만, 특정 프록시나 설정에서는 예상과 다를 수 있습니다.
*   **프록시 버퍼링 주의**: 중간에 있는 프록시 서버(Nginx, Cloudflare 등)가 응답을 전부 받을 때까지 버퍼링했다가 한 번에 클라이언트에게 전달하려고 할 수 있습니다. 이러면 스트리밍의 장점(빠른 초기 응답)이 사라지죠. 프록시 설정에서 버퍼링을 끄거나 스트리밍에 적합하게 조정해야 할 수 있습니다. "택배 중간에서 멈춰있으면 답답한 거랑 같다."
*   **`stream`의 유연함 vs. `streamText/streamSSE`의 편리함**: 아주 로우레벨 제어가 필요하거나 바이너리 데이터를 스트리밍해야 한다면 `stream`을, 단순 텍스트나 SSE 규격에 맞춘다면 `streamText`나 `streamSSE`를 쓰는 게 코드도 간결하고 편합니다. "상황에 맞는 연장을 쓰자."