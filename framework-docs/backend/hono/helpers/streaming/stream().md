`stream()`
`Response` 객체 형태로 간단한 스트리밍 응답을 반환합니다. "데이터를 한 번에 다 보내는 게 아니라, 잘게 쪼개서 실시간으로 계속 보내줄게!" 하는 방식이죠.

```typescript
app.get('/stream', (c) => {
  // c (컨텍스트)와 스트림 처리 함수를 넘겨준다.
  return stream(c, async (stream) => {
    // 스트림이 중단(aborted)될 때 실행할 작업을 등록할 수 있다.
    // 예를 들어, 클라이언트가 갑자기 연결을 끊어버렸을 때!
    stream.onAbort(() => {
      console.log('아이고, 손님이 가버렸네! (Aborted!)')
    })

    // Uint8Array 형태로 데이터를 써서 보낸다. (이건 "Hello"라는 글자)
    await stream.write(new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]))
    // 다른 ReadableStream을 가져와서 그 내용을 이어서 쭉 보낼 수도 있다.
    // 예를 들어, 파일에서 읽어온 내용을 바로 보낸다거나!
    await stream.pipe(anotherReadableStream)
  })
})
```

---

**얘 뭐 하는 애냐?**
`stream()`은 서버에서 클라이언트로 데이터를 보낼 때, 마치 수도꼭지에서 물 흘려보내듯이 연속적으로, 조각조각 나눠서 보내는 기술을 쉽게 쓸 수 있게 해주는 녀석입니다. 큰 파일을 한 방에 다 로딩해서 보내려면 서버 메모리도 터지고 클라이언트도 하염없이 기다려야 하는데, 스트리밍을 쓰면 데이터가 준비되는 대로 바로바로 보내니까 훨씬 효율적이죠. "뷔페 음식 한 번에 다 담아오지 말고, 먹을 만큼씩 계속 가져다 먹는 느낌!"

**왜 쓰는데?**
1.  **대용량 데이터 전송**: 몇 기가짜리 동영상 파일이나 거대한 CSV 데이터를 통째로 메모리에 올렸다가 보내는 건 자살행위입니다. 스트리밍을 쓰면 파일을 조금씩 읽으면서 바로바로 클라이언트로 흘려보내니까 서버 부담이 확 줄어듭니다. "코끼리도 한 입씩 먹으면 다 먹을 수 있다."
2.  **실시간 데이터 처리**: 서버에서 계속 생성되는 로그 데이터, 주식 시세, 채팅 메시지처럼 실시간으로 업데이트되는 정보를 클라이언트에게 지연 없이 보여줄 때 아주 유용합니다. 데이터가 생길 때마다 바로바로 쏴주는 거죠.
3.  **응답 시작 시간 단축 (Time To First Byte, TTFB 개선)**: 전체 데이터를 다 처리하고 응답을 시작하는 게 아니라, 첫 번째 데이터 조각이라도 준비되면 바로 보내기 시작하니까 클라이언트 입장에서는 "어? 뭔가 오기 시작했다!" 하고 더 빨리 느끼게 됩니다. 웹 성능 최적화에 중요한 지표죠.
4.  **메모리 효율성**: 데이터를 한꺼번에 메모리에 다 들고 있을 필요가 없으니 서버 메모리를 아낄 수 있습니다. 특히 동시 접속자가 많은 서비스에서는 이게 엄청난 차이를 만듭니다.

**언제 불려 나오냐?**
Hono 라우트 핸들러 안에서 `return stream(c, async (stream) => { ... })` 형태로 호출합니다. `stream` 콜백 함수 안에서 `stream.write()`로 데이터를 직접 써서 보내거나, `stream.pipe()`로 다른 읽기 가능한 스트림(예: 파일 스트림, 다른 API 응답 스트림)을 연결해서 그 내용을 그대로 전달할 수 있습니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`async/await`는 기본**: 스트림 작업은 본질적으로 비동기입니다. `stream` 콜백 함수는 `async`로 선언하고, 내부의 `stream.write()`, `stream.pipe()` 같은 작업 앞에는 `await`를 붙여서 데이터가 제대로 전송될 때까지 기다려줘야 합니다. "급할수록 돌아가라, 비동기는 기다림의 미학."
*   **에러 처리 및 중단 처리(`onAbort`)**: 스트리밍 중에 네트워크 연결이 끊기거나 클라이언트가 브라우저를 닫아버리는 등 예기치 않은 상황이 발생할 수 있습니다. `stream.onAbort()` 콜백을 등록해서 이런 상황에 대처(예: 리소스 정리, 로그 남기기)해야 합니다. "손님이 갑자기 나가도 뒷정리는 해야지."
*   **데이터 형식은 `Uint8Array`**: `stream.write()`로 직접 데이터를 쓸 때는 `Uint8Array` 형태로 넘겨줘야 합니다. 문자열을 보내고 싶으면 `new TextEncoder().encode("보낼 문자열")` 같은 식으로 변환해야 합니다. "컴퓨터는 0과 1밖에 모른다. 문자도 숫자로 바꿔서 줘."
*   **`Content-Type` 헤더 설정**: 스트리밍으로 어떤 종류의 데이터를 보내는지 클라이언트에게 알려줘야 합니다. 예를 들어, 일반 텍스트면 `c.header('Content-Type', 'text/plain; charset=UTF-8')`, JSON 스트림이면 `application/octet-stream`이나 `application/x-ndjson` 등을 상황에 맞게 설정해줘야 브라우저나 클라이언트가 제대로 해석할 수 있습니다. `stream()` 함수 자체에서 자동으로 해주지 않는 경우가 많으니 직접 챙겨야 합니다.
*   **압축과의 관계**: 스트리밍 데이터도 압축해서 보내면 효율이 더 좋아집니다. `Transfer-Encoding: chunked`와 함께 `Content-Encoding: gzip` 같은 헤더를 적절히 사용하면 좋습니다. (Hono나 실행 환경에 따라 자동 처리될 수도 있습니다.)
*   **클라이언트 측 처리**: 서버에서 스트리밍으로 보냈으면 클라이언트에서도 스트리밍으로 받아 처리해야 그 효과를 제대로 누릴 수 있습니다. 브라우저의 `fetch` API는 기본적으로 스트리밍 응답을 지원합니다 (`response.body`가 ReadableStream).
*   **너무 잘게 쪼개면 역효과**: 데이터를 너무 작은 조각으로 나눠서 `stream.write()`를 자주 호출하면 오히려 오버헤드가 발생할 수 있습니다. 적절한 크기로 묶어서 보내는 게 좋습니다. "밥알 하나씩 떠먹여주면 감질난다."