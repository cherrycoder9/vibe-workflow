스트리밍 헬퍼의 세 번째 인자는 에러 핸들러입니다. 이 인자는 선택 사항이며, 지정하지 않으면 에러는 콘솔 에러로 출력됩니다.

```typescript
app.get('/stream', (c) => {
  return stream(
    c,
    async (stream) => {
      // 중단되었을 때 실행될 프로세스를 작성합니다.
      stream.onAbort(() => {
        console.log('중단됨!')
      })
      // Uint8Array를 씁니다. (예: "Hello"를 바이트 배열로)
      await stream.write(
        new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]) // H e l l o
      )
      // 읽기 가능한 스트림을 파이프로 연결합니다.
      await stream.pipe(anotherReadableStream) // 다른 스트림 데이터를 쭉쭉 보내!
    },
    (err, stream) => { // 에러 발생 시 이 함수가 호출됨
      stream.writeln('에러 발생!') // 클라이언트에게도 에러 메시지 스트리밍
      console.error(err) // 서버 콘솔에도 에러 기록
    }
  )
})
```

콜백 함수들이 실행된 후 스트림은 자동으로 닫힙니다.

**경고**

스트리밍 헬퍼의 콜백 함수에서 에러가 발생하면, Hono의 `onError` 이벤트는 트리거되지 않습니다.

`onError`는 응답이 전송되기 전에 에러를 처리하고 응답을 덮어쓰기 위한 훅입니다. 하지만, 스트리밍 콜백 함수가 실행될 때는 이미 스트림 전송이 시작되었으므로, 응답을 덮어쓸 수 없습니다. (이미 물은 엎질러졌고, 스트림은 흐르기 시작했다는 뜻!)

---

**얘 뭐 하는 애냐?**
Hono에서 스트리밍 방식으로 데이터를 찔끔찔끔 나눠 보낼 때, 그 과정에서 혹시라도 에러가 터지면 "아이고, 망했네!" 하고 끝내는 게 아니라, "음, 문제가 생겼군. 일단 클라이언트한테는 이렇게 알려주고, 우리는 원인을 파악해보자" 하고 뒷수습하는 역할을 하는 녀석이야. 스트리밍 작업 중 발생하는 예외 상황을 전문적으로 처리하는 응급 구조팀 같은 거지.

**왜 쓰는데?**
1.  **우아한 에러 처리**: 스트리밍 중에 에러가 나면 클라이언트는 영문도 모르고 연결이 뚝 끊기거나 이상한 데이터를 받을 수 있어. 에러 핸들러를 쓰면 "죄송합니다, 데이터 전송 중 문제가 발생했습니다. 잠시 후 다시 시도해주세요." 같은 친절한 메시지를 스트림에 담아 보낼 수 있지. "손님, 요리 중에 불이 나서 잠시 중단합니다!" 하고 알려주는 격.
2.  **서버 안정성 유지**: 예기치 않은 에러가 스트리밍 전체를 멈추고 서버까지 다운시키는 걸 막아줘. 에러를 적절히 잡아서 로깅하고, 필요한 조치를 취한 뒤 스트림을 안전하게 종료할 수 있게 해.
3.  **디버깅 용이**: 에러 발생 시 `console.error(err)` 등으로 에러 객체 내용을 자세히 기록해두면, 나중에 "대체 왜 스트리밍이 터졌지?" 하고 원인 분석할 때 아주 요긴한 단서가 돼. "CCTV로 사고 현장 돌려보는 느낌."

**언제 불려 나오냐?**
`stream()` 셔틀의 세 번째 승객으로 탑승해. 첫 번째는 컨텍스트(`c`), 두 번째는 실제 스트리밍 로직을 담은 비동기 함수, 그리고 세 번째가 바로 이 에러 처리 함수야. 스트리밍 로직(두 번째 콜백 함수) 안에서 `await` 키워드로 뭔가 하다가 `Promise`가 거부(reject)되거나, 명시적으로 에러를 `throw` 하면 이 세 번째 에러 핸들러가 "출동!" 하고 호출돼.

**쓸 때 꿀팁 및 주의사항:**
*   **`stream.writeln()`으로 클라이언트에게 알림**: 에러 핸들러 안에서 `stream.writeln('뭔가 잘못됐어요!')`처럼 클라이언트에게 보낼 메시지를 스트림에 직접 쓸 수 있어. 이미 스트림이 시작된 상태라 일반적인 HTTP 응답(상태 코드 변경 등)은 못 바꾸지만, 스트림 내용으로나마 상황을 전달하는 거지.
*   **`console.error(err)`는 국룰**: 서버 쪽에서는 에러의 상세 내용을 콘솔에 찍어서 기록으로 남겨야 해. 에러 객체(`err`)에는 보통 에러 메시지, 스택 트레이스 등이 담겨 있어서 문제 해결에 큰 도움이 돼.
*   **Hono의 전역 `onError`는 안 먹힘 (중요!)**: 이게 핵심인데, 스트리밍 콜백 안에서 터진 에러는 Hono 앱 레벨에 설정한 `app.onError((err, c) => { ... })` 핸들러가 못 잡아. 왜냐? `onError`는 HTTP 응답 헤더를 보내기 "전에" 뭔가 해보려는 놈인데, 스트리밍은 이미 헤더 보내고 몸통 데이터 찔끔찔끔 보내는 중이거든. "이미 출발한 기차는 세울 수 없다." 그래서 스트리밍 전용 에러 핸들러가 따로 필요한 거야.
*   **`stream.onAbort()`와는 다름**: `stream.onAbort()`는 클라이언트가 브라우저를 닫거나 요청을 취소해서 연결이 "정상적으로" 중단됐을 때 호출되는 거고, 에러 핸들러는 스트리밍 로직 "내부에서" 예외가 발생했을 때 호출돼. 목적이 다르니 헷갈리지 말자.
*   **자원 정리**: 만약 스트리밍 중에 외부 파일 핸들이나 DB 커넥션 같은 자원을 열었다면, 에러 핸들러 안에서 이런 자원들을 깨끗하게 닫아주는 코드를 넣는 게 좋아. 안 그러면 자원 누수로 서버가 빌빌댈 수 있어. "뒷정리는 깔끔하게!"
*   **에러 핸들러 자체에서 또 에러 나면?**: 그건... 답이 없다. 최대한 에러 핸들러는 단순하고 견고하게 짜야 해. "구조팀이 조난당하면 안 되잖아."