웹소켓 헬퍼로 정의된 핸들러는 RPC 모드를 지원합니다.

```typescript
// server.ts (서버 측 코드)
const wsApp = app.get(
  '/ws', // '/ws' 경로로 웹소켓 요청이 오면
  upgradeWebSocket((c) => { // 웹소켓 연결로 업그레이드!
    // ... 여기에 웹소켓 연결 후 로직 (메시지 수신, 발신 등)을 넣는다.
  })
)

// wsApp의 타입을 뽑아서 WebSocketApp 이라는 이름으로 내보낸다.
// 클라이언트에서 이 타입을 써서 서버 함수들을 안전하게 호출할 수 있게 된다.
export type WebSocketApp = typeof wsApp

// client.ts (클라이언트 측 코드)
// 서버에서 정의한 WebSocketApp 타입을 사용해서 hc (Hono Client)를 초기화한다.
// 'http://localhost:8787'은 서버 주소.
const client = hc<WebSocketApp>('http://localhost:8787')

// hc 인스턴스에서 웹소켓 객체를 가져온다. 이제 이 socket으로 통신하면 된다.
const socket = client.ws.$ws() // 클라이언트용 웹소켓 객체
```

---

**얘 뭐 하는 애냐?**
여기서 말하는 "RPC 모드"는 Hono의 웹소켓 기능을 쓸 때, 클라이언트(브라우저나 다른 프로그램)가 마치 서버에 있는 함수를 자기 코드에서 직접 호출하는 것처럼 쉽게 통신할 수 있게 해주는 방식이야. 복잡한 메시지 포맷이나 요청/응답 로직을 직접 짤 필요 없이, Hono가 알아서 "함수 호출하듯" 만들어준다는 거지. "서버 함수, 내 것처럼 편하게 쓰자!"

`upgradeWebSocket`은 HTTP 요청을 웹소켓 연결로 "업그레이드" 시켜주는 Hono의 마법사야. 클라이언트가 "/ws" 같은 특정 경로로 웹소켓 연결을 시도하면, 얘가 받아서 "자, 이제부터 너랑 나는 웹소켓으로 대화한다!" 하고 길을 터주는 거지.

`hc` (Hono Client)는 서버에서 정의한 Hono 앱의 타입 정보를 활용해서, 클라이언트 쪽에서도 타입 체크의 축복을 받으며 안전하게 서버 API(여기서는 웹소켓 연결)를 호출할 수 있게 해주는 라이브러리야.

**왜 쓰는데?**
1.  **개발 편의성 극대화**: 클라이언트에서 `socket.send(JSON.stringify({ type: 'sendMessage', payload: 'hello' }))` 이런 식으로 복잡하게 메시지 만들고 파싱할 필요 없이, `await client.api.chat.sendMessage.$post({ json: { message: 'hello' } })` (HTTP RPC 예시) 나 웹소켓의 경우 정해진 방식으로 함수 호출하듯 서버 기능을 쓸 수 있게 돼. (웹소켓 RPC는 `hono/rpc`를 통해 좀 더 명시적으로 구현될 때 빛을 발하는데, 여기서는 `hc`를 통한 타입 안전성과 연결의 용이성에 초점) "그냥 함수 부르듯이 서버랑 대화하기, 얼마나 편해?"
2.  **타입 안전성 (TypeScript의 축복)**: 서버(`WebSocketApp` 타입 정의)와 클라이언트(`hc<WebSocketApp>`)가 같은 타입 정보를 공유하니까, 함수 이름이나 파라미터를 잘못 쓰면 컴파일 시점에 에러를 딱 잡아줘. "오타 나서 밤새 삽질할 일 줄여준다, 개꿀!"
3.  **자동 직렬화/역직렬화 (기대 효과)**: RPC 시스템은 보통 데이터 주고받을 때 JSON 등으로 알아서 변환(직렬화/역직렬화)해주는 기능이 포함돼. 개발자는 순수 자바스크립트 객체나 값만 다루면 되니 편하지. (Hono의 웹소켓 RPC도 이런 편의를 제공하려는 목적이 있어.)

**언제 불려 나오냐?**
클라이언트와 서버 간에 실시간 양방향 통신이 필요하고, 그 통신 로직을 함수 호출처럼 깔끔하게 만들고 싶을 때 써. 예를 들어 실시간 채팅, 협업 도구, 게임 상태 동기화 같은 기능을 만들 때 유용하지.

서버에서는 `app.get('/ws', upgradeWebSocket(...))` 형태로 특정 경로에 웹소켓 핸들러를 설정하고, 그 핸들러의 타입을 `export type WebSocketApp = typeof wsApp`처럼 뽑아내.
클라이언트에서는 이 타입을 `hc<WebSocketApp>('서버주소')` 형태로 Hono Client에 알려주고, `client.ws.$ws()`를 호출해서 웹소켓 연결 객체를 얻어내서 통신을 시작하는 거야.

**쓸 때 꿀팁 및 주의사항:**
*   **`hono/rpc`와의 관계**: Hono에는 `hono/rpc`라는 별도의 RPC 라이브러리가 있어. 이게 HTTP 요청을 함수 호출처럼 만들어주는 데 특화되어 있고, 웹소켓과도 연동될 수 있어. 여기서 말하는 "RPC 모드"는 `hc`와 타입 공유를 통해 웹소켓 통신도 마치 원격 함수를 호출하는 듯한 개발 경험을 제공하려는 Hono의 철학을 반영한 거라고 이해하면 돼. 완전한 의미의 웹소켓 RPC 프레임워크 기능은 `hono/rpc` 문서를 더 자세히 봐야 할 수도 있어.
*   **타입 동기화는 생명**: 서버에서 API 정의(타입)가 바뀌면, 클라이언트 프로젝트에서도 해당 타입을 업데이트해줘야 타입 안전성의 이점을 제대로 누릴 수 있어. 안 그러면 컴파일은 통과했는데 런타임에서 "그런 함수 없는데요?" 할 수 있다고. "설계도 바뀌었는데 옛날 설계도로 집 지으면 망한다."
*   **웹소켓 자체의 복잡성은 여전함**: RPC 모드가 편의성을 제공하긴 하지만, 웹소켓 연결 관리(끊김, 재연결, 에러 처리 등)의 기본적인 복잡성은 여전히 개발자가 신경 써야 할 부분이야. "자동 운전 차라도 운전대는 잡고 있어야지."
*   **`$ws()`의 의미**: `hc` 클라이언트에서 `.ws`는 웹소켓 관련 엔드포인트를 지칭하고, 그 뒤에 붙는 `.$ws()`는 실제 웹소켓 연결 객체를 생성하고 반환하는 특별한 호출이야. 일반적인 HTTP GET 요청의 `$get()`이나 POST 요청의 `$post()`와는 구분되는 웹소켓 전용 메서드라고 보면 돼.
*   **서버-클라이언트 간의 약속**: RPC는 결국 클라이언트와 서버가 "이런 이름으로 부르면 이런 데이터를 주고받기로 하자"는 약속(API 명세)을 잘 지켜야 원활하게 돌아가. 타입 시스템이 이 약속을 강제하는 데 도움을 주는 거고.
*   **에러 처리**: 네트워크는 항상 불안정할 수 있고, 서버 로직에서 에러가 날 수도 있어. RPC 호출 시 발생할 수 있는 에러에 대한 처리를 클라이언트와 서버 양쪽에서 꼼꼼하게 해줘야 안정적인 서비스를 만들 수 있어. "예외 처리 안 하면 서비스 터지는 건 시간문제."