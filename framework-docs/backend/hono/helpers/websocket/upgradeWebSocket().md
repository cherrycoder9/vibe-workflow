`upgradeWebSocket()`
`upgradeWebSocket()`은 웹소켓(WebSocket)을 다루기 위한 핸들러를 반환합니다. HTTP 연결을 웹소켓 연결로 "업그레이드" 시켜주는 녀석이죠.

```typescript
const app = new Hono()

app.get(
  '/ws', // '/ws' 경로로 GET 요청이 오면 웹소켓으로 전환 시도!
  upgradeWebSocket((c) => { // 여기서 c는 일반 HTTP 요청 컨텍스트
    // 이 안쪽은 웹소켓 연결이 성공한 후의 로직
    return {
      onMessage(event, ws) { // 클라이언트가 메시지 보내면 발동!
        console.log(`클라이언트 메시지: ${event.data}`)
        ws.send('서버에서 안녕!') // 서버도 메시지 발사!
      },
      onClose: () => { // 연결 끊기면 발동!
        console.log('연결 끊김')
      },
      // onError(event) { console.error('에러 발생!', event.error) }, // 에러 나면 발동!
      // onOpen(event, ws) { console.log('연결 성공!') }, // 연결 성공 시 발동! (Cloudflare Workers는 현재 미지원)
    }
  })
)
```

**사용 가능한 이벤트들:**

*   `onOpen`: 웹소켓 연결이 성공적으로 열렸을 때 발생. (주의: 현재 Cloudflare Workers에서는 지원 안 함)
*   `onMessage`: 클라이언트로부터 메시지를 수신했을 때 발생.
*   `onClose`: 웹소켓 연결이 닫혔을 때 발생.
*   `onError`: 오류가 발생했을 때 발생.

**⚠️ 경고 ⚠️**

웹소켓 헬퍼를 사용하는 라우트에 헤더를 수정하는 미들웨어(예: CORS 적용)를 함께 사용하면, "변경 불가능한 헤더를 수정할 수 없습니다"라는 에러를 만날 수 있습니다. 왜냐하면 `upgradeWebSocket()` 함수도 내부적으로 헤더를 변경하기 때문입니다.

따라서 웹소켓 헬퍼와 미들웨어를 동시에 사용할 때는 주의해야 합니다. (한마디로, "얘네 둘이 같이 쓰면 머리 아플 수 있으니 조심해!")

---

**얘 뭐 하는 애냐?**
`upgradeWebSocket()`은 일반적인 HTTP 요청/응답 방식에서 벗어나, 서버와 클라이언트가 실시간으로 양방향 통신을 할 수 있는 "웹소켓" 연결로 갈아타게 해주는 마법사 같은 녀석입니다. 클라이언트가 "저 웹소켓 쓰고 싶은데요?" 하고 특정 경로(`예: /ws`)로 요청하면, 서버가 "오케이, 그럼 지금부터 웹소켓으로 대화하자!" 하고 연결 통로를 열어주는 거죠.

**왜 쓰는데?**
1.  **실시간 양방향 통신**: 채팅 앱, 실시간 알림, 온라인 게임, 주식 시세 업데이트처럼 서버와 클라이언트가 지연 없이 계속 데이터를 주고받아야 하는 서비스 만들 때 필수입니다. HTTP는 클라이언트가 요청해야 서버가 응답하는 단방향 구조라 이런 거 만들기 빡세거든요. "계속 새로고침 안 해도 알아서 정보가 뿅뿅!"
2.  **낮은 지연 시간 (Low Latency)**: 한 번 연결되면 그 통로를 계속 쓰기 때문에, 매번 연결 맺고 끊는 HTTP보다 훨씬 빠릿빠릿하게 데이터를 주고받을 수 있습니다.
3.  **서버 푸시 가능**: HTTP에서는 서버가 먼저 클라이언트한테 말 걸기 힘들지만, 웹소켓은 서버가 원할 때 언제든지 클라이언트에게 데이터를 쏴줄 수 있습니다. "손님, 주문하신 메뉴 나왔습니다!" 하고 서버가 먼저 알려주는 격.

**언제 불려 나오냐?**
Hono 라우트 핸들러 자리에 `upgradeWebSocket()`을 넣어서 사용합니다. 클라이언트가 해당 경로로 웹소켓 연결을 요청하면, `upgradeWebSocket`이 HTTP 요청을 웹소켓 프로토콜로 전환 처리하고, 그 결과로 반환된 객체 안에 정의된 `onMessage`, `onClose` 등의 이벤트 핸들러들이 실제 웹소켓 통신을 담당하게 됩니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`onOpen`의 플랫폼 의존성**: Cloudflare Workers 같은 특정 환경에서는 `onOpen` 이벤트가 지원되지 않을 수 있다는 점을 기억해야 합니다. "모든 기능이 어디서나 똑같이 돌아가진 않는다." 필요하다면 다른 방식으로 연결 성공을 감지하거나, `onMessage`를 처음 받았을 때 초기화 로직을 수행하는 것도 방법입니다.
*   **헤더 수정 미들웨어와의 충돌 주의**: 이게 진짜 중요한데, `upgradeWebSocket()` 자체가 응답 헤더를 건드려서 웹소켓 핸드셰이크를 처리합니다. 그런데 그 앞에 CORS 설정 같은 헤더 수정 미들웨어가 끼어들어서 헤더를 먼저 바꿔버리면, `upgradeWebSocket`이 "어? 이거 내가 쓰려던 헤더인데 누가 건드렸네? 나 일 못 해!" 하고 에러를 뿜을 수 있습니다. 웹소켓 라우트에는 헤더 건드리는 미들웨어를 최대한 피하거나, 아주 신중하게 순서를 조정해야 합니다. "선빵필승이 아니라, 순서 잘못 꼬이면 다 망한다."
*   **상태 관리**: 웹소켓 연결은 한 번 맺어지면 계속 유지됩니다. 그래서 각 연결별로 사용자 정보나 상태를 어딘가에 저장하고 관리해야 할 수 있습니다. (예: 채팅방에 누가 있는지, 특정 유저에게만 메시지 보내기 등). 이건 `upgradeWebSocket` 자체가 해주는 게 아니라 개발자가 직접 구현해야 하는 부분입니다. "연결만 해준다고 끝이 아니다. 뒷수습은 네 몫!"
*   **에러 처리의 중요성**: `onError` 핸들러를 잘 구현해서 네트워크 문제나 예기치 않은 오류 발생 시 적절히 대응해야 합니다. 그냥 `console.log`만 찍고 넘어가면 실제 서비스에서는 문제 파악도 어렵고 사용자 경험도 나락 갑니다.
*   **보안 고려**: 웹소켓도 결국 네트워크 통신입니다. 인증/인가 로직을 잘 구현해서 아무나 함부로 웹소켓 연결 맺고 서버 자원 축내거나 이상한 데이터 보내지 못하게 막아야 합니다. `upgradeWebSocket` 콜백 함수의 첫 번째 인자인 `c` (HTTP 컨텍스트)를 활용해서 초기 연결 시점에 쿠키나 토큰을 검증할 수 있습니다. "문단속 철저히!"
*   **클라이언트 라이브러리**: 서버에서 `upgradeWebSocket`으로 웹소켓을 열었으면, 클라이언트(브라우저, 앱 등)에서도 웹소켓 클라이언트 라이브러리 (브라우저 내장 `WebSocket` API 등)를 써서 접속해야 합니다. 서로 규격이 맞아야 대화가 통하겠죠?