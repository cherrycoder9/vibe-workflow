`createMiddleware()`
`createMiddleware()`는 `factory.createMiddleware()`를 줄여 쓰는 간편한 방법이야. 네가 직접 커스텀 미들웨어를 만들고 싶을 때 쓰는 함수지. "나만의 중간 점검맨 만들기" 딱 그거야.

```typescript
// createMiddleware 함수를 소환! (어디서 임포트하는지는 안 나왔지만, Hono 팩토리 기능의 일부겠지)
// import { createMiddleware } from 'hono/factory' // 아마 이럴 듯?

// 간단한 메시지 미들웨어 만들기
const messageMiddleware = createMiddleware(async (c, next) => {
  // 일단 다음 미들웨어나 핸들러로 공을 넘기고 (await next())
  await next()
  // 그쪽 일이 다 끝나면 돌아와서 응답 헤더에 X-Message 추가!
  c.res.headers.set('X-Message', 'Good morning!')
})

// 팁: 미들웨어에 인자를 넘기고 싶다고? 함수로 한 번 더 감싸면 돼!
const poweredByMiddleware = (message: string) => {
  return createMiddleware(async (c, next) => {
    await next()
    // 이제 인자로 받은 message를 헤더에 뙇!
    c.res.headers.set('X-Powered-By', message)
  })
}

// 이렇게 써먹으면 된다.
// app.use(poweredByMiddleware('My Awesome Server'))
```

---

**얘 뭐 하는 애냐?**
`createMiddleware()`는 Hono 앱에서 요청(Request)이 실제 라우트 핸들러에 도달하기 전이나, 핸들러가 응답(Response)을 생성한 후에 특정 작업을 끼워 넣을 수 있는 "커스텀 부품"을 만드는 함수야. "공장 라인에 나만의 검수 로봇 추가하기" 같은 거지. 요청/응답을 중간에서 가로채서 뭔가 특별한 일을 하도록 프로그래밍하는 거야.

**왜 쓰는데?**
1.  **공통 로직 재활용**: 여러 라우트에서 반복적으로 사용되는 코드(예: 로깅, 인증 체크, 요청 데이터 검증, 응답 헤더 추가 등)를 미들웨어로 만들어두면 코드 중복을 줄이고 관리가 편해져. "여기저기 복붙하던 코드, 이제 한 곳에서 해결!"
2.  **요청/응답 변형**: 들어오는 요청을 살짝 수정하거나(예: 특정 헤더 추가/삭제), 나가는 응답에 공통적인 정보를 덧붙일 수 있어(예: `X-Powered-By` 헤더 추가, 응답 시간 기록).
3.  **선처리/후처리 작업**: 실제 핸들러 실행 전에 사전 준비 작업을 하거나(예: 사용자 인증), 핸들러 실행 후에 마무리 작업을 할 때(예: 에러 처리, 응답 압축) 유용해.
4.  **플러그인/확장 기능 개발**: Hono 자체 기능 외에 필요한 기능을 미들웨어 형태로 만들어서 앱에 쉽게 붙였다 뗐다 할 수 있어. "레고 블록처럼 기능 조립하기!"

**언제 불려 나오냐?**
`createMiddleware()`로 만든 미들웨어는 Hono 앱의 `app.use()` (모든 경로에 적용) 또는 특정 라우트 메서드 (`app.get()`, `app.post()` 등)의 인자로 등록돼. 요청이 해당 경로로 들어오면, 등록된 순서대로 미들웨어들이 줄줄이 실행되는 거야.

미들웨어 함수 안에서는 보통 두 가지 인자를 받아:
*   `c`: 컨텍스트(Context) 객체. 요청(`c.req`), 응답(`c.res`), 변수 공유(`c.set()`, `c.get()`) 등 Hono의 핵심 기능에 접근할 수 있어.
*   `next`: 다음 미들웨어나 라우트 핸들러를 호출하는 함수. `await next()`를 호출해야 요청 처리가 다음 단계로 넘어가. 이걸 호출 안 하면 거기서 요청 처리가 멈춰버리니 주의! (일부러 막을 때도 쓰지만)

**쓸 때 꿀팁 및 주의사항:**
*   **`await next()`는 생명줄 (대부분의 경우)**: `await next()`를 호출해야 다음 미들웨어나 최종 핸들러로 제어권이 넘어가. 이걸 빼먹으면 요청이 중간에 길을 잃고 "어? 나 어디로 가야 해?" 상태가 돼. 물론, 특정 조건에서 요청을 여기서 끝내버리고 싶을 땐 일부러 호출 안 할 수도 있어 (예: 인증 실패 시 바로 401 응답).
*   **`next()` 호출 전후로 코드 실행**:
    *   `await next()` **전에** 코드를 넣으면: 요청이 핸들러로 가기 전에 실행됨 (선처리).
    *   `await next()` **후에** 코드를 넣으면: 핸들러가 일을 마치고 응답이 생성된 후에 실행됨 (후처리). 이걸로 응답 내용을 바꾸거나 헤더를 추가할 수 있지.
*   **에러 처리는 `try...catch`로**: 미들웨어나 `await next()` 호출 과정에서 에러가 터질 수 있으니, `try...catch`로 감싸서 우아하게 처리하는 게 좋아. 안 그러면 앱 전체가 뻗을 수도 있어. "안전망은 촘촘할수록 좋다."
*   **컨텍스트(`c`)는 만능 도구상자**: `c.req`로 요청 객체에 접근해서 헤더나 바디를 읽고, `c.res`로 최종 응답을 조작할 수 있어. `c.set('userId', 123)`처럼 값을 저장해두면 다음 미들웨어나 핸들러에서 `c.get('userId')`로 꺼내 쓸 수도 있지. (단, `c.res`는 `await next()` 이후에 조작해야 의미가 있는 경우가 많아.)
*   **미들웨어 체인 순서가 중요**: `app.use()`로 여러 미들웨어를 등록하면, 등록한 순서대로 실행돼. 순서가 꼬이면 의도치 않은 결과가 나올 수 있으니 "줄 잘 서라!"
*   **인자 받는 미들웨어 만들기 (팩토리 패턴)**: 예제처럼 미들웨어 자체를 함수로 한 번 더 감싸면, 미들웨어에 설정을 위한 인자를 넘겨줄 수 있어. `messageMiddleware('Hello')`처럼 말이지. 이러면 더 유연하고 재사용성 높은 미들웨어를 만들 수 있어. "옵션 조절 가능한 맞춤형 부품!"
*   **비동기(`async/await`)는 기본**: 미들웨어 함수는 보통 `async`로 선언하고, `next()` 호출은 `await`를 붙여줘. Hono가 비동기 처리에 최적화되어 있어서 이게 자연스러워.