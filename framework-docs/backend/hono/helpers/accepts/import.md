`hono/accepts`에서 `accepts`를 가져옵니다.

```typescript
import { Hono } from 'hono'
import { accepts } from 'hono/accepts'
```
위 코드는 Hono 프레임워크에서 `accepts`라는 미들웨어를 사용하려고 할 때, 해당 기능을 프로그램 안으로 불러들이는 주문 같은 겁니다. 쉽게 말해 "야, `accepts` 너 이리 와서 일 좀 해!" 하고 호출하는 거죠. 이 `accepts`가 있어야 클라이언트가 어떤 형식의 데이터를 원하는지 알아챌 수 있습니다.

---

**얘 뭐 하는 애냐?**
`accepts`는 클라이언트가 HTTP 요청 보낼 때 같이 딸려오는 `Accept`, `Accept-Language`, `Accept-Encoding` 같은 헤더들을 쫙 스캔해서 "아하, 이 손님은 JSON 데이터를 제일 좋아하고, 한국어를 선호하며, 데이터는 gzip으로 압축해줘도 괜찮다고 하는군!" 하고 파악하는 똑똑한 점원 역할입니다. 서버가 HTML, JSON, XML 등 다양한 메뉴를 준비해놨을 때, 손님 취향에 딱 맞는 걸로 골라주는 거죠.

**왜 쓰는데?**
1.  **콘텐츠 맞춤 제작 (콘텐츠 협상)**: 똑같은 URL(/api/info)로 요청이 들어와도, 브라우저가 요청하면 예쁜 HTML 페이지를, 앱이나 다른 프로그램이 요청하면 데이터만 깔끔하게 담긴 JSON을 보내주는 식으로 맞춤형 응답이 가능해집니다. "손님, 일반석 드릴까요, 비즈니스석 드릴까요?" 하는 느낌이죠.
2.  **글로벌 서비스 (다국어 지원)**: 클라이언트가 `Accept-Language: ko` 헤더를 보내면 한국어 페이지를, `en`을 보내면 영어 페이지를 보여주는 식으로 국제적인 서비스를 할 때 필수입니다. "어서 오세요"와 "Welcome"을 구분하는 센스!
3.  **데이터 전송 효율 UP (압축)**: 클라이언트가 `Accept-Encoding: gzip`처럼 압축된 데이터를 받을 수 있다고 알려주면, 서버는 데이터를 압축해서 보내줍니다. 이러면 데이터 크기가 줄어서 전송 속도도 빨라지고 트래픽 비용도 아낄 수 있습니다. "이삿짐 싸는데, 부피 줄여서 트럭 한 대로 끝내는 격!"

**언제 불려 나오냐?**
Hono 앱에 미들웨어로 등록해서 씁니다. `app.use('/api/*', accepts())`처럼 특정 경로의 모든 요청에 대해 미리 작동하게 하거나, `app.get('/data', accepts(), (c) => { ... })`처럼 특정 라우트 핸들러가 실행되기 직전에 끼어들어 "손님 정보 스캔 완료!" 상태로 만들어줍니다. 그러면 핸들러 안에서 `c.req.accepts(['application/json', 'text/html'])` 같은 코드로 "손님, JSON이랑 HTML 중에 뭐가 더 좋으세요?" 하고 물어보고 최적의 응답을 결정할 수 있습니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`Accept` 헤더는 보기보다 복잡함**: `text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8` 이런 식으로 우선순위(q-factor)까지 덕지덕지 붙어서 옵니다. `accepts` 미들웨어가 이걸 깔끔하게 파싱해서 "그래서 뭘 제일 원하는데?"를 알려주니 개발자는 편하죠.
*   **"우리 식당 메뉴판입니다" (서버 지원 목록 명시)**: `c.req.accepts(['application/json', 'text/html'])`처럼 서버가 실제로 제공할 수 있는 콘텐츠 타입 목록을 배열로 딱 알려줘야 합니다. 그래야 `accepts`가 클라이언트 선호도랑 비교해서 "아, 이 손님은 JSON을 원하지만 HTML도 괜찮다고 하니, 우리 가게 주력 메뉴인 JSON으로 드리자!" 하고 제대로 매칭해줍니다. 목록에 없으면 "그런 거 안 파는데요?" 시전.
*   **선택과 집중이 중요**: 모든 클라이언트의 모든 취향을 다 맞춰주려고 하면 서버 로직만 복잡해지고 유지보수는 안드로메다로 갑니다. 핵심적인 몇 가지 포맷이나 언어만 확실하게 지원하는 게 현실적입니다. "뷔페도 모든 음식이 다 맛있진 않다."
*   **기본값 설정은 생명줄**: 클라이언트가 `Accept` 헤더를 아예 안 보내거나, 서버가 지원 못 하는 것만 달라고 떼쓸 수도 있습니다. 이럴 때를 대비해서 "묻지도 따지지도 않고 기본은 HTML입니다" 같은 기본 응답 포맷을 정해두는 게 안전빵입니다.
*   **캐시 서버와의 밀당, `Vary` 헤더**: 콘텐츠 협상을 사용했다면, 응답 헤더에 `Vary: Accept` (또는 `Accept-Language` 등)를 꼭 포함시켜야 합니다. 이게 없으면 중간에 있는 캐시 서버들이 "어? 이 URL은 항상 똑같은 내용이네?" 하고 착각해서, JSON 받아야 할 손님한테 HTML 주고, 한국어 사용자한테 영어 페이지 주는 대참사가 날 수 있습니다. `hono/accepts`가 어느 정도는 챙겨주지만, 원리는 알아두는 게 좋습니다. "옆 테이블 김치찌개 시켰는데 왜 나한테 된장찌개 주냐고!"
*   **테스트는 실전처럼**: 다양한 `Accept` 관련 헤더(종류, 우선순위, 누락 등)를 조합해서 Postman 같은 툴로 직접 쏴보면서 서버가 의도대로 똑똑하게 반응하는지 반드시 확인해야 합니다. "대충 테스트하면 서비스 터진다."