`hono/body-limit`에서 `bodyLimit`을 가져옵니다.

```typescript
import { Hono } from 'hono'
import { bodyLimit } from 'hono/body-limit'
```

Body Limit 미들웨어는 요청 본문(request body)의 파일 크기를 제한할 수 있습니다.

이 미들웨어는 먼저 요청 헤더에 `Content-Length` 값이 있으면 그 값을 사용합니다. 만약 `Content-Length` 헤더가 설정되어 있지 않으면, 스트림으로 본문을 읽어 지정된 파일 크기보다 클 경우 에러 핸들러를 실행합니다.

---

**얘 뭐 하는 애냐?**
`bodyLimit` 미들웨어는 클라이언트가 서버로 보내는 데이터(요청 본문)의 크기를 감시하는 문지기 역할을 합니다. "야, 너 너무 무거운 짐 들고 왔어! 이 정도까지만 반입 가능해!" 하고 정해진 용량을 초과하는 요청을 중간에 딱 차단해버리는 거죠. 주로 파일 업로드나 대용량 JSON 페이로드 같은 걸 받을 때 서버가 터지는 걸 막기 위해 씁니다.

**왜 쓰는데?**
1.  **서버 보호 (DoS 방어)**: 악의적인 사용자가 엄청나게 큰 파일을 한꺼번에 보내서 서버 메모리를 터뜨리거나 네트워크 대역폭을 점유해버리는 서비스 거부(DoS) 공격을 어느 정도 막을 수 있습니다. "우리 서버는 소중하니까요."
2.  **자원 관리**: 서버가 처리할 수 있는 요청 크기에 한계가 있으니, 미리 상한선을 정해두면 불필요한 자원 낭비를 막고 안정적인 서비스 운영에 도움이 됩니다. "뷔페에서 음식 남기면 벌금 내는 거랑 비슷."
3.  **애플리케이션 레벨 제한**: 특정 엔드포인트에서는 작은 JSON만 받고 싶은데, 다른 곳에서는 큰 파일 업로드를 허용해야 할 때 유용합니다. 각 라우트별로 다른 제한을 걸 수 있거든요.

**언제 불려 나오냐?**
Hono 앱에 미들웨어로 등록해서 씁니다. 보통 파일 업로드 처리 라우트나 POST/PUT 요청을 받는 API 엔드포인트 앞에 붙여서 사용합니다.

```typescript
const app = new Hono()

// 모든 /upload 경로로 들어오는 요청에 대해 본문 크기를 10MB로 제한
app.use(
  '/upload/*',
  bodyLimit({
    maxSize: 10 * 1024 * 1024, // 10MB (바이트 단위로 설정)
    onError: (c) => { // 용량 초과 시 실행될 에러 핸들러
      return c.json({ error: 'Request body too large!' }, 413) // 413 Payload Too Large
    },
  })
)

app.post('/upload/image', async (c) => {
  // 이 핸들러는 bodyLimit 미들웨어를 통과한 요청만 받음
  const body = await c.req.parseBody()
  // ... 파일 처리 로직 ...
  return c.json({ message: 'File uploaded successfully!' })
})

// 특정 라우트에만 적용할 수도 있음
app.post(
  '/submit-small-data',
  bodyLimit({
    maxSize: 1024, // 1KB
    onError: (c) => c.text('Data too large', 413),
  }),
  async (c) => {
    const data = await c.req.json()
    return c.json({ received: data })
  }
)
```
위 코드처럼 `app.use()`로 특정 경로 패턴에 적용하거나, 특정 라우트 핸들러 바로 앞에 미들웨어로 끼워 넣을 수 있습니다. `maxSize` 옵션으로 최대 크기를 바이트 단위로 지정하고, `onError` 콜백 함수로 용량 초과 시 클라이언트에게 보낼 응답을 커스터마이징할 수 있습니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`Content-Length` 헤더 우선**: 클라이언트가 요청 헤더에 `Content-Length`를 포함해서 보내면, `bodyLimit`은 일단 그 값을 믿고 검사합니다. 만약 이 헤더 값이 `maxSize`보다 크면 바로 차단! 스트림을 실제로 읽어보지도 않아서 효율적이죠.
*   **스트리밍 읽기**: `Content-Length` 헤더가 없거나 부정확할 경우 (예: 청크 인코딩), `bodyLimit`은 요청 본문을 스트림으로 조금씩 읽으면서 크기를 체크합니다. 읽다가 `maxSize`를 넘어가면 "어이쿠, 너무 크네!" 하고 `onError` 핸들러를 호출합니다.
*   **`onError` 핸들러는 필수**: 용량 초과 시 어떤 응답을 보낼지 `onError` 콜백으로 명확히 정의해줘야 합니다. 안 그러면 Hono 기본 에러 핸들러가 작동하거나, 클라이언트는 뭐가 문제인지 모를 수 있습니다. HTTP 상태 코드로는 `413 Payload Too Large`를 쓰는 게 일반적입니다.
*   **단위는 바이트(Byte)**: `maxSize` 설정할 때 헷갈리지 마세요. `10 * 1024 * 1024`는 10MB입니다. `10`만 덜렁 쓰면 10바이트짜리 파일도 못 올리는 대참사가...
*   **글로벌 vs. 라우트별 설정**: 앱 전체에 기본 제한을 걸고 특정 라우트에서만 다른 제한을 적용하는 식으로 유연하게 설정할 수 있습니다. 하지만 너무 복잡하게 꼬이면 관리하기 힘들어지니 적당히!
*   **파일 업로드 라이브러리와의 관계**: `c.req.parseBody()` 같은 Hono의 내장 파서나 다른 멀티파트 폼 데이터 처리 라이브러리를 사용하기 "전에" `bodyLimit` 미들웨어가 먼저 실행되어야 효과가 있습니다. 이미 파싱 다 하고 나서 크기 제한하면 늦어요. "소 잃고 외양간 고치는 격."
*   **너무 작은 제한은 금물**: 너무 빡빡하게 제한을 걸면 정상적인 요청도 막힐 수 있으니, 서비스 성격에 맞게 적절한 크기를 설정하는 게 중요합니다. "손님은 왕인데, 문턱이 너무 높으면 안 오겠죠?"