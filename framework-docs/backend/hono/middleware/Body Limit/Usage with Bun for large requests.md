Hono의 `bodyLimit` 미들웨어를 사용해서 기본값보다 큰 요청 본문을 허용하려고 할 때, Bun 자체의 요청 본문 크기 제한 설정도 같이 손봐줘야 할 수 있어. 이 글을 쓰는 시점 기준으로, Bun의 `Bun.serve`가 받아들이는 요청 본문의 기본 제한 크기는 128MiB (메비바이트)야. 만약 Hono의 `bodyLimit` 미들웨어에서 이 128MiB보다 큰 값을 `maxSize`로 설정하더라도, Bun이 먼저 "너무 커!" 하고 요청을 막아버리기 때문에 Hono의 `onError` 핸들러는 호출되지도 못하고 요청은 실패할 거야. Bun이 Hono에게 요청을 넘기기도 전에 413 상태 코드를 찍고 연결을 끊어버리거든. "문지기(Hono) 만나기도 전에 입구컷(Bun) 당하는 셈이지."

그래서 Hono와 Bun을 함께 사용하면서 128MiB보다 큰 요청을 받고 싶다면, Bun의 설정에도 더 큰 값을 명시해줘야 해:

**첫 번째 방법 (export default 형태):**
```typescript
export default {
  port: process.env['PORT'] || 3000, // 포트 설정은 원래 하던 대로
  fetch: app.fetch, // Hono 앱의 fetch 함수를 연결
  maxRequestBodySize: 1024 * 1024 * 200, // 여기에 원하는 최대 크기를 바이트 단위로! (예: 200MiB)
}
```

**두 번째 방법 (`Bun.serve` 직접 호출 형태):**
```typescript
Bun.serve({
  fetch(req, server) {
    // 필요하다면 여기서 클라이언트 IP 주소 같은 추가 정보도 Hono로 넘겨줄 수 있어
    return app.fetch(req, { ip: server.requestIP(req) })
  },
  maxRequestBodySize: 1024 * 1024 * 200, // 여기도 마찬가지로 원하는 최대 크기를 바이트 단위로!
})
```

---

**얘 뭐 하는 애냐? (앞선 `bodyLimit` 설명과 이어짐)**
앞서 설명한 Hono의 `bodyLimit` 미들웨어는 애플리케이션 레벨에서 요청 크기를 제한하는 녀석이었지? 근데 Bun 같은 런타임 환경은 그보다 한 단계 앞에서, 즉 HTTP 요청을 받자마자 자체적으로 크기 제한을 둘 수 있어. 이 설명은 "Hono에서 아무리 '나 200MB까지 받을 수 있어!' 외쳐도, 그 앞에서 Bun이 '우리 동네는 128MB 넘으면 출입금지야!' 하고 막아버리면 소용없다"는 걸 알려주는 거야.

**왜 이런 걸 알아야 하는데?**
1.  **이중 필터링 이해**: 요청은 [인터넷] -> [Bun 런타임] -> [Hono 앱] 순서로 들어와. 각 단계마다 크기 제한 필터가 있을 수 있다는 걸 알아야 해. Hono의 `bodyLimit`은 두 번째 필터고, Bun의 `maxRequestBodySize`는 첫 번째 필터인 셈이지. "공항 보안 검색대도 여러 개잖아? 첫 번째 검색대에서 걸리면 두 번째 검색대는 구경도 못 한다."
2.  **`onError` 핸들러가 안 먹히는 이유 파악**: "분명 Hono `bodyLimit`에 `onError` 멋지게 설정해놨는데 왜 실행이 안 되지?" 싶을 때, 바로 이 Bun의 자체 제한 때문일 가능성이 높아. Bun이 먼저 요청을 잘라버리니 Hono는 구경도 못 하는 거지.
3.  **대용량 파일 업로드 설정**: 만약 네 서비스가 진짜 큰 파일(예: 150MB짜리 동영상)을 받아야 한다면, Hono `bodyLimit`의 `maxSize`만 늘려서는 안 되고, Bun의 `maxRequestBodySize`도 그보다 크거나 같게 설정해줘야 정상적으로 작동해. "두 개의 문을 모두 통과해야 최종 목적지에 도달할 수 있다."

**언제 이런 설정이 필요하냐?**
Hono를 Bun 환경에서 사용하면서, Bun의 기본 요청 본문 크기 제한인 128MiB를 초과하는 데이터를 받아야 할 때. 예를 들어, 고화질 동영상 업로드, 대용량 데이터 백업 파일 전송 같은 기능을 구현한다면 반드시 `Bun.serve` 설정에서 `maxRequestBodySize` 값을 Hono의 `bodyLimit`에 설정한 `maxSize`와 같거나 더 크게 맞춰줘야 해.

**쓸 때 꿀팁 및 주의사항:**
*   **단위 통일 및 계산 주의**: `maxRequestBodySize`도 바이트 단위로 설정해야 해. `1024 * 1024 * 200`은 200MiB를 의미하지. 괜히 단위 헷갈려서 0 하나 더 붙이거나 빼면 의도치 않은 크기로 설정될 수 있으니 조심!
*   **메모리 사용량 고려**: 요청 본문 크기 제한을 너무 크게 풀면, 동시에 여러 사용자가 큰 파일을 올릴 때 서버 메모리가 부족해질 수 있어. 서버 스펙과 예상 트래픽을 고려해서 적절한 값을 설정해야 해. "뷔페 접시 크다고 음식 다 담으면 결국 남긴다."
*   **Hono `bodyLimit`은 여전히 유효**: Bun의 제한을 풀었다고 해서 Hono의 `bodyLimit`이 필요 없는 건 아니야. Bun의 설정은 런타임 레벨의 1차 방어선이고, Hono의 `bodyLimit`은 애플리케이션 레벨에서 좀 더 세밀하게 경로별로 다른 제한을 두거나, 커스텀 에러 처리를 하는 데 여전히 유용해.
*   **다른 런타임도 마찬가지일 수 있음**: Bun뿐만 아니라 Node.js (예: Express의 `body-parser` 미들웨어 자체 제한), Deno 등 다른 런타임이나 웹 서버(Nginx, Apache)도 자체적인 요청 크기 제한 설정을 가질 수 있어. Hono 앞단에 뭐가 있느냐에 따라 비슷한 상황이 발생할 수 있다는 걸 염두에 둬야 해. "문제 생기면 레이어별로 다 까봐야 한다."