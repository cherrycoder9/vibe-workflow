# CSRF Protection

CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조) 공격을 막기 위한 미들웨어다. 요청 헤더를 까서 이게 진짜 사용자가 보낸 요청인지 확인하는 방식으로 작동한다.

구체적으로는 `Origin` 헤더 값이랑 실제 요청된 URL을 비교해서, 엉뚱한 데서 보낸 폼(form) 제출 같은 걸로 장난치는 CSRF 공격을 차단한다. "너네 집에서 보낸 택배 아니면 안 받는다, 이거지."

다만, `Origin` 헤더를 안 보내는 구닥다리 브라우저 쓰거나, 리버스 프록시 같은 거 설정해서 `Origin` 헤더를 홀랑 날려 먹는 환경에서는 이 미들웨어가 제대로 힘을 못 쓸 수 있다. 그런 환경이라면 다른 CSRF 토큰 방식을 알아보는 게 좋다. "환경 탓하지 말고, 대안을 찾아라."

**임포트**

```javascript
import { Hono } from 'hono'
import { csrf } from 'hono/csrf'
```

**사용법**

```javascript
const app = new Hono()

app.use(csrf()) // 기본빵

// origin 옵션으로 허용할 출처 지정하기
// 문자열 하나
app.use(csrf({ origin: 'myapp.example.com' }))

// 문자열 배열 (여러 개)
app.use(
  csrf({
    origin: ['myapp.example.com', 'development.myapp.example.com'],
  })
)

// 함수로 커스텀 검증 로직 (고급 기술)
// 이 경우, 프로토콜(https 등)까지 포함해서 지정된 출처와 정확히 일치하는지 꼼꼼히 검증하는 걸 강력 추천한다.
// 특히 정규식을 쓸 때는 `$` 메타문자를 활용해 문자열 끝까지 정확히 일치하는지 확인해야 한다.
// 절대! 네버! 앞부분만 대충 일치하는 방식(forward match)으로 검증하면 안 된다. (예: `evil-myapp.example.com`도 통과되는 수가 있음)
app.use(
  '*',
  csrf({
    origin: (origin) =>
      /https:\/\/(\w+\.)?myapp\.example\.com$/.test(origin), // 예: https://myapp.example.com 또는 https://sub.myapp.example.com 만 허용
  })
)
```

**옵션**

*   `origin` (선택 사항): `string | string[] | Function`
    허용할 출처(Origin)를 지정한다. 문자열, 문자열 배열, 또는 커스텀 검증 함수를 쓸 수 있다.

---

**얘 뭐 하는 애냐?**
Hono 프레임워크에서 CSRF(사이트 간 요청 위조) 공격을 막아주는 보안 기능이다. 웹사이트가 "이거 진짜 사용자가 보낸 요청 맞냐?"를 확인해서, 사용자가 모르는 사이에 이상한 요청(비밀번호 변경, 글 삭제 등)이 서버로 날아가는 걸 막는다. "내 집 문단속 내가 한다."

**왜 쓰는데? (목적)**
사용자 계정 털리거나, 데이터가 멋대로 바뀌거나 지워지는 해킹 사고를 막으려고 쓴다. 한마디로 웹 애플리케이션의 보안 레벨을 올리는 거다. "털리고 후회 말고, 미리미리 방어하자."

**언제 불려 나오냐? (호출 시점)**
클라이언트(브라우저)가 서버에 HTTP 요청을 보낼 때, 실제 요청 처리 로직(라우트 핸들러)이 돌아가기 전에 이 미들웨어가 먼저 끼어들어서 검사를 시작한다. 주로 `POST`, `PUT`, `DELETE`처럼 서버 상태를 바꾸는 요청에 대해 작동한다.

**쓸 때 꿀팁 및 주의사항:**
*   **`Origin` 헤더 못 믿겠으면 다른 것도 써라:** 이 방식은 `Origin` 헤더에 크게 의존한다. 이 헤더가 없거나 조작될 수 있는 환경(구식 브라우저, 일부 프록시)에서는 효과가 떨어지니, CSRF 토큰 같은 다른 방어 수단도 같이 쓰는 게 좋다. "계란은 한 바구니에 담지 마라."
*   **`origin` 설정은 빡세게:** 허용할 출처(`origin` 옵션)를 지정할 땐 `https://myapp.example.com`처럼 프로토콜(https)까지 정확히, 그리고 와일드카드(`*`)나 정규식은 최소한으로 써야 안전하다. 대충 `myapp.example.com`만 걸어두면 `http://myapp.example.com`이나 `악당-myapp.example.com` 같은 놈들한테 문 열어주는 꼴이다.
*   **함수로 `origin` 검증? 정규식 끝까지 확인해라:** 함수로 `origin`을 검증할 때는 정규식의 끝을 나타내는 `$`를 써서 정확히 일치하는 도메인만 허용해야 한다. `startsWith` 같은 걸로 대충 검사하면 보안 구멍 생기기 딱 좋다. "대충 하면 대충 망한다."
*   **모든 요청에 걸 필요는 없다:** `GET`이나 `HEAD`처럼 데이터 안 바꾸는 요청에는 굳이 CSRF 보호를 걸 필요 없다. 오히려 서버 자원 낭비일 수 있다. 필요한 경로(`app.use('/admin/*', csrf())`)나 HTTP 메서드에만 선택적으로 적용하는 게 효율적이다.
*   **API도 예외 없다:** 특히 상태를 바꾸는 API 엔드포인트에는 CSRF 보호를 꼭 걸어라. SPA(싱글 페이지 애플리케이션)랑 통신하는 API라도 쿠키 기반 인증을 쓴다면 CSRF 공격 대상이 될 수 있다. "방심은 금물."