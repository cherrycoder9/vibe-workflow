# Request ID Middleware Explained
Request ID 미들웨어는 각 요청마다 고유한 ID를 생성해서, 핸들러에서 써먹을 수 있게 해준다. "이 요청, 저 요청 헷갈리지 말라고 이름표 딱 붙여주는 격이지."

Request ID 미들웨어가 적용된 핸들러나 미들웨어에서는 `c.get('requestId')`를 통해 요청 ID에 접근할 수 있다.

```typescript
import { Hono } from 'hono'
import { requestId } from 'hono/request-id'

const app = new Hono()

app.use('*', requestId()) // 모든 경로에 requestId 미들웨어 적용

app.get('/', (c) => {
  return c.text(`니 요청 ID는 ${c.get('requestId')} 이거다`) // requestId 가져오기
})
```

타입을 명시적으로 지정하고 싶으면, `RequestIdVariables`를 임포트해서 `new Hono()`의 제네릭으로 넘겨주면 된다. "타입스크립트 쓰는 놈들은 이렇게 해야 마음이 편안하지."

```typescript
import type { RequestIdVariables } from 'hono/request-id'

const app = new Hono<{
  Variables: RequestIdVariables // 타입 명시
}>()
```

**옵션들**
*   `limitLength?: number`
    요청 ID의 최대 길이. 기본값은 255. "너무 길면 데이터베이스 터지니까 적당히."
*   `headerName?: string`
    요청 ID에 사용될 헤더 이름. 기본값은 `X-Request-Id`. "회사마다 쓰는 헤더 이름 다르면 이걸로 통일시켜."
*   `generator?: (c: Context) => string`
    요청 ID 생성 함수. 기본적으로 `crypto.randomUUID()`를 사용한다. "UUID 말고 니가 만든 복잡한 ID 쓰고 싶으면 이걸로 갈아끼워."

---

얘 뭐 하는 애냐?
서버에 들어오는 모든 HTTP 요청에다가 유니크한 식별번호(ID)를 하나씩 딱! 붙여주는 놈이다. 마치 택배 송장번호처럼, 어떤 요청인지 구분하고 추적할 때 써먹으려고. "이거 없으면 나중에 로그 뒤질 때 눈 빠진다."

왜 쓰는데? (왜 이런 걸 만들어서 붙이는데?)
1.  **요청 추적 및 디버깅**: 서비스가 복잡해지면 하나의 요청이 여러 시스템을 거치기도 하는데, 이때 요청 ID가 있으면 "이놈의 요청이 어디까지 가서 뭘 했나" 추적하기가 수월해진다. 에러 났을 때도 해당 ID로 로그를 싹 긁어모으면 원인 찾기가 한결 쉽지. "범인 찾기 난이도 하락!"
2.  **로깅 강화**: 그냥 로그만 찍으면 나중에 뭐가 뭔지 모르는데, 요청 ID를 로그마다 박아두면 특정 요청과 관련된 로그만 필터링해서 볼 수 있다. "로그 바다에서 길 잃지 않게 해주는 등대랄까."
3.  **API 모니터링**: API 요청마다 ID가 있으니, 특정 ID의 요청이 얼마나 걸렸는지, 어떤 응답을 줬는지 등을 분석해서 API 성능 모니터링에도 써먹을 수 있다.

언제 불려 나오냐? (언제 이 ID가 생성되고 붙냐?)
클라이언트가 서버에 HTTP 요청을 보내면, 이 미들웨어가 다른 비즈니스 로직 처리하기 전에 제일 먼저 혹은 아주 초반에 끼어들어서 요청 객체에 ID를 생성하고 심어준다. `app.use('*', requestId())` 이렇게 글로벌하게 설정하면 모든 요청에 다 적용된다.

쓸 때 꿀팁 및 주의사항:
*   **글로벌 적용이 국룰**: 어지간하면 특정 경로에만 적용하지 말고, `app.use('*', requestId())`처럼 모든 요청에 적용해서 일관성을 확보하는 게 좋다. "어떤 놈은 있고 어떤 놈은 없으면 그게 더 헷갈려."
*   **헤더 이름 표준화**: 여러 서비스나 팀이랑 같이 일한다면, `headerName` 옵션으로 `X-Request-Id` 같은 표준 헤더 이름을 쓰거나 내부적으로 통일된 이름을 쓰는 게 좋다. "우리끼리는 이 이름으로 통한다!"
*   **ID 생성기 커스텀은 신중하게**: 기본 `crypto.randomUUID()`는 충분히 강력하고 충돌 가능성도 거의 없다. 굳이 커스텀 생성기를 쓴다면, ID의 유일성이 확실히 보장되는지, 성능에 문제는 없는지 잘 따져봐야 한다. "괜히 어설프게 만들었다가 ID 중복 나면 대참사."
*   **로깅 시스템과의 연동이 핵심**: 요청 ID를 만들었으면 뭐하나, 로그에 안 찍으면 말짱 도루묵이다. 사용하는 로깅 라이브러리 설정에서 `c.get('requestId')`로 가져온 ID를 로그 포맷에 꼭 포함시켜라. "구슬이 서 말이라도 꿰어야 보배."
*   **ID 길이**: `limitLength` 기본값 255는 넉넉하지만, 저장 공간이나 네트워크 전송량에 민감하다면 적절히 줄일 수도 있다. UUID v4 기준으로 36자면 충분.
*   **보안은 기본**: 요청 ID 자체에 민감한 정보(사용자 ID, 세션 정보 등)를 직접 포함시키지 마라. ID는 그냥 식별자일 뿐, 정보 저장소가 아니다.