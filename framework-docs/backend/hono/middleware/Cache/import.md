`hono/cache`에서 `cache`를 가져옵니다.

```typescript
import { Hono } from 'hono'
import { cache } from 'hono/cache'
```

Cache 미들웨어는 웹 표준 Cache API를 사용합니다.

Cache 미들웨어는 현재 커스텀 도메인을 사용하는 Cloudflare Workers 프로젝트와 Deno 1.26+를 사용하는 Deno 프로젝트를 지원합니다. Deno Deploy에서도 사용할 수 있습니다.

Cloudflare Workers는 `Cache-Control` 헤더를 존중하고 캐시된 응답을 반환합니다. 자세한 내용은 Cloudflare Docs의 Cache를 참조하세요. Deno는 헤더를 존중하지 않으므로 캐시를 업데이트해야 하는 경우 자체 메커니즘을 구현해야 합니다.

각 플랫폼별 사용법은 아래 "사용법" 섹션을 참조하세요. (네가 준 내용에는 사용법 예시가 없어서 이 부분은 일반적인 설명을 붙일게.)

---

**얘 뭐 하는 애냐?**
`cache` 미들웨어는 말 그대로 Hono 앱의 응답 결과를 "캐시"해주는 녀석이야. 한 번 요청해서 받은 응답을 어딘가에 저장해뒀다가, 똑같은 요청이 또 들어오면 실제 로직을 다시 실행하는 대신 저장해둔 응답을 바로 쏴주는 거지. "자주 찾는 물건은 꺼내기 쉬운 곳에 미리 챙겨두는 센스!"

**왜 쓰는데?**
1.  **응답 속도 향상 (퍼포먼스 UP!)**: 매번 데이터베이스 뒤지고, 복잡한 계산하고, 외부 API 호출하고... 이런 비싼 작업을 반복하는 대신, 캐시된 결과를 바로 주니까 응답 속도가 미친 듯이 빨라질 수 있어. 사용자는 "와, 이 사이트 빠르네!" 하고 감탄하게 되지.
2.  **서버 부하 감소**: 똑같은 요청을 계속 처리하느라 서버가 헉헉대는 걸 막아줘. 특히 트래픽이 몰릴 때 캐시가 빛을 발하지. "일 잘하는 알바생 한 명 더 쓰는 효과!"
3.  **비용 절감 (특히 API 호출 비용)**: 외부 유료 API를 호출해서 데이터를 가져오는 경우, 한 번 가져온 결과를 캐시해두면 API 호출 횟수를 줄여서 비용을 아낄 수 있어. "구독 서비스 중복 결제 막는 격!"

**언제 불려 나오냐?**
Hono 라우트 핸들러 체인에서 미들웨어로 등록돼. 특정 경로의 GET 요청에 대해 응답을 캐시하고 싶을 때 주로 사용하지.

```typescript
// 기본적인 사용 예시 (실제 환경에 따라 옵션 조정 필요)
const app = new Hono()

app.get(
  '/users/:id',
  cache({ // cache 미들웨어 설정!
    cacheName: 'my-app-cache', // 캐시 저장소 이름 (필수)
    cacheControl: 'max-age=3600', // Cache-Control 헤더 설정 (예: 1시간 동안 유효)
    // wait: true, // Cloudflare Workers에서 캐시 쓰기 완료를 기다릴지 여부
    // keyGenerator: (c) => new Request(c.req.url, c.req.raw) // 캐시 키 생성 방식 커스텀 (고급)
  }),
  async (c) => {
    const id = c.req.param('id')
    // 여기서 DB 조회나 비싼 작업 수행
    const user = await fetchUserFromDB(id)
    return c.json(user)
  }
)
```
위 코드에서 `/users/:id` 경로로 GET 요청이 오면, `cache` 미들웨어가 먼저 "이거 캐시에 있나?" 하고 뒤져봐. 있으면 바로 캐시된 응답을 주고, 없으면 뒤에 있는 핸들러(`async (c) => { ... }`)를 실행해서 응답을 생성한 다음, 그 응답을 캐시에 저장하고 클라이언트에게도 보내주는 식이야.

**쓸 때 꿀팁 및 주의사항:**
*   **플랫폼 지원 확인**: `hono/cache`는 웹 표준 Cache API를 쓰는데, 이게 모든 환경에서 똑같이 돌아가진 않아. Cloudflare Workers나 Deno (특히 Deno Deploy) 같이 이 API를 제대로 지원하는 환경에서 주로 써야 해. "아무 데서나 마법봉 휘두른다고 마법이 나가진 않는다."
*   **`cacheName`은 필수**: 캐시를 저장할 공간의 이름을 지정해야 해. 보통 앱 이름이나 API 버전 같은 걸 조합해서 유니크하게 만들지.
*   **`Cache-Control` 헤더의 마법 (특히 Cloudflare)**: Cloudflare Workers 같은 환경에서는 HTTP `Cache-Control` 헤더(`max-age`, `s-maxage`, `public`, `private` 등)를 잘 설정하는 게 중요해. 이 헤더에 따라 브라우저 캐시, CDN 캐시 동작이 달라지거든. `hono/cache` 미들웨어의 `cacheControl` 옵션으로 이 헤더를 응답에 추가할 수 있어. "캐시 유효기간 설정은 신중하게!"
*   **Deno 환경의 특수성**: Deno에서는 `Cache-Control` 헤더를 자동으로 존중해서 캐시를 관리해주지 않아. 그래서 캐시를 언제 지우고 업데이트할지 (캐시 무효화 전략) 직접 고민하고 코드를 짜야 할 수도 있어. "Deno에서는 좀 더 수동으로 챙겨줘야 한다."
*   **캐시 키(Cache Key) 전략**: 어떤 요청을 "같은 요청"으로 보고 캐시를 공유할지 결정하는 게 캐시 키야. 기본적으로는 요청 URL을 쓰지만, 경우에 따라서는 특정 헤더 값(예: `Accept-Language`)까지 포함해서 키를 만들어야 할 수도 있어 (`keyGenerator` 옵션). "열쇠가 안 맞으면 보물 상자는 안 열린다."
*   **캐시 무효화(Cache Invalidation)는 숙명**: 한 번 캐시된 데이터가 영원히 유효하진 않겠지? 원본 데이터가 바뀌면 캐시도 업데이트해줘야 하는데, 이걸 "캐시 무효화"라고 해. 이게 생각보다 골치 아픈 문제야. `Cache-Control`의 `max-age`를 짧게 잡거나, 데이터 변경 시 수동으로 캐시를 삭제하는 로직을 넣거나, ETag 같은 걸 활용하는 방법 등이 있어. "캐시는 편리하지만, 썩은 음식 주면 안 되잖아?"
*   **GET 요청에만 주로 사용**: 캐시는 보통 멱등성(idempotent)이 보장되는 GET 요청에 사용하는 게 일반적이야. POST, PUT, DELETE 같은 요청은 서버 상태를 바꾸기 때문에 캐시하면 꼬일 수 있어.
*   **개인 정보 캐싱 주의**: 사용자별로 다른 내용이 보이는 페이지(예: 마이페이지)를 통째로 공개 캐시에 저장하면 개인정보 유출 대참사가 날 수 있어. `Cache-Control: private`을 쓰거나, 아예 캐시 대상에서 제외해야 해. "아무거나 냉장고에 넣어두면 상한다."