```typescript
const app = new Hono()

// '/auth/*' 경로로 들어오는 모든 요청에 대해 기본 인증을 걸어버렷!
app.use(
  '/auth/*', // 이 경로 밑으로는 다 검문 대상이야
  basicAuth({ // 기본 인증 미들웨어 출동!
    username: 'hono',     // 아이디는 'hono'
    password: 'acoolproject', // 비번은 'acoolproject' (실제론 이렇게 쓰면 혼나!)
  })
)

// 인증 통과한 녀석들만 이 페이지를 볼 수 있지
app.get('/auth/page', (c) => {
  return c.text('인증되셨습니다, 손님.') // "통과!"
})
```

특정 라우트와 특정 HTTP 메서드에만 콕 집어서 제한하고 싶다면 이렇게 합니다:

```typescript
const app = new Hono()

// '/auth/page' GET 요청은 누구나 볼 수 있어 (인증 없음)
app.get('/auth/page', (c) => {
  return c.text('페이지 보는 중...')
})

// 하지만 '/auth/page' DELETE 요청은 함부로 못 하지!
app.delete(
  '/auth/page', // 이 경로, 이 메서드!
  basicAuth({ username: 'hono', password: 'acoolproject' }), // 여기서 인증 검사!
  (c) => { // 인증 통과해야 이 핸들러 실행됨
    return c.text('페이지 삭제 완료!')
  }
)
```

만약 아이디/비번을 직접 검증하는 로직을 짜고 싶다면, `verifyUser` 옵션을 사용하세요. 이 함수가 `true`를 반환하면 인증 성공으로 간주합니다.

```typescript
const app = new Hono()

app.use(
  basicAuth({
    // verifyUser 함수로 나만의 인증 로직을 심어보자!
    verifyUser: (username, password, c) => {
      // 여기서 DB를 조회하든, 외부 API를 부르든 맘대로!
      // 여기선 간단하게 하드코딩된 아이디/비번이랑 비교
      return (
        username === 'dynamic-user' && password === 'hono-password'
      ) // 이 조건 맞으면 true 반환 -> 인증 성공!
    },
  })
)
```

---

**얘 뭐 하는 애냐?**
`basicAuth` 미들웨어는 웹에서 가장 기본적인 형태의 인증 방식인 "HTTP 기본 인증(Basic Authentication)"을 Hono 앱에 쉽게 붙여주는 녀석입니다. 웹사이트 들어갈 때 브라우저가 못생긴 로그인 팝업창 띄우면서 "아이디랑 비번 내놔!" 하는 거, 그거 구현해주는 겁니다. 아주 간단한 비밀번호 보호가 필요할 때 써먹기 좋습니다.

**왜 쓰는데?**
1.  **초간단 접근 제한**: 복잡한 로그인 시스템 만들기는 귀찮고, 그냥 특정 페이지나 API를 아무나 못 보게 살짝 막고 싶을 때 최고입니다. "관리자 페이지? 일단 이걸로 막아둬!"
2.  **개발/스테이징 환경 보호**: 아직 개발 중이거나 내부 테스트용으로만 열어둔 사이트가 구글 봇에 긁히거나 아무나 들어와서 구경하는 걸 막고 싶을 때 유용합니다. "공사 중 표지판 + 자물쇠" 느낌이죠.
3.  **API 엔드포인트 보호 (간단한 경우)**: 아주 민감한 데이터는 아니지만, 그래도 아무나 호출 못 하게 하고 싶은 내부용 API 같은 곳에 간단히 적용할 수 있습니다.

**언제 불려 나오냐?**
Hono 앱에 미들웨어로 등록해서 사용합니다. `app.use('/admin/*', basicAuth(...))`처럼 특정 경로 전체에 적용하거나, `app.get('/secret-data', basicAuth(...), (c) => { ... })`처럼 특정 라우트 핸들러가 실행되기 직전에 끼어들어 인증을 수행합니다. 인증에 실패하면 보통 브라우저는 401 Unauthorized 응답과 함께 로그인 팝업을 띄우고, 성공하면 다음 미들웨어나 라우트 핸들러로 제어를 넘깁니다.

**쓸 때 꿀팁 및 주의사항:**
*   **HTTPS는 필수! (아니면 그냥 다 털림)**: HTTP 기본 인증은 아이디와 비밀번호를 Base64로 인코딩해서 보내는데, 이건 암호화가 아니라 그냥 글자 바꾸기 수준이라 중간에 누가 가로채면 바로 내용 다 보입니다. "비밀번호를 엽서에 써서 보내는 격." 반드시 HTTPS 환경에서만 사용해야 그나마 안전합니다.
*   **비밀번호는 절대 코드에 박지 마세요 (예제는 예제일 뿐!)**: 예제 코드처럼 `username: 'hono', password: 'acoolproject'` 이렇게 코드에 아이디/비번 박아두면 깃허브에 올라가는 순간 전 세계에 공개하는 겁니다. `env()` 같은 걸로 환경 변수에서 읽어오거나, `verifyUser` 옵션 써서 DB 같은 안전한 곳에 저장된 정보를 조회해야 합니다. "비번 적힌 포스트잇 모니터에 붙이지 말라고!"
*   **`verifyUser`로 커스텀 인증 로직**: 고정된 아이디/비번 말고, DB에 저장된 사용자 정보랑 비교하거나, LDAP 같은 외부 인증 시스템이랑 연동하고 싶으면 `verifyUser` 함수를 사용하세요. 이 함수 안에서 `async/await` 써서 비동기 처리도 가능합니다.
*   **"영역(Realm)" 지정 가능**: `basicAuth({ realm: '여긴 관리자만!', ... })`처럼 `realm` 옵션을 주면 브라우저 로그인 팝업에 표시되는 메시지를 바꿀 수 있습니다. 사용자에게 "어디에 접속하려고 하는지" 알려주는 용도죠.
*   **보안 수준은 딱 "기본"**: 이름처럼 정말 "기본적인" 인증 방식입니다. CSRF 보호도 안 되고, 세션 관리도 없고, 비밀번호 재시도 공격에도 취약할 수 있습니다. 진짜 중요한 서비스나 민감 데이터를 다룬다면 OAuth 2.0, JWT 같은 더 강력한 인증 방식을 고민해야 합니다. "동네 문단속용이지, 은행 금고용 자물쇠는 아니다."
*   **API 클라이언트와의 연동**: 브라우저가 아닌 프로그램(curl, Postman, 앱 등)에서 기본 인증을 사용하는 API를 호출할 때는 HTTP 요청 헤더에 `Authorization: Basic base64인코딩된_아이디:비밀번호` 형태로 직접 넣어서 보내야 합니다. `curl -u username:password https://example.com/api` 이런 식으로요.