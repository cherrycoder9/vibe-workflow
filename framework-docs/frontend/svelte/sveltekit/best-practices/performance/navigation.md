Navigation (내비게이션)
Preloading (미리 불러오기)
링크 옵션을 사용해서 필요한 코드와 데이터를 미리 적극적으로 불러오면 클라이언트 쪽 내비게이션 속도를 높일 수 있습니다. 새 SvelteKit 앱을 만들면 이 기능은 기본적으로 `<body>` 요소에 설정되어 있습니다.

Non-essential data (덜 중요한 데이터)
즉시 필요하지 않은, 느리게 로딩되는 데이터의 경우, `load` 함수에서 반환하는 객체에 데이터 자체 대신 프로미스(promise)를 담을 수 있습니다. 서버 `load` 함수의 경우, 이렇게 하면 내비게이션 (또는 초기 페이지 로드) 후에 데이터가 스트리밍됩니다.

Preventing waterfalls (폭포수 현상 방지)
성능을 가장 크게 저해하는 것 중 하나는 "폭포수(waterfall)"라고 불리는, 순차적으로 발생하는 일련의 요청들입니다. 이건 서버나 브라우저 양쪽에서 다 일어날 수 있습니다.

브라우저에서는 HTML이 JS를 요청하고, JS가 CSS를 요청하고, CSS가 배경 이미지와 웹 폰트를 요청할 때 에셋 폭포수(Asset waterfalls)가 발생할 수 있습니다. SvelteKit은 `modulepreload` 태그나 헤더를 추가해서 이런 문제 대부분을 해결해주지만, 개발자 도구의 네트워크 탭을 보면서 추가로 미리 불러와야 할 리소스가 있는지 확인해야 합니다. 특히 웹 폰트는 수동으로 처리해야 하니 주의 깊게 보세요.
만약 유니버설 `load` 함수가 현재 사용자 정보를 가져오기 위해 API를 호출하고, 그 응답에서 얻은 세부 정보를 사용해 저장된 항목 목록을 가져오고, 또 그 응답을 사용해 각 항목의 세부 정보를 가져온다면, 브라우저에서는 여러 번의 순차적인 요청이 발생하게 됩니다. 이건 성능에 치명적이며, 특히 백엔드에서 물리적으로 멀리 떨어진 사용자에게는 더욱 그렇습니다. 가능하면 서버 `load` 함수를 사용해서 이 문제를 피하세요.
서버 `load` 함수도 폭포수 현상에서 자유롭지는 않습니다 (대기 시간이 긴 왕복이 거의 없어서 비용은 훨씬 적지만요). 예를 들어, 현재 사용자를 가져오기 위해 데이터베이스를 쿼리하고, 그 데이터를 사용해 저장된 항목 목록을 가져오기 위해 두 번째 쿼리를 한다면, 일반적으로는 데이터베이스 조인(join)을 사용해 단일 쿼리를 실행하는 것이 더 효율적입니다.

---

**얘 뭐 하는 애냐?**
한마디로 "페이지 로딩 속도 끌어올리는 최적화 기술 종합세트"야. 사용자가 링크 누르기도 전에 "아, 다음엔 이거 보여줘야겠네?" 하고 미리 코드랑 데이터를 슬쩍 가져오는 게 **Preloading**. "이 데이터는 지금 당장 없어도 페이지는 돌아가니까, 일단 화면부터 띄우고 천천히 가져오자" 이게 **Non-essential data** 처리 방식. **Preventing waterfalls**는 요청이 꼬리에 꼬리를 물고 늘어져서 거북이처럼 느려지는 걸 막는 거야. "야, 줄줄이 비엔나처럼 요청 보내지 말고 한 방에 끝내든가, 동시에 처리해!" 이거지.

**왜 쓰는데?**
느려터진 웹사이트는 뭐다? 바로 사용자 이탈이다. 이걸 쓰는 이유는 딱 하나, 사용자가 "아오, 답답해!" 하면서 창 닫는 걸 막기 위해서야. 페이지가 휙휙 뜨면 사용자 경험(UX)이 좋아지고, 그러면 뭐다? 서비스 만족도가 올라가는 거지. "로딩 중..." 화면 오래 보면 현기증 난단 말이에요.

**언제/어떻게 쓰냐?**
*   **Preloading:** SvelteKit은 똑똑해서 기본적으로 `<body>` 태그에 마우스 올리면 다음 페이지 데이터 미리 가져오는 설정을 해놔. 특정 링크에만 적용하고 싶으면 `<a>` 태그에 `data-sveltekit-preload-data` 속성을 쓰거나, 최신 SvelteKit에선 더 다양한 링크 옵션으로 제어할 수 있어.
*   **Non-essential data:** `load` 함수에서 데이터를 바로 안 주고 `Promise` 형태로 던져주면 돼. 그럼 SvelteKit이 "아, 이건 나중에 천천히 보내줘도 되는구나" 하고 알아서 처리해줘. 화면엔 일단 뭐라도 보여주면서 말이지.
*   **Preventing waterfalls:** 이건 네가 정신 똑바로 차리고 설계해야 해.
    *   **에셋 폭포수:** 개발자 도구(F12) Network 탭 켜놓고 뭐가 줄줄이 로딩되는지 감시해야 돼. 특히 웹폰트 같은 건 `<link rel="preload">`로 수동 처리해줘야 할 때가 많아. SvelteKit이 많이 도와주긴 하지만 100%는 아니라고.
    *   **데이터 폭포수:** 브라우저에서 API 요청을 연쇄적으로 하지 마. 사용자 정보 가져오고 -> 그걸로 게시물 목록 가져오고 -> 그걸로 또 댓글 가져오고... 이러면 망한다. 서버 `load` 함수 안에서 필요한 데이터 한 번에 다 만들어서 보내거나, DB에서 JOIN 써서 한 큐에 가져와.

**쓸 때 꿀팁 및 주의사항:**
*   **Preloading, 과하면 독:** 모든 링크에 다 걸면 오히려 서버랑 사용자 데이터만 축낼 수 있어. "쓸데없이 미리 다 가져오면 데이터 낭비, 서버 과부하다!" 꼭 필요한, 사용자가 높은 확률로 누를 것 같은 링크에만 적용하는 게 현명해.
*   **Non-essential 데이터, 핵심은 챙겨라:** 뭐가 핵심이고 뭐가 부가적인지 판단 잘해야 돼. 핵심 데이터까지 `Promise`로 넘기면 사용자는 빈 화면만 멍하니 보게 될 수도 있다. "일단 뼈대부터 보여주고 살을 붙여라." 그리고 데이터 로딩 중이라는 표시는 사용자 배려의 기본이다.
*   **Waterfall은 숙명, 하지만 극복 가능:** 이건 프레임워크가 마법처럼 다 해결해주는 게 아니야. 데이터 흐름을 잘 설계하고, "이 요청 다음에 저 요청이 꼭 필요한가?" 계속 고민해야 돼. "네트워크 탭은 너의 베프다. 수시로 확인해라."
*   **서버 `load`는 만능 치트키 (데이터 폭포수 한정):** 브라우저에서 API 여러 번 호출해서 조합하는 것보다, 서버 `load`에서 한 번에 필요한 데이터를 다 가공해서 내려주는 게 훨씬 빨라. "웬만한 데이터 조립은 서버에서 끝내고 와라. 클라이언트는 보여주기만 할 뿐."
*   **웹폰트, 그 무거운 존재:** 웹폰트는 예쁘지만 성능에는 쥐약일 수 있어. 폰트 파일 자체도 크고, 잘못 적용하면 글자 깜빡임(FOIT/FOUT) 때문에 사용자가 눈갱당한다. "폰트 때문에 사이트 망치지 말고, 최적화 방법 따로 공부해라."