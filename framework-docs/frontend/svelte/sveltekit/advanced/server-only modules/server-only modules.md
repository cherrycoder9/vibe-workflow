**Server-only modules**

찐친처럼 스벨트킷은 네 비밀을 지켜준다. 백엔드랑 프론트엔드를 같은 저장소에서 작업하다 보면, 민감한 데이터(API 키가 담긴 환경 변수 같은 거)를 실수로 프론트엔드 코드에 넣어버리기 십상이지. 스벨트킷은 이런 대참사를 원천봉쇄할 방법을 제공하는데, 그게 바로 "서버 전용 모듈"이야.

**비공개 환경 변수**
`$env/static/private`이랑 `$env/dynamic/private` 모듈은 오직 서버에서만 돌아가는 모듈, 예를 들어 `hooks.server.js`나 `+page.server.js` 같은 곳에서만 임포트할 수 있어. "아무나 못 건드린다, 이거지."

**서버 전용 유틸리티**
파일 시스템에서 에셋을 읽어오는 `read` 함수가 들어있는 `$app/server` 모듈도 마찬가지로 서버에서 돌아가는 코드에서만 임포트 가능해. "이것도 서버 밖으론 못 나간다."

**네 모듈도 서버 전용으로 만들기**
네가 만든 모듈도 두 가지 방법으로 서버 전용 딱지를 붙일 수 있어:
1.  파일 이름 끝에 `.server` 붙이기 (예: `secrets.server.js`)
2.  `$lib/server` 폴더 안에 넣기 (예: `$lib/server/secrets.js`)

**어떻게 돌아가는데?**
공개용 코드(클라이언트 코드)가 서버 전용 코드를 (직접적이든 간접적이든) 임포트하려고 하면...

```javascript
// $lib/server/secrets.js
export const atlantisCoordinates = [/* 비밀임 */];

// src/routes/utils.js
export { atlantisCoordinates } from '$lib/server/secrets.js'; // 여기서 서버 전용 모듈을 끌어다 씀
export const add = (a, b) => a + b;

// src/routes/+page.svelte
<script>
	import { add } from './utils.js'; // add 함수만 쓰려고 했지만...
</script>
```

...스벨트킷이 바로 에러를 뱉어낼 거야:

```
Cannot import $lib/server/secrets.js into public-facing code: (공개용 코드에 $lib/server/secrets.js 임포트 못 한다!)
- src/routes/+page.svelte (얘가 범인)
	- src/routes/utils.js (얘가 중간책)
		- $lib/server/secrets.js (얘는 서버 전용인데!)
```

비록 공개용 코드인 `src/routes/+page.svelte`가 `add` 함수만 쓰고 비밀인 `atlantisCoordinates`는 안 썼다고 해도, 그 비밀 코드가 브라우저가 다운로드하는 자바스크립트에 섞여 들어갈 수 있기 때문에, 이 임포트 경로는 안전하지 않다고 보는 거야. "혹시 모르니까 일단 막고 본다" 이거지.

이 기능은 동적 임포트, 심지어 `await import(\`./\${foo}.js\`)`처럼 경로가 동적으로 만들어지는 경우에도 작동해. 다만 한 가지 작은 주의사항이 있는데, 개발 중에 공개용 코드와 서버 전용 모듈 사이에 동적 임포트가 두 단계 이상 끼어있으면, 코드가 처음 로드될 때는 이 불법적인 임포트를 감지하지 못할 수도 있어.

`Vitest` 같은 유닛 테스트 프레임워크는 서버 전용 코드와 공개용 코드를 구분하지 않아. 그래서 `process.env.TEST === 'true'`로 판단될 때, 즉 테스트 실행 중에는 이 불법 임포트 감지 기능이 비활성화돼. "테스트할 땐 잠깐 봐준다."

---

**얘 뭐 하는 애냐?**
이름 그대로 서버에서만 굴러야 할 코드 쪼가리들이 실수로라도 사용자 브라우저에 딸려 들어가는 걸 막아주는 문지기 같은 놈이야. API 키, 데이터베이스 접속 정보 같은 민감한 정보나 서버에서만 돌아야 하는 무거운 로직들을 안전하게 지켜주는 역할을 하지. "너, 프론트엔드로는 못 지나간다!" 하고 딱 막아서는 거지.

**왜 쓰는데?**
1.  **보안 강화 (이게 핵심):** 제일 중요한 이유. API 키나 DB 비밀번호 같은 게 프론트엔드 코드에 박혀서 브라우저로 넘어가면? 그건 그냥 "우리 집 열쇠 길바닥에 뿌립니다~" 하는 거랑 똑같아. 해커들한테 "어서 오세요, 고객님!" 하는 꼴이지. 이걸 막아서 네 서버랑 데이터를 안전하게 지키는 거야.
2.  **코드 분리 명확화:** "이건 서버에서만 써야 해!", "저건 아무 데서나 써도 돼!" 하고 개발자가 명확하게 구분해서 코드를 짜도록 유도해. 덕분에 코드 구조가 깔끔해지고, 나중에 "이 코드가 어디서 돌아가는 거였지?" 하고 머리 싸맬 일이 줄어들어.
3.  **실수 방지턱:** 사람은 누구나 실수하잖아? 깜빡하고 서버용 모듈을 클라이언트 쪽에서 임포트할 수도 있는데, 스벨트킷이 이걸 알아서 잡아주니까 개발자가 한숨 돌릴 수 있는 거지. "괜찮아, 내가 한 번 더 봐줄게."

**언제 적용되고 어떻게 쓰냐?**
네가 특정 파일이나 폴더에 "이건 서버 전용임!" 하고 딱지를 붙여주면, 스벨트킷이 빌드할 때나 개발 서버 돌릴 때 그걸 기억하고 있다가 감시를 시작해.
*   파일 이름 끝에 `.server.js` (또는 `.server.ts` 등) 붙이기: `db.server.js`처럼.
*   `$lib/server/` 폴더 안에 파일 넣기: `$lib/server/payment-gateway.js`처럼.

이렇게 해두면, 만약 클라이언트 쪽 코드(예: `+page.svelte`, `+layout.svelte` 또는 얘네가 임포트하는 일반 `.js` 파일)에서 저 서버 전용 모듈을 `import` 하려고 시도하면, 스벨트킷이 "야, 너 지금 선 넘었어!" 하면서 바로 에러를 빵 터뜨려.

**쓸 때 꿀팁 및 주의사항:**
*   **간접 임포트도 다 잡아낸다, 거의:** `A(클라) -> B(공용) -> C(서버전용)` 이렇게 한 다리, 두 다리 건너서 임포트해도 스벨트킷은 귀신같이 "어쭈, 서버 전용 모듈을 빼돌리려고?" 하면서 잡아내려고 해. 다만, 개발 모드에서 동적 임포트(`await import(...)`)가 여러 단계 복잡하게 얽혀있으면 첫 로딩 때는 놓칠 수도 있으니 주의. "완벽하진 않지만, 대부분의 도둑은 잡는다."
*   **테스트할 땐 잠깐 프리패스:** 유닛 테스트 돌릴 때는 서버/클라이언트 구분이 모호해서 이 기능이 잠시 꺼져. 안 그러면 테스트 코드 짜기 너무 빡세지니까. "시험 볼 땐 잠깐 규칙 완화."
*   **환경 변수는 `$env/static/private` 또는 `$env/dynamic/private` 활용:** API 키, DB 접속 정보 같은 민감한 환경 변수는 얘네를 써서 서버에만 꽁꽁 숨겨야 해. 이게 국룰.
*   **파일 시스템 접근은 `$app/server`:** 서버에서 파일 읽고 쓰는 등의 작업은 `$app/server` 모듈에 있는 기능을 활용하는 게 정석.
*   **"이거 왜 안 되지?" 싶을 땐 임포트 경로 확인:** 가끔 서버 전용으로 만든 모듈이 아닌데 에러가 난다면, 혹시 나도 모르게 그 모듈이 다른 서버 전용 모듈을 임포트하고 있지는 않은지 거슬러 올라가 봐. "범인은 이 안에 있어!"
*   **결국은 개발자의 안전벨트:** 이 기능은 개발자의 실수를 시스템 레벨에서 한 번 더 걸러주는 안전장치야. "안전벨트 맸다고 막 운전하면 안 되는 거 알지? 그래도 안 매는 것보단 낫다."