`handle` 함수

이 함수는 SvelteKit 서버가 요청을 받을 때마다 실행됩니다. 앱이 실행 중일 때든, 미리 렌더링(prerendering)할 때든 상관없이 말이죠. 그리고 이 함수가 최종 응답을 결정합니다. `handle` 함수는 요청 정보를 담은 `event` 객체와, 요청된 경로를 렌더링하고 `Response` 객체를 생성하는 `resolve` 함수를 인자로 받습니다. 이걸 이용해서 응답 헤더나 본문을 수정하거나, 아예 SvelteKit의 기본 라우팅을 건너뛰고 프로그래밍 방식으로 직접 라우트를 처리할 수도 있습니다. (예를 들어, 특정 경로에 대해 완전히 다른 응답을 만들어낼 때 쓰죠.)

**위치:** `src/hooks.server.js` (또는 `.ts`)

```typescript
// src/hooks.server.ts
import type { Handle } from '@sveltejs/kit';

export const handle: Handle = async ({ event, resolve }) => {
	// 만약 요청 URL 경로가 '/custom'으로 시작하면,
	if (event.url.pathname.startsWith('/custom')) {
		// SvelteKit 라우팅 쌩까고 그냥 'custom response' 텍스트를 응답으로 보낸다.
		return new Response('custom response');
	}

	// 그 외의 경우에는, SvelteKit이 알아서 하도록 resolve 함수를 호출한다.
	const response = await resolve(event);
	// 그리고 그 결과를 반환한다.
	return response;
};
```

정적 에셋(이미 미리 렌더링된 페이지 포함)에 대한 요청은 SvelteKit의 `handle` 함수를 거치지 않습니다. 걔네들은 그냥 파일 서버가 바로바로 처리해버리죠.

만약 `handle` 함수를 직접 만들지 않으면, 기본값은 `({ event, resolve }) => resolve(event)` 입니다. 즉, "별일 없으면 그냥 SvelteKit 니가 알아서 다 해" 라는 뜻이죠.

미리 렌더링(prerendering)하는 동안, SvelteKit은 페이지들을 돌아다니면서 링크를 찾고, 발견된 각 경로를 렌더링합니다. 이때도 `handle` 함수 (그리고 `load` 함수 같은 다른 라우트 의존성들)가 호출됩니다. 만약 이 미리 렌더링 단계에서 특정 코드가 실행되지 않도록 하고 싶다면, 앱이 빌드 중인지 아닌지를 미리 확인해야 합니다.

---

**얘 뭐 하는 애냐?**

`handle` 함수는 SvelteKit 앱의 문지기 같은 놈입니다. 모든 요청이 서버에 도착하면 제일 먼저 이놈을 거쳐가죠. 여기서 요청을 검사하고, "너는 통과!", "너는 이쪽으로 가!", "너는 내가 직접 처리한다!" 같은 결정을 내립니다. 일종의 중앙 관제탑, 혹은 요청 처리 파이프라인의 첫 번째 필터라고 생각하면 됩니다. "모든 길은 `handle`로 통한다!"

**왜 쓰는데?**

1.  **요청/응답 커스터마이징:** 모든 요청에 대해 공통적으로 헤더를 추가하거나(예: `Content-Security-Policy`), 응답 본문을 살짝 수정하거나, 쿠키를 심거나 읽을 때 씁니다. "들어오고 나가는 모든 짐은 내가 검사한다!"
2.  **인증/권한 처리:** 특정 경로에 접근하기 전에 사용자가 로그인했는지, 혹은 특정 권한이 있는지 검사해서, 없으면 로그인 페이지로 쫓아내거나 "접근 금지!" 메시지를 날릴 수 있습니다. "신분증 까봐! 여기 아무나 못 들어와!"
3.  **조건부 라우팅/응답:** 요청 URL, 헤더, 쿠키 등을 보고 "아, 이 요청은 SvelteKit 페이지 렌더링할 필요 없이 내가 그냥 간단히 처리해야겠다" 싶을 때, `resolve` 함수를 호출하지 않고 직접 `Response` 객체를 만들어서 반환할 수 있습니다. 위 예제처럼 `/custom` 경로 요청을 특별 취급하는 경우가 그렇죠.
4.  **A/B 테스팅, 기능 플래그:** 특정 사용자 그룹에게만 다른 버전의 페이지를 보여주거나, 새로운 기능을 테스트할 때 `handle`에서 분기 처리를 할 수 있습니다.
5.  **로깅/모니터링:** 모든 요청에 대한 정보를 기록하거나, 성능 데이터를 수집하는 용도로도 쓸 수 있습니다.

**언제 불려 나오냐?**

*   브라우저에서 SvelteKit 서버로 HTTP 요청이 날아올 때마다 (페이지 이동, API 요청 등)
*   빌드 시점에 미리 렌더링(prerendering)을 할 때, 각 페이지를 렌더링하기 직전에

기본적으로 SvelteKit 서버가 처리하는 모든 동적 요청의 시작점에 있다고 보면 됩니다. (정적 파일 요청은 제외!)

**쓸 때 꿀팁 및 주의사항:**

*   **`resolve(event)`는 마법의 문:** 대부분의 경우, `handle` 함수 안에서 뭔가 특별한 처리를 한 뒤에는 `await resolve(event)`를 호출해서 SvelteKit의 정상적인 라우팅 및 렌더링 과정을 진행시켜야 합니다. 이걸 빼먹으면 사용자는 아무것도 못 봅니다. "문지기가 문 안 열어주면 손님 못 들어온다고!"
*   **`resolve(event, opts)`로 변신 가능:** `resolve` 함수는 두 번째 인자로 `transformPageChunk`나 `filterSerializedResponseHeaders` 같은 옵션을 받아서 HTML 청크를 변형하거나, 서버에서 클라이언트로 전달되는 헤더를 필터링하는 고급 기능도 제공합니다. 필요하면 공식 문서를 뒤져보세요.
*   **`event` 객체는 보물창고:** `event` 객체 안에는 `url`, `request`, `cookies`, `locals`, `platform` 등 요청과 관련된 유용한 정보가 잔뜩 들어있습니다. 이걸 잘 활용해야 `handle` 함수를 제대로 써먹을 수 있습니다. "보물 상자 열쇠는 `event` 안에!"
*   **`event.locals`는 나만의 비밀 공간:** `handle` 함수에서 `event.locals` 객체에 값을 저장해두면, 이후에 호출되는 `load` 함수나 API 라우트 핸들러에서 그 값을 꺼내 쓸 수 있습니다. 요청 처리 과정 전반에 걸쳐 데이터를 공유하는 통로인 셈이죠. 예를 들어, 사용자 인증 정보를 `event.locals.user`에 담아두면 편리합니다.
*   **성능 생각은 하고 짜라:** `handle` 함수는 모든 요청마다 실행되니까, 여기서 너무 무거운 작업을 하거나 오래 걸리는 비동기 호출을 남발하면 앱 전체 성능이 느려질 수 있습니다. "문지기가 일 너무 오래 하면 줄 길어진다고!"
*   **에러 처리는 확실하게:** `handle`에서 에러가 터지면 앱 전체가 맛이 갈 수 있습니다. `try...catch` 등으로 예외 처리를 꼼꼼하게 하는 게 좋습니다.
*   **미리 렌더링(Prerendering) 시 동작 주의:** 미리 렌더링할 때도 `handle`이 실행되는데, 이때는 실제 사용자 요청이 아니므로 `request` 객체의 내용이 제한적일 수 있습니다. `building` 플래그 (`import { building } from '$app/environment';`)를 확인해서 미리 렌더링 중인지 아닌지 구분해서 처리해야 할 때도 있습니다. "손님 없을 때 연습 스윙하는 거랑 실전은 다르다고!"