이건 트랜스포터(transporter) 모음집입니다. 서버에서 `load` 함수나 폼 액션(form actions)을 통해 반환되는 커스텀 타입(사용자 정의 데이터 타입)들을 서버와 클라이언트 경계를 넘어 안전하게 전달할 수 있게 해주는 녀석들이죠. 각 트랜스포터는 서버에서 값을 인코딩하는 `encode` 함수 (해당 타입의 인스턴스가 아니면 `false`를 반환)와, 클라이언트에서 이를 다시 원래대로 복원하는 `decode` 함수로 구성됩니다.

예시 코드는 `src/hooks.server.js` (또는 `.ts`) 파일에 작성될 내용으로 보입니다.

```typescript
// src/hooks.server.ts (또는 .js)

import { Vector } from '$lib/math'; // 사용자 정의 Vector 클래스
import type { Transport } from '@sveltejs/kit'; // SvelteKit에서 제공하는 Transport 타입

export const transport: Transport = {
  Vector: { // 'Vector'라는 이름으로 트랜스포터 정의
    encode: (value) => value instanceof Vector && [value.x, value.y],
    // value가 Vector 클래스의 인스턴스면 [x, y] 배열로 변환, 아니면 false 반환
    decode: ([x, y]) => new Vector(x, y)
    // [x, y] 배열을 받아서 다시 new Vector(x, y)로 복원
  }
};
```

---

**얘 뭐 하는 애냐?**

SvelteKit의 `transport`는 서버에서 만든 복잡한 자바스크립트 객체(클래스 인스턴스 같은 거)를 클라이언트로 안전하게 배송해주는 일종의 "택배 시스템"입니다. 기본적으로 서버-클라이언트 간 데이터 전송은 JSON으로 직렬화 가능한 단순한 데이터만 가능한데, 이놈을 쓰면 우리가 직접 만든 클래스 객체 같은 것도 원형 그대로(는 아니지만, 본질은 유지한 채로) 주고받을 수 있게 됩니다. "객체 직구 대행 서비스"라고나 할까요.

**왜 쓰는데?**

1.  **커스텀 타입 전송:** `load` 함수나 폼 액션에서 날짜 객체(`Date`), `Map`, `Set` 또는 직접 만든 클래스 인스턴스(`Vector` 같은)를 반환하고 싶을 때 씁니다. 그냥 보내면 단순 JSON 객체로 변환되면서 메서드나 `instanceof` 체크 같은 게 다 날아가 버리는데, `transport`를 쓰면 클라이언트에서도 원래 타입처럼 다룰 수 있게 됩니다. "데이터야, 너 원래 모습으로 돌아와!"
2.  **데이터 무결성 유지:** 서버에서 특정 타입으로 작업했던 데이터를 클라이언트에서도 동일한 타입으로 인식하고 사용해야 할 때 중요합니다. 타입 정보가 유지되니 코드의 안정성과 예측 가능성이 올라가죠.
3.  **코드 중복 감소:** 비슷한 변환 로직을 여러 군데서 반복할 필요 없이, `hooks.server.ts`에 한 번 정의해두면 SvelteKit이 알아서 처리해줍니다.

**언제 불려 나오냐?**

*   **서버에서:** `load` 함수나 폼 액션이 `transport`에 등록된 커스텀 타입의 값을 반환할 때, 해당 타입의 `encode` 함수가 호출되어 데이터를 직렬화 가능한 형태로 변환합니다.
*   **클라이언트에서:** 서버로부터 데이터를 받아서 `load` 함수의 반환값이나 폼 액션의 결과를 사용할 때, SvelteKit 내부적으로 해당 타입의 `decode` 함수를 호출해서 원래 객체 형태로 복원합니다.

**쓸 때 꿀팁 및 주의사항:**

*   **`hooks.server.ts` (또는 `.js`)에 정의:** 이 `transport` 설정은 반드시 `src/hooks.server.ts` (자바스크립트 프로젝트면 `src/hooks.server.js`) 파일에 `export const transport = { ... };` 형태로 정의해야 SvelteKit이 인식합니다. "지정된 장소에 둬야 찾아가지, 아무 데나 두면 모른다!"
*   **`encode`는 `false`를 반환할 수 있어야 함:** `encode` 함수는 주어진 값이 자신이 처리할 타입의 인스턴스가 맞는지 확인하고, 아니면 `false`를 반환해야 합니다. 그래야 SvelteKit이 "아, 이건 내가 처리할 게 아니구나" 하고 넘어갑니다. `value instanceof MyClass` 같은 체크가 필수입니다.
*   **직렬화 가능한 형태로 변환:** `encode` 함수는 결국 JSON으로 변환될 수 있는 값(배열, 객체, 문자열, 숫자, 불리언)을 반환해야 합니다. 함수나 심볼 같은 건 못 보냅니다. "택배 상자에 들어가는 것만 보내라고!"
*   **`decode`는 `encode`의 역함수:** `encode`로 쪼갠 부품들을 `decode`에서 다시 조립해서 원래 객체를 만들어야 합니다. `new MyClass(...)` 형태로 복원하는 게 일반적이죠.
*   **이름이 중요:** `transport` 객체에 정의하는 키 이름(예: `Vector`)은 서버와 클라이언트 간에 이 타입을 식별하는 이름표 역할을 합니다.
*   **모든 걸 `transport`로 해결하려 들지 마세요:** 간단한 데이터는 그냥 보내도 됩니다. `transport`는 정말 커스텀 타입의 "객체성"을 유지해야 할 때 쓰는 최후의 보루 같은 느낌으로 접근하는 게 좋습니다. 남용하면 설정이 복잡해지고 오히려 성능에 부담될 수도 있습니다. "망치로 모든 못을 박을 순 있지만, 드라이버가 필요할 때도 있는 법."
*   **보안 고려:** `decode` 함수에서 입력값을 다룰 때, 예상치 못한 데이터가 들어올 가능성도 염두에 둬야 합니다. 특히 외부 입력에 의존하는 복잡한 객체를 복원한다면 더욱 그렇습니다. (이 예시처럼 단순 배열에서 객체 만드는 건 크게 문제없지만요.)