SvelteKit 라우팅 순서 정하기 (Sorting)

하나의 URL 경로에 여러 라우트 파일이 동시에 매칭될 수 있습니다. 예를 들어 `/foo-abc`라는 경로에는 아래 파일들이 전부 "나랑 맞는데?" 하고 손들 수 있다는 거죠.

*   `src/routes/[...catchall]/+page.svelte` (모든 걸 다 잡아채는 놈)
*   `src/routes/[[a=x]]/+page.svelte` (옵셔널 파라미터 `a`가 `x` 타입일 때)
*   `src/routes/[b]/+page.svelte` (동적 파라미터 `b`가 있을 때)
*   `src/routes/foo-[c]/+page.svelte` (`foo-`로 시작하고 동적 파라미터 `c`가 있을 때)
*   `src/routes/foo-abc/+page.svelte` (정확히 `foo-abc`일 때)

이러면 SvelteKit은 "그래서 누구한테 일 시켜야 돼?" 하고 멘붕이 올 수 있습니다. 그래서 SvelteKit은 다음 규칙에 따라 라우트들의 우선순위를 정합니다. 뺑소니범 잡듯이 제일 정확한 놈을 찾아내는 거죠.

1.  **구체적인 놈이 장땡:** 파라미터 없는 라우트(예: `/about`)가 동적 파라미터 하나 있는 라우트(예: `/[id]`)보다 우선순위가 높습니다. 파라미터가 적을수록, 고정된 부분이 많을수록 더 구체적인 놈으로 쳐줍니다. "범인은 키 180cm에 안경 쓴 남자!" 같이 디테일할수록 먼저 잡히는 거죠.
2.  **타입 지정된 파라미터 우대:** `[name=type]` (예: `[id=integer]`)처럼 파라미터에 타입 매처가 붙은 놈이 그냥 `[name]` (예: `[id]`)보다 우선순위가 높습니다. "그냥 남자가 아니라, '20대' 남자!" 같이 조건을 더 건 놈을 더 쳐주는 겁니다.
3.  **옵셔널이랑 나머지(rest)는 쩌리 취급 (단, 맨 뒤일 때만):** `[[optional]]` 파라미터나 `[...rest]` 파라미터는 라우트 경로의 맨 마지막 부분이 아니면 순서 정할 때 없는 셈 칩니다. 만약 맨 마지막 부분이라면, 가장 낮은 우선순위를 받습니다. 즉, `x/[[y]]/z`는 순서 정할 때는 그냥 `x/z`랑 똑같이 취급한다는 소리입니다. "있어도 그만, 없어도 그만인 애들은 일단 무시. 근데 진짜 아무도 없으면 그때 보자."
4.  **그래도 동점이면? 가나다순:** 위 규칙들로도 우선순위를 가릴 수 없으면 알파벳 순서로 정합니다. "실력 똑같으면 이름 빠른 놈이 먼저!" (실제로는 파일 경로 문자열 기준입니다)

이런 규칙들을 적용하면, 위 예시의 라우트들은 다음과 같이 줄을 서게 됩니다.

1.  `src/routes/foo-abc/+page.svelte` (가장 정확하게 일치)
2.  `src/routes/foo-[c]/+page.svelte` (그다음으로 구체적, `foo-`로 시작하고 파라미터 하나)
3.  `src/routes/[[a=x]]/+page.svelte` (옵셔널이지만 타입 매처 있음. 하지만 위 둘보다는 덜 구체적)
4.  `src/routes/[b]/+page.svelte` (일반 동적 파라미터 하나)
5.  `src/routes/[...catchall]/+page.svelte` (모든 걸 다 받는 최후의 보루)

결과적으로, 사용자가 `/foo-abc`로 접속하면 `src/routes/foo-abc/+page.svelte` 파일이 실행되고, `/foo-def`로 접속하면 (1번 파일은 안 맞으니) `src/routes/foo-[c]/+page.svelte` 파일이 실행됩니다. 덜 구체적인 나머지 쩌리들은 무시당하는 거죠.

---

**얘 뭐 하는 애냐?**

SvelteKit의 라우트 우선순위 정렬 규칙은 "어떤 URL 요청이 들어왔을 때, 여러 후보 라우트 파일 중에서 어떤 놈을 진짜 실행시킬지 결정하는 기준"입니다. 한마디로 "교통정리반장" 같은 역할이죠. 수많은 길(라우트) 중에서 지금 온 차(URL 요청)가 가야 할 정확한 길을 딱 지정해주는 겁니다. 이게 없으면 "어? 이 길도 되고 저 길도 되는데? 어디로 가야 하죠?" 하면서 시스템 전체가 혼란에 빠집니다.

**왜 쓰는데?**

1.  **명확한 라우팅:** 어떤 URL에 어떤 페이지가 떠야 하는지 예측 가능하게 만듭니다. 개발자가 의도한 대로 정확한 컴포넌트가 렌더링되도록 보장하는 거죠. "내비게이션이 정확해야 운전자가 딴 데로 안 새지!"
2.  **라우트 충돌 방지:** 여러 라우트 패턴이 겹칠 때 발생할 수 있는 모호함을 해결합니다. 예를 들어 `/[id]`랑 `/admin`이 둘 다 `/admin` 요청에 반응할 수 있다면, 더 구체적인 `/admin`이 우선되도록 해서 혼선을 막습니다.
3.  **유연한 라우팅 설계 가능:** 정적 경로, 동적 파라미터, 옵셔널 파라미터, 캐치올(catch-all) 라우트 등을 섞어 쓰면서도 SvelteKit이 알아서 우선순위를 정해주니 개발자는 좀 더 다양한 패턴의 URL 구조를 설계할 수 있습니다. "규칙만 잘 지키면 복잡한 길도 문제없어!"

**언제 불려 나오냐?**

*   사용자가 브라우저 주소창에 URL을 입력하거나, 웹사이트 내의 링크를 클릭해서 새로운 페이지로 이동하려고 할 때 SvelteKit 내부적으로 이 라우팅 우선순위 결정 로직이 번개처럼 실행됩니다.
*   개발 모드에서 파일 구조를 바꾸거나 새 라우트 파일을 추가/수정할 때도 SvelteKit이 이 규칙에 따라 내부적으로 라우트 맵을 업데이트합니다.

**쓸 때 꿀팁 및 주의사항:**

*   **구체적인 것부터 만들어라:** 가장 확실하고 좁은 범위의 라우트(예: `/about/contact`)를 먼저 만들고, 그다음 좀 더 일반적인 라우트(예: `/[category]/[item]`)를 만드는 게 정신 건강에 이롭습니다. "특등 사수부터 배치하고, 일반병은 나중에!"
*   **파일 이름이 곧 우선순위 (부분적으로):** SvelteKit은 파일 시스템 기반 라우팅이라 파일/폴더 이름이 중요합니다. 특히 동점일 경우 알파벳순 정렬 규칙 때문에 예상치 못한 결과가 나올 수도 있으니, 폴더와 파일 이름을 일관성 있게 짓는 게 좋습니다.
*   **`[...catchall]`은 최후의 수단:** 모든 걸 다 잡아채는 `[...catchall].svelte` 같은 건 이름처럼 정말 "아무것도 해당 안 될 때" 보여줄 404 페이지나 특수 처리용으로 쓰는 게 좋습니다. 이걸 너무 앞 순위 폴더에 두면 다른 라우트들이 다 씹힐 수 있습니다. "얘는 문지기야, 함부로 VIP석에 앉히지 마."
*   **옵셔널 파라미터의 함정:** `src/routes/[[lang]]/about/+page.svelte` 같은 옵셔널 파라미터는 `/about`과 `/en/about` 둘 다 매칭됩니다. 이때 `/about`이라는 정적 라우트가 따로 있다면 그게 우선됩니다. 옵셔널은 "있으면 좋고, 없어도 그만"이지만, "확실한 놈 있으면 걔한테 밀린다"는 걸 기억하세요.
*   **테스트는 필수:** 복잡한 라우팅 규칙을 만들었다면, 반드시 여러 URL로 직접 접속해보면서 의도한 대로 작동하는지 확인해야 합니다. "머릿속 시뮬레이션만 믿지 말고, 직접 돌려봐!" 개발자 도구의 네트워크 탭이나 SvelteKit 자체 디버깅 기능을 활용하면 좋습니다.