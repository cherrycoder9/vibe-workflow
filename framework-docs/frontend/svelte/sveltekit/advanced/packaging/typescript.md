**TypeScript**

니가 타입스크립트를 직접 안 쓰더라도, 니 라이브러리를 쓰는 사람들은 타입스크립트를 쓸 수 있으니 타입 정의는 꼭 제공해야 해. 그래야 그 사람들이 똑똑한 자동 완성(인텔리센스) 기능을 제대로 누릴 수 있거든. `@sveltejs/package`를 쓰면 타입 생성 과정 대부분이 알아서 처리돼. 기본적으로 라이브러리를 패키징할 때 자바스크립트, 타입스크립트, 스벨트 파일에 대한 타입 정의가 자동으로 만들어져. 니가 신경 쓸 건 `exports` 맵의 `types` 조건이 올바른 파일을 가리키도록 하는 것뿐이야. `npx sv create`로 라이브러리 프로젝트를 시작하면, 루트 익스포트에 대해서는 이 설정이 자동으로 돼.

하지만 루트 익스포트 말고 다른 경로를 제공한다면, 예를 들어 `your-library/foo` 같은 임포트를 지원한다면, 타입 정의를 제공하기 위해 추가 작업이 필요해. 안타깝게도 타입스크립트는 기본적으로 `{ "./foo": { "types": "./dist/foo.d.ts", ... }}` 같은 익스포트의 `types` 조건을 제대로 해석하지 못해. 대신 라이브러리 루트 기준으로 `foo.d.ts`를 찾으려고 하지 (즉, `your-library/dist/foo.d.ts`가 아니라 `your-library/foo.d.ts`를 찾는다는 소리). 이걸 해결하려면 두 가지 옵션이 있어:

첫 번째 옵션은 니 라이브러리를 쓰는 사람들한테 `tsconfig.json` (또는 `jsconfig.json`)의 `moduleResolution` 옵션을 `bundler`(타입스크립트 5부터 사용 가능하며, 앞으로 가장 권장되는 최고의 옵션), `node16`, 또는 `nodenext`로 설정하라고 요구하는 거야. 이렇게 하면 타입스크립트가 실제로 `exports` 맵을 보고 타입을 정확하게 해석해.

두 번째 옵션은 타입스크립트의 `typesVersions` 기능을 (약간 편법으로) 활용해서 타입을 연결하는 거야. 이건 `package.json` 안의 필드인데, 타입스크립트 버전에 따라 다른 타입 정의를 확인하거나 경로 매핑 기능을 제공해. 우리는 이 경로 매핑 기능을 이용하는 거지. 위에서 언급한 `foo` 익스포트의 경우, 해당하는 `typesVersions`는 다음과 같아:

```json
{
	"exports": {
		"./foo": {
			"types": "./dist/foo.d.ts",
			"svelte": "./dist/foo.js"
		}
	},
	"typesVersions": {
		">4.0": {
			"foo": ["./dist/foo.d.ts"]
		}
	}
}
```

`>4.0`은 사용 중인 타입스크립트 버전이 4보다 크면 (실질적으로 항상 그렇겠지) 안쪽 맵을 확인하라는 뜻이야. 안쪽 맵은 `your-library/foo`의 타이핑이 `./dist/foo.d.ts`에 있다는 것을 타입스크립트에 알려줘. 본질적으로 `exports` 조건을 복제하는 셈이지. 반복 작업을 줄이기 위해 와일드카드 `*`를 사용해서 한 번에 여러 타입 정의를 제공할 수도 있어. 단, `typesVersions`를 사용하기로 했다면 루트 임포트(보통 `"index.d.ts": [...]`로 정의됨)를 포함한 모든 타입 임포트를 이 방식을 통해 선언해야 한다는 점을 기억해.

---

**얘 뭐 하는 애냐?**
라이브러리 만들 때, 타입스크립트 쓰는 개발자들이 "이 함수 인자 뭐임?", "리턴 타입은 또 뭐고?" 하면서 헤매지 않도록, 타입 정보를 담은 설명서(`.d.ts` 파일)를 제대로 찾아갈 수 있게 길 터주는 작업이야. 특히 라이브러리 안의 특정 모듈(예: `my-lib/utils`)을 직접 땡겨 쓸 때, 타입스크립트가 "아, 이놈 타입은 저기 있구나!" 하고 똑똑하게 알아채게 만드는 거지.

**왜 쓰는데?**
1.  **개발자 경험(DX) 떡상:** 타입스크립트 유저들한테 자동완성, 실시간 타입 체크 같은 IDE 풀옵션 기능을 제공해서 개발 속도랑 편의성을 확 올려줘. "이거 잘 해놓으면 '개발자님, 복 받으실 거예요' 소리 듣는다."
2.  **버그 사전 차단:** 코드 짜는 단계에서 타입 오류를 미리 잡아내니까, 나중에 실행하다 "이게 왜 터져?" 하는 상황을 줄여줘. "런타임 에러는 개발자의 적, 타입스크립트는 든든한 아군."
3.  **라이브러리 간지 상승:** 타입 정의 잘 돼 있는 라이브러리는 뭔가 "체계가 잡혀있네" 하는 인상을 줘서 사람들이 더 믿고 쓰게 만들어. "있어빌리티"가 올라간달까.

**언제 불려 나오냐?**
네가 만든 라이브러리를 다른 사람이 타입스크립트 프로젝트에서 가져다 쓸 때, 특히 `package.json`의 `exports` 필드로 여러 진입점(subpath export, 예: `your-library/featureA`)을 제공할 때 이 설정이 중요해져. 그냥 라이브러리 이름(`your-library`) 하나만 달랑 익스포트하면 `@sveltejs/package`가 대부분 알아서 해주는데, "우리 라이브러리는 좀 더 세분화된 임포트를 지원한다!" 싶을 때 고민 시작이야.

**쓸 때 꿀팁 및 주의사항:**
*   **`moduleResolution: 'bundler'`가 대세:** 사용자 `tsconfig.json`에 `moduleResolution: 'bundler'` (TS 5.0+) 쓰라고 하는 게 제일 깔끔하고 미래지향적. 이게 `exports` 맵을 제일 잘 이해해.
*   **`typesVersions`는 차선책:** 위 방법이 여의치 않으면 `typesVersions`를 써. 근데 이거 쓰면 `package.json`이 좀 너저분해지고, 모든 경로를 다 적어줘야 해서 관리 포인트가 늘어나. "약간 구시대 유물 느낌도 나지만, 아직 쓸모는 있다."
*   **`@sveltejs/package`는 기본빵:** 대부분의 타입 생성 및 기본 설정은 `@sveltejs/package`가 잘 처리해 주니까 너무 미리부터 걱정할 필요는 없어. 네가 직접 손대야 하는 건 주로 복잡한 서브모듈 익스포트 같은 고급 설정 때야.
*   **실제 테스트는 국룰:** 설정 바꾸고 나면, 반드시 타입스크립트 쓰는 프로젝트에서 네 라이브러리 임포트해보고 타입 추론이 제대로 되는지, 자동완성은 잘 뜨는지 직접 확인해봐. "내 머릿속에선 완벽했는데? -> 현실은 시궁창" 테크 타지 않으려면 필수.
*   **`typesVersions` 쓸 거면 루트도 포함:** `typesVersions` 쓰기로 마음먹었으면, 서브모듈뿐만 아니라 루트 익스포트(예: `"index": ["./dist/index.d.ts"]`)도 빠짐없이 다 적어줘야 해. 하나라도 빼먹으면 "왜 나만 안돼!" 시전 가능.