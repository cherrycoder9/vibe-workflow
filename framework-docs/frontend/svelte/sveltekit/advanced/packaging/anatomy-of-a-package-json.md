`package.json` 그거 완전 호적등본 같은 거야. 니가 만든 라이브러리가 세상에 나가서 제대로 행세하려면 이 파일부터 잘 꾸며야 한다고. 어떤 놈인지, 뭘 할 수 있는지, 뭘 필요로 하는지 다 적혀있으니까. 중요한 항목들 하나씩 까보자.

**`name`**

```json
{
	"name": "your-library"
}
```

---

**얘 뭐 하는 애냐?**
니 라이브러리 이름표. npm에 이 이름으로 올라가고, 다른 사람들이 `npm install your-library` 할 때 쓰는 바로 그 이름. `https://npmjs.com/package/네-라이브러리-이름` 주소에도 박제됨.

**왜 쓰는데?**
세상에 니 라이브러리 존재를 알리고, 남들이 쉽게 찾아 쓰고 설치하게 하려고. 이름 없으면 뭘로 불러? "야, 거기 그거" 할 순 없잖아.

**쓸 때 꿀팁 및 주의사항:**
*   **중복 체크 필수:** npm 사이트에서 이미 누가 쓰고 있는 이름인지 꼭 확인해. 겹치면 등록 안 됨. "내가 원조 맛집 하려 했는데 옆집이 이미 쓰고 있네?" 꼴 나는 거지.
*   **간결하고 명확하게:** 너무 길거나, 특수문자 덕지덕지 붙이거나, 뭔 기능인지 감도 안 오는 이름은 피하는 게 상책. 개발자들이 기억하기 쉽게.
*   **대소문자 구분 없음 (사실상):** npm은 패키지 이름을 소문자로 처리하니까, `Your-Library`나 `your-library`나 같은 걸로 침. 그냥 속 편하게 소문자로 쭉 밀어.

**`license`**

```json
{
	"license": "MIT"
}
```

---

**얘 뭐 하는 애냐?**
니 라이브러리 사용 허가서. "이 코드 가져다 써도 되는데, 이런 조건은 지켜줘. 그리고 문제 생겨도 난 책임 안 짐." 같은 내용을 담는 법적 문서 같은 거.

**왜 쓰는데?**
1.  **사용 범위 명확화:** 다른 사람들이 니 코드를 어떤 조건 하에 사용할 수 있는지 (상업적 이용 가능? 수정 가능? 배포 시 출처 표기해야 하나?) 알려줘서 분쟁 소지를 줄임.
2.  **저작권 보호 (겸 포기):** 니가 만든 코드지만, "이런 조건만 지키면 자유롭게 쓰세요~" 하고 권리를 일정 부분 열어주는 거지. 완전 무법천지로 만들 순 없으니까.
3.  **생태계 기여:** 오픈소스 정신! 라이선스 명시 안 하면 다른 사람들이 쓰기 찜찜해함. "이거 써도 되나? 나중에 고소당하는 거 아냐?"

**쓸 때 꿀팁 및 주의사항:**
*   **`LICENSE` 파일도 같이 넣어라:** `package.json`에 딸랑 "MIT" 적는다고 끝나는 게 아님. 해당 라이선스 전문이 담긴 `LICENSE` (또는 `LICENSE.md`) 파일을 프로젝트 루트에 같이 넣어줘야 국룰.
*   **MIT가 만능은 아님:** MIT 라이선스가 쿨하고 쓰기 편해서 많이 쓰이지만 (거의 "가져다 쓰되 내 책임은 없음" 수준), 니 라이브러리 성격이나 니 철학에 따라 다른 라이선스(GPL, Apache 등)를 고려해야 할 수도 있음. 잘 모르면 MIT가 제일 무난빵.
*   **라이선스 없으면? All rights reserved:** 명시 안 하면 기본적으로 "모든 권리 소유함. 건들지 마셈." 상태라 남들이 못 씀. 오픈소스로 풀 거면 반드시 명시.

**`files`**

```json
{
	"files": ["dist"]
}
```

---

**얘 뭐 하는 애냐?**
npm에 패키지 올릴 때 "이것들만 챙겨서 올려!" 하고 콕콕 집어주는 이삿짐 목록 같은 거.

**왜 쓰는데?**
1.  **패키지 용량 다이어트:** 개발할 때 쓰는 온갖 잡다한 파일들(테스트 코드, 원본 소스 파일, 설정 파일, 임시 파일 등)까지 다 올리면 패키지 용량만 쓸데없이 커짐. 설치 시간도 오래 걸리고.
2.  **깔끔한 배포:** 사용자한테는 실제 실행에 필요한 최소한의 파일만 제공하는 게 예의. "손님, 이건 드시면 안 돼요. 이건 장식입니다."

**쓸 때 꿀팁 및 주의사항:**
*   **`package.json`, `README`, `LICENSE`는 자동 포함:** 얘네는 `files` 목록에 없어도 알아서 딸려 올라감. "필수템이라 이미 챙겨놨어."
*   **빌드 결과물 폴더 지정:** 보통 `dist`나 `build` 같은 폴더에 컴파일/번들링된 최종 결과물이 들어가는데, 이걸 꼭 포함시켜야 함. 안 그러면 사용자는 빈 껍데기만 받음.
*   **`.npmignore` 활용:** `files`에 포함할 것만 적는 게 귀찮거나, 제외할 게 더 명확하면 `.npmignore` 파일 만들어서 "얘네는 빼고 올려줘" 할 수도 있음. `.gitignore`랑 비슷한데 npm 배포 전용.
*   **와일드카드 사용 가능:** `["dist", "src/**/*.js"]` 이런 식으로 특정 패턴에 맞는 파일들만 지정할 수도 있음. 근데 보통은 빌드된 `dist` 폴더 하나만 딱 지정하는 게 깔끔.

**`exports`**

```json
{
	"exports": {
		".": {
			"types": "./dist/index.d.ts",
			"svelte": "./dist/index.js"
		}
	}
}
```

---

**얘 뭐 하는 애냐?**
니 라이브러리의 공식 출입구 안내도. "메인 기능은 이쪽(`your-library`)으로, 특정 컴포넌트는 저쪽(`your-library/Foo.svelte`)으로 들어오세요~" 하고 알려주는 역할. 모듈 시스템(ESM, CommonJS)이나 환경(Node.js, 브라우저, 타입스크립트)에 따라 다른 문을 안내해 줄 수도 있음.

**왜 쓰는데?**
1.  **캡슐화 및 명확한 API 제공:** 사용자가 라이브러리 내부 파일 구조를 알 필요 없이, 정해진 경로로만 기능에 접근하게 해서 깔끔한 사용 경험을 줌. "복잡한 내부는 몰라도 되고, 이것만 쓰면 돼."
2.  **다양한 환경 지원:** "타입스크립트 쓰는 사람은 이 타입 정의 파일 참고하고, 스벨트 쓰는 사람은 이 JS 파일 가져가." 이런 식으로 환경에 맞는 최적의 파일을 제공 가능.
3.  **트리 쉐이킹 최적화:** 번들러가 "아, 이 라이브러리는 이 경로들만 쓰라고 공식적으로 지정했구나" 하고 인지해서, 안 쓰는 코드를 더 효과적으로 쳐낼 수 있게 도와줌 (이론상).

**쓸 때 꿀팁 및 주의사항:**
*   **`.` (점 하나)는 기본 출입구:** `import { something } from 'your-library'` 했을 때 뭘 가져올지 정의. 이게 핵심.
*   **`types`는 타입스크립트 사용자를 위한 배려:** 타입 정의 파일(`.d.ts`) 경로를 알려줘서 자동완성 같은 IDE 기능을 제대로 쓰게 해줌. 타입스크립트 라이브러리라면 필수. 없으면 "이거 타입 뭐냐?" 소리 나옴.
*   **`svelte`는 스벨트 전용 출입구:** 스벨트 컴파일러나 관련 도구들이 "아, 이건 스벨트 컴포넌트 라이브러리구나" 하고 알아먹게 해주는 신호. 스벨트 컴포넌트 아니면 `default` 같은 걸로 대체 가능.
*   **엔트리 포인트 추가 시 신중하게:** `your-library/utils`처럼 하위 경로로도 접근하게 만들 수 있는데, 이때 각 경로마다 `types` 같은 조건도 잘 챙겨줘야 함. 안 그러면 타입스크립트 사용자가 "왜 여긴 타입 없어!" 하고 화냄.
*   **잘못 설정하면 "모듈 못 찾겠다 꾀꼬리":** 경로 틀리거나 파일 없으면 바로 `Module not found` 에러 파티. 배포 전에 꼭 테스트해봐야 함.

**`svelte` (레거시 필드)**

```json
{
	"svelte": "./dist/index.js"
}
```

---

**얘 뭐 하는 애냐?**
"저 스벨트 라이브러리인데요..." 하고 옛날 방식 도구들한테 자기소개하는 명찰. `exports` 필드의 `svelte` 조건이 나오기 전에 쓰던 방식.

**왜 쓰는데?**
**하위 호환성.** 아직 `exports` 필드의 `svelte` 조건을 못 알아먹는 구닥다리 빌드 도구나 IDE 확장 프로그램들이 있을 수 있어서, 걔네들한테 "나 스벨트 컴포넌트 라이브러리 맞거든?" 하고 알려주려고 남겨둠. "혹시 모르니 일단 달아는 놓자."

**쓸 때 꿀팁 및 주의사항:**
*   **`exports` 필드 쓰면 사실상 없어도 됨 (요즘엔):** 최신 스벨트킷이나 관련 도구들은 `exports` 필드를 우선적으로 잘 확인함. 그래도 아직까진 넣어두는 게 "안전빵".
*   **루트 엔트리 포인트를 가리켜라:** 보통 라이브러리의 메인 JS 파일 (예: `dist/index.js`)을 지정함.
*   **언젠가는 사라질 운명:** 기술은 계속 발전하니까, 이 필드도 점점 역사의 뒤안길로... 하지만 당분간은 보험 삼아 넣어두자.

**`sideEffects`**

```json
{
	"sideEffects": ["**/*.css"]
}
```

---

**얘 뭐 하는 애냐?**
번들러(웹팩, 롤업 등)한테 "이 파일들은 건들면 전역 상태가 바뀌거나 뭔가 일이 터질 수 있으니까, 코드에서 직접 안 쓰는 것처럼 보여도 함부로 지우지 마!" 라고 알려주는 안전 표지판.

**왜 쓰는데?**
1.  **똑똑한 트리 쉐이킹 유도:** 번들러는 안 쓰는 코드를 알아서 제거(트리 쉐이킹)해서 최종 결과물 크기를 줄이려고 함. 근데 어떤 파일들은 `import`만 해도 전역 스타일을 먹이거나(`*.css`), `window` 객체에 뭔가를 추가하는 등 "사이드 이펙트"를 일으킴. 이런 파일들은 사용 여부와 관계없이 번들에 포함되어야 함.
2.  **CSS 파일 보호:** CSS 파일은 대표적인 사이드 이펙트 유발자. `import './styles.css'` 하면 그 스타일이 전역에 적용되잖아? 이걸 `sideEffects`에 명시 안 하면 번들러가 "어? 이 CSS 파일에서 뭘 `export`해서 쓰는 것도 없네? 지워야지!" 하고 스타일 다 날려 먹을 수 있음. "내 예쁜 CSS 돌려내!"
3.  **의도치 않은 기능 삭제 방지:** 전역 폴리필이나 특정 라이브러리 초기화 코드처럼, `import` 자체로 의미가 있는 코드들이 실수로 제거되는 걸 막음.

**쓸 때 꿀팁 및 주의사항:**
*   **`false`로 설정:** "내 라이브러리엔 사이드 이펙트 있는 파일 하나도 없음! 순수 그 자체! 안 쓰는 건 다 지워도 돼!" 라는 강력한 선언. 번들러가 더 공격적으로 트리 쉐이킹 가능. 근데 진짜 자신 있을 때만 써야 함. CSS 파일도 없어야 하고, 전역 건드리는 JS도 없어야 함.
*   **배열로 특정 파일/패턴 지정:** `["**/*.css", "./dist/init-global-stuff.js"]` 이런 식으로 사이드 이펙트 있는 파일들만 콕콕 집어줄 수 있음. 이게 제일 흔한 방식.
*   **라이브러리 개발자라면 필독:** 니 라이브러리가 CSS 파일을 포함하거나, `import`만으로 뭔가 하는 코드가 있다면 반드시 `sideEffects` 설정을 제대로 해줘야 사용자들이 피 안 봄. 안 그러면 "님 라이브러리 쓰니까 스타일 다 깨짐 ㅠㅠ" 소리 듣는다.
*   **Vite는 좀 덜 민감, Webpack은 중요:** 번들러마다 `sideEffects` 처리 방식이 약간 다를 수 있음. Vite는 자체적으로 CSS 등을 잘 처리하는 경향이 있지만, Webpack 같은 다른 번들러와의 호환성을 위해 명시해주는 게 좋음. "만약을 대비하는 자세, 칭찬해."