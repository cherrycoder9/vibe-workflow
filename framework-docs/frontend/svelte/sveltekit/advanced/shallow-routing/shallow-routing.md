**Shallow routing**

스벨트킷 앱에서 페이지를 이동하면 히스토리 목록에 항목이 쌓이지. 뒤로 가기, 앞으로 가기 버튼 누르면 이 목록을 오가면서 필요에 따라 `load` 함수 다시 돌리고 페이지 컴포넌트도 갈아 끼우고.

근데 가끔은 페이지 이동 없이 히스토리 항목만 만들고 싶을 때가 있어. 예를 들어 모달 창을 띄웠는데, 사용자가 뒤로 가기 제스처로 그 창을 닫게 하고 싶을 때 말이야. 특히 모바일에서는 직접 UI 건드리는 것보다 스와이프 제스처가 더 편할 때가 많거든. 이런 상황에서 히스토리 항목이랑 연결 안 된 모달은 사용자 뒷목 잡게 만들기 딱 좋아. 닫으려고 뒤로 스와이프 했는데 엉뚱한 페이지로 가버리면 "아놔!" 소리 절로 나오지.

스벨트킷은 `pushState`랑 `replaceState` 함수로 이걸 가능하게 해. 페이지 이동 없이 히스토리 항목에 상태 값을 연결할 수 있게 해주거든. 예를 들어 히스토리 기반 모달을 이렇게 만들 수 있어:

`+page.svelte`
```typescript
<script lang="ts">
	import { pushState } from '$app/navigation';
	import { page } from '$app/state'; // 오타 수정: $app/state가 아니라 $app/stores에서 가져와야 할 수도 있음. (공식 문서 확인 필요)
	                                  // 하지만 일단 주어진 코드대로 설명함.
	import Modal from './Modal.svelte';

	function showModal() {
		// URL은 그대로 두고, 히스토리 상태에 showModal: true를 추가
		pushState('', {
			showModal: true
		});
	}
</script>

{#if $page.state.showModal} <!-- $page.state로 접근하려면 $app/stores에서 page를 가져와야 함 -->
	<Modal close={() => history.back()} />
{/if}
```
이 모달은 뒤로 가기 (그러면 `$page.state.showModal`이 알아서 `false` 비슷한 걸로 바뀜)로 닫거나, 모달 자체의 닫기 버튼 같은 걸 눌러서 `close` 콜백 함수(`history.back()` 호출)를 실행시켜서 프로그래밍 방식으로 닫을 수 있어.

---

**얘 뭐 하는 애냐?**
`Shallow routing`은 말 그대로 "얕은 라우팅"이야. 페이지 전체를 새로고침하거나 데이터를 다시 불러오는 "깊은" 라우팅 대신, URL이나 히스토리 상태만 살짝 바꿔치기해서 실제 페이지 이동 없이 UI의 일부만 변경하는 기술이지. "겉모습만 살짝 바꿨어요, 속은 그대로!" 뭐 이런 느낌. 사용자는 URL이 바뀌거나 뒤로 가기가 되는 걸 보고 페이지가 이동했다고 느낄 수 있지만, 실제로는 같은 페이지에 머무르면서 내용 일부만 샥 바뀐 거야.

**왜 쓰는데?**
1.  **사용자 경험(UX) 향상:** 모달 창, 탭 전환, 필터링 결과 같은 걸 보여줄 때 페이지 전체를 리로드하면 버벅거리고 사용자 짜증 지수 올라가잖아. Shallow routing 쓰면 이런 자잘한 UI 변경을 부드럽게 처리하면서도 브라우저 히스토리(뒤로 가기/앞으로 가기) 기능을 살릴 수 있어. "새로고침 없이 쾌적하게!"
2.  **상태 공유 및 복원 용이:** 모달이 열린 상태나 특정 탭이 선택된 상태를 URL이나 히스토리 상태에 저장해두면, 사용자가 그 URL을 공유하거나 나중에 다시 방문했을 때 동일한 상태를 복원하기 쉬워. "야, 이 필터 먹인 상태로 봐봐!" (URL에 반영했을 경우)
3.  **모바일 친화적:** 본문에서 말했듯이, 모바일에서 뒤로 가기 제스처로 모달 닫는 건 거의 국룰이거든. Shallow routing으로 히스토리 항목을 만들어주면 이런 자연스러운 사용자 경험을 제공할 수 있어.

**언제 불려 나오냐?**
주로 클라이언트 사이드에서 사용자 인터랙션에 따라 UI의 일부를 변경하고 싶지만, 서버에서 새 데이터를 가져올 필요는 없을 때 사용해.
*   모달 창을 띄우고 닫을 때
*   탭 UI에서 다른 탭으로 전환할 때
*   데이터 목록에 필터나 정렬 조건을 적용할 때
이럴 때 `pushState`나 `replaceState` 함수를 호출해서 히스토리 스택을 조작하는 방식으로 구현해.

**쓸 때 꿀팁 및 주의사항:**
*   **`pushState` vs `replaceState`:**
    *   `pushState(url, data)`: 새 히스토리 항목을 추가해. 사용자가 뒤로 가기 하면 이전 상태로 돌아갈 수 있지. 모달 띄울 때 주로 써. "나 여기 왔다감! (도장 쾅)"
    *   `replaceState(url, data)`: 현재 히스토리 항목을 교체해. 뒤로 가기 해도 이 변경 직전 상태로는 못 돌아가. 자잘한 필터 변경처럼 굳이 히스토리에 남길 필요 없을 때 써. "원래 있던 놈 밀어내고 내가 차지!"
*   **상태 객체(`data`) 활용:** `pushState('', { showModal: true })`처럼 두 번째 인자로 넘긴 객체는 `$page.state` (정확히는 `$app/stores`의 `page` 스토어를 통해 `page.state`로 접근)에 저장돼. URL에 드러나지 않는 상태 값을 관리하기 좋아.
*   **URL도 바꿀 수 있지만, `load` 함수는 안 탄다!:** `pushState('/items?filter=active', { ... })`처럼 첫 번째 인자로 URL을 넘기면 브라우저 주소창의 URL도 바꿀 수 있어. 하지만 스벨트킷의 `load` 함수는 다시 실행되지 않는 게 핵심이야. 이게 Shallow routing의 특징! "주소는 바꿨지만, 데이터는 재활용!"
*   **뒤로 가기/앞으로 가기 처리:** 사용자가 브라우저 버튼이나 제스처로 뒤로/앞으로 이동하면 `$page.state`가 변경된 값으로 업데이트돼. 이 변화를 감지해서 UI(예: 모달 닫기, 필터 해제)를 알맞게 업데이트 해줘야 해. 안 그러면 "어? URL은 바뀌었는데 화면은 왜 그대로지?" 같은 버그 파티 열린다.
*   **남용은 금물:** 모든 사소한 UI 변경에 다 `pushState`를 때려 박으면 브라우저 히스토리 스택이 더러워지고 사용자가 "내가 어디로 돌아가고 있는 거지?" 하며 길을 잃을 수 있어. 꼭 필요하고 의미 있는 상태 변화에만 쓰는 게 좋아.
*   **초기 상태 고려:** 사용자가 Shallow routing으로 변경된 URL로 바로 접속하거나, 페이지를 새로고침하면 `$page.state`는 초기화될 수 있어. 이럴 때를 대비해서 `load` 함수에서 URL 파라미터 등을 읽어 초기 UI 상태를 설정하는 로직도 필요할 수 있다. "첫인상도 중요하다고!"