네 레이아웃의 `load` 함수를 서버에서만 돌리고 싶다고? 그럼 `+layout.js`에 있던 코드를 `+layout.server.js` 파일로 옮기고, 타입도 `LayoutLoad`에서 `LayoutServerLoad`로 바꿔주면 돼.

`+layout.js`랑 마찬가지로, `+layout.server.js`에서도 페이지 옵션들(`prerender`, `ssr`, `csr`)을 설정할 수 있어.

---

**얘 뭐 하는 애냐?**
이름 끝에 `.server` 붙은 놈들은 딱 보면 감이 오지? "나는 서버에서만 일한다!" 이거야. `+layout.server.js`는 레이아웃에 필요한 데이터를 가져오거나 처리할 때, 그 작업을 오직 서버에서만 하도록 강제하는 녀석이지. 클라이언트(브라우저)에는 코드 한 줄 넘어가지 않아. "니들(브라우저)은 결과만 받아먹어!" 이런 느낌.

**왜 쓰는데?**
1.  **보안 철통방어**: API 키, 데이터베이스 접속 정보 같은 민감한 정보는 브라우저에 노출되면 바로 대참사잖아? 이런 건 서버에서만 다뤄야 안전빵이지. `+layout.server.js`는 이런 비밀스러운 작업을 하기에 딱 좋아. "비밀번호는 나만 알 거임."
2.  **서버 전용 작업**: 데이터베이스 직접 조회, 파일 시스템 접근, 혹은 서버 환경에서만 돌아가는 라이브러리 사용 등, 브라우저에서는 꿈도 못 꿀 작업들을 여기서 처리할 수 있어.
3.  **성능 최적화 (가끔)**: 모든 데이터를 클라이언트로 보내서 처리하는 것보다, 서버에서 미리 필요한 부분만 딱 정리해서 보내주면 네트워크 트래픽도 줄고 클라이언트 부담도 덜 수 있지. 물론, 서버 부하도 고려해야 하지만.
4.  **`ssr=false`일 때도 데이터는 서버에서**: `ssr` 옵션을 꺼서 클라이언트 사이드 렌더링만 하더라도, 초기 데이터 로딩은 이놈을 통해 서버에서 가져올 수 있어. 첫 화면 깡통으로 보이는 거 막아주는 역할.

**언제 불려 나오냐?**
*   서버에서 페이지를 처음 렌더링할 때, 해당 레이아웃이 적용되면 이놈의 `load` 함수가 실행돼.
*   클라이언트 사이드 네비게이션 중에도, 만약 해당 레이아웃에 `csr=false` 옵션이 걸려있거나, `+layout.js`가 없어서 데이터 로딩을 서버에 의존해야 한다면 서버의 `+layout.server.js`가 호출될 수 있어. (보통은 `+layout.js`와 함께 쓰여서, `+layout.js`가 `+layout.server.js`의 데이터를 받아오는 구조로 많이 쓰이지.)

**쓸 때 꿀팁 및 주의사항:**
*   **브라우저 API는 꿈도 꾸지 마**: `window`, `document` 같은 브라우저 전용 객체 여기서 쓰려고 하면 바로 에러 파티다. "여긴 서버라고, 정신 차려!"
*   **`+layout.js`랑 같이 쓸 때 데이터 흐름 파악 필수**: `+layout.server.js`에서 `load`로 데이터 만들고, 그걸 `+layout.js`의 `load` 함수에서 `data` 매개변수로 받아서 가공하거나 그대로 넘기는 패턴이 일반적. 둘이 어떻게 데이터 주고받는지 모르면 머리 터진다.
*   **민감 정보는 여기서만!**: DB 접속, 외부 API 비밀 키 사용 등은 무조건 `.server.js` 파일 안에서 끝내야 해. 클라이언트 쪽(`+layout.js`나 `+page.js`)으로 민감 정보가 그대로 넘어가면 보안 사고 나는 거 한순간이다.
*   **페이지 옵션과의 관계**: `prerender`, `ssr`, `csr` 옵션에 따라 이놈의 `load` 함수가 실행되는 방식이나 시점이 달라질 수 있으니, 각 옵션의 의미를 정확히 알고 써야 한다. 특히 `prerender` 시에는 빌드 타임에 실행된다는 점!
*   **`+page.server.js`와의 역할 분담**: 레이아웃 전반에 필요한 데이터는 `+layout.server.js`에, 특정 페이지만을 위한 서버 사이드 데이터 로직은 `+page.server.js`에 두는 식으로 역할을 나누면 코드가 깔끔해진다. "영역 확실히 나눠서 일하자, 헷갈리니까."