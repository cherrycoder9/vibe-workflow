전역 상태(global state)를 못 쓴다면서 `$page.data` 같은 앱 상태나 스토어는 어떻게 쓰는 건지 궁금했을 거야. 정답은 바로 스벨트(Svelte)의 컨텍스트(context) API를 서버에서 써먹는다는 거지. 상태나 스토어를 `setContext`로 컴포넌트 트리에 딱 붙여놓고, 필요할 때 `getContext`로 쏙 빼오는 방식이야. 우리만의 상태 관리에도 이 방법을 그대로 적용할 수 있어.

**레이아웃 파일 (src/routes/+layout.svelte) 예시:**

```html
<script lang="ts">
	import { setContext } from 'svelte';
	import type { LayoutProps } from './$types';
	let { data }: LayoutProps = $props();

	// 우리 상태를 참조하는 함수를 컨텍스트에 넘겨서
	// 자식 컴포넌트들이 접근할 수 있게 한다
	setContext('user', () => data.user);
</script>

<slot />
```

**페이지 파일 (src/routes/user/+page.svelte) 예시:**

```html
<script lang="ts">
	import { getContext } from 'svelte';

	// 컨텍스트에서 user 스토어(여기선 상태 함수)를 가져온다
	const user = getContext('user');
</script>

<p>{user().name}님, 환영합니다!</p>
```

`setContext`에 함수를 넘기는 이유는 경계를 넘나들며 반응성(reactivity)을 유지하기 위해서야. 더 자세한 건 [여기](https://svelte.dev/docs/svelte#setcontext)서 읽어보도록. (링크는 생략할게, 알지?)

`svelte/store`의 스토어를 이 용도로 쓸 수도 있지만, 스벨트 5 버전을 쓴다면 대신 유니버설 반응성(universal reactivity)을 활용하는 걸 추천해.

서버 사이드 렌더링(SSR) 중에 하위 페이지나 컴포넌트에서 컨텍스트 기반 상태 값을 업데이트해도, 부모 컴포넌트의 값에는 영향을 주지 않아. 왜냐하면 상태 값이 업데이트될 시점에는 부모가 이미 렌더링 끝난 상태거든. 반대로 클라이언트에서는 (기본적으로 활성화된 CSR 환경에서) 값이 전파되고 계층 구조상 상위에 있는 컴포넌트, 페이지, 레이아웃들이 새 값에 반응해. 따라서 하이드레이션(hydration) 중 상태 업데이트 시 값이 번쩍이는 현상(values 'flashing')을 피하려면, 상태를 위로 올리기보다는 아래로 내려주는 게 일반적인 권장 사항이야.

만약 SSR을 안 쓰고 (그리고 앞으로도 절대 쓸 일 없다고 확신한다면), 컨텍스트 API 없이 그냥 공유 모듈에 상태를 안전하게 보관해도 돼.

---

**얘 뭐 하는 애냐?**
스벨트에서 "전역 변수처럼 아무 데서나 막 쓰진 못하지만, 그래도 컴포넌트 트리 안에서는 여기저기서 공유하고 싶은 데이터"를 안전하고 체계적으로 관리하는 방법이야. `setContext`로 "이거 우리 식구들끼리만 쓰는 비밀 정보야" 하고 숨겨두면, `getContext`로 "나 그 비밀 정보 좀 줘" 하고 꺼내 쓰는 거지. "우리 집 가보(家寶)를 자식들한테만 물려주는 느낌"이랄까.

**왜 쓰는데?**
1.  **props 드릴링 회피:** 데이터를 최상위에서 최하위 컴포넌트까지 일일이 props로 전달하는 고통(props drilling)에서 해방될 수 있어. "택배 상하차 알바를 면제시켜주는 마법."
2.  **깔끔한 상태 관리:** 전역 변수 남발로 인한 "이거 어디서 바뀐 거야?" 하는 혼란을 막아줘. 데이터 흐름을 특정 컴포넌트 트리로 제한해서 예측 가능하게 만들어.
3.  **서버/클라이언트 호환성:** 특히 SSR 환경에서 앱 전체에 걸친 상태를 안전하게 공유하는 데 유용해. 스벨트킷의 `$page` 같은 내부 기능도 이 방식을 쓴다니, 믿고 쓸 만하지.
4.  **스벨트 5 반응성 활용:** 스벨트 5부터는 일반적인 자바스크립트 변수나 객체도 반응형으로 만들 수 있는데(룬, runes), 이걸 컨텍스트랑 같이 쓰면 스토어 없이도 깔끔하게 상태 관리가 가능해.

**언제 불려 나오냐?**
*   여러 중첩된 컴포넌트에서 동일한 데이터나 상태 로직을 공유해야 할 때.
*   레이아웃 컴포넌트에서 가져온 데이터를 하위 페이지나 컴포넌트에서 사용하고 싶을 때.
*   테마(다크 모드/라이트 모드), 사용자 인증 정보, 국제화 설정처럼 앱의 특정 부분 전반에 걸쳐 필요한 상태를 관리할 때.

**쓸 때 꿀팁 및 주의사항:**
*   **`setContext`는 부모, `getContext`는 자손:** `setContext`는 반드시 컴포넌트 초기화 시점에 호출해야 하고, `getContext`는 `setContext`가 호출된 컴포넌트의 자식 또는 그 자손 컴포넌트에서만 쓸 수 있어. "족보 꼬이면 집안 망한다."
*   **키(key)는 신중하게:** `setContext('myKey', value)` 할 때 쓰는 'myKey'는 문자열이나 심볼(Symbol)을 쓸 수 있는데, 앱 전체에서 겹치지 않게 잘 관리해야 해. 보통 심볼을 쓰는 게 충돌 방지에 더 안전해.
*   **반응성은 함수로 전달:** 예제처럼 `setContext('user', () => data.user)` 이렇게 함수로 감싸서 넘겨야 `data.user`가 바뀌었을 때 `getContext`로 가져다 쓰는 쪽에서도 변경을 감지할 수 있어 (스벨트 5의 룬 이전 방식). 스벨트 5 룬을 쓰면 그냥 `setContext('user', data.user)`처럼 해도 반응성이 유지될 수 있지만, 공식 문서 예제가 함수를 쓰는 건 이유가 있는 거야.
*   **SSR 시 업데이트 주의:** 본문에도 나왔지만, SSR 중에는 자식이 부모 상태를 바꾸는 게 반영 안 돼. "이미 기차 떠났는데 손 흔들어봐야 소용없다." 클라이언트에서만 양방향 업데이트가 원활하니, SSR을 쓴다면 데이터 흐름은 위에서 아래로(top-down) 설계하는 게 속 편해.
*   **꼭 컨텍스트 써야 하나?** 상태 공유 범위가 아주 좁거나, SSR 전혀 안 쓴다면 그냥 `.js`나 `.ts` 파일에 `export let sharedState = ...` 하고 가져다 써도 돼. 하지만 앱이 커지거나 SSR 도입 가능성이 있다면 컨텍스트가 정석이야. "야매로 하다가 나중에 피똥 싸지 말고, 처음부터 제대로 하자."
*   **스토어 vs 컨텍스트:** `svelte/store`도 컨텍스트랑 비슷한 역할을 할 수 있지만, 컨텍스트는 스벨트 코어 기능이고 좀 더 유연하게 쓸 수 있어. 스벨트 5에서는 룬(runes) 기반 반응형 상태를 컨텍스트로 넘기는 게 대세가 될 거야. "신문물 나왔으면 써보는 게 인지상정."