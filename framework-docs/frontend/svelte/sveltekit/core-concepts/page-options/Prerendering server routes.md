**Route announcements (라우트 알림)**

옛날 방식의 서버 렌더링 앱에서는 링크(`<a>` 태그 같은 거)를 누를 때마다 페이지 전체가 새로고침됐어. 이때 스크린 리더 같은 보조 기술은 새 페이지의 제목을 읽어줘서 사용자가 "아, 페이지가 바뀌었구나" 하고 알 수 있었지.

근데 스벨트킷(SvelteKit)에서는 페이지 이동할 때 새로고침 없이 샤샥 바뀌잖아? 이걸 클라이언트 사이드 라우팅이라고 하는데, 이 방식 때문에 스벨트킷은 페이지 이동할 때마다 새 페이지 이름을 알려주는 '라이브 리전(live region)'이라는 걸 페이지에 슬쩍 끼워 넣어. 이놈이 `<title>` 태그를 쓱 보고 페이지 이름을 알아내서 알려주는 거야.

그래서 네 앱의 모든 페이지는 각자 다르고 설명적인 제목을 가져야 해. 스벨트킷에서는 각 페이지에 `<svelte:head>` 요소를 넣어서 이걸 할 수 있어.

예시) `src/routes/+page.svelte`
```html
<svelte:head>
	<title>할 일 목록</title>
</svelte:head>
```
이렇게 하면 페이지 이동 후에 스크린 리더 같은 보조 기술이 새 페이지를 인식할 수 있게 돼. 그리고 이런 설명적인 제목은 SEO(검색 엔진 최적화)에도 중요해. "제목이 구리면 검색해도 안 나온다, 이 말이야."

**Prerendering server routes (서버 라우트 사전 렌더링)**

다른 페이지 옵션들과는 다르게, `prerender` 옵션은 `+server.js` 파일에도 적용돼. 이 파일들은 레이아웃의 영향을 받지는 않지만, 만약 어떤 페이지가 이 서버 라우트에서 데이터를 가져간다면, 그 페이지의 기본값을 상속받을 거야. 예를 들어 `+page.js` 파일에 이런 `load` 함수가 있다고 치자.

예시) `+page.js`
```javascript
import type { PageLoad } from './$types';
export const prerender = true; // 이 페이지는 사전 렌더링한다!

export const load: PageLoad = async ({ fetch }) => {
	const res = await fetch('/my-server-route.json'); // 서버 라우트에서 데이터 가져오기
	return await res.json();
};
```
이러면 `src/routes/my-server-route.json/+server.js` 파일에 자체적으로 `export const prerender = false`라고 명시하지 않는 한, 이 서버 라우트도 사전 렌더링 대상으로 취급될 거야. "딱히 하지 말라고 안 하면 그냥 같이 해버린다, 이거지."

---

**얘네 뭐 하는 애들이냐?**

*   **Route announcements:** 이건 시각 장애인 사용자를 위한 배려 기능이야. 페이지가 휙휙 바뀌는데 아무 소리도 안 나면 "지금 내가 어디 있는 거지?" 싶을 거 아냐. 그걸 막기 위해 페이지 바뀔 때마다 "지금 '할 일 목록' 페이지입니다~" 하고 알려주는 착한 기능이지. 물론, 일반 사용자에게도 페이지 제목은 중요하고.
*   **Prerendering server routes:** 이건 빌드할 때 아예 API 응답까지 미리 만들어두는 기능이야. 사용자가 접속했을 때 서버에서 또 계산하고 자시고 할 필요 없이 이미 만들어진 JSON 파일을 띡 던져주니까 속도가 빠르겠지? "손님 오시기 전에 음식 미리 다 해놓는 식당 같은 거야."

**왜 쓰는데?**

*   **Route announcements:**
    1.  **웹 접근성 향상:** 스크린 리더 사용자에게 명확한 페이지 전환 정보를 제공해서 사용성을 높여. "모두에게 친절한 웹을 만들자!"
    2.  **SEO (검색 엔진 최적화):** 각 페이지마다 의미 있는 제목이 있으면 검색 엔진이 내용을 더 잘 이해하고, 검색 결과에도 잘 노출돼. "제목 맛집이 검색 상위권 차지한다."
*   **Prerendering server routes:**
    1.  **성능 향상:** 빌드 시점에 API 응답을 생성해두니까, 실제 요청 시 서버 부하가 줄고 응답 속도가 빨라져. "미리 계산해두면 나중에 편하다."
    2.  **정적 호스팅 가능:** API 응답까지 파일로 만들어지니까, 복잡한 서버 없이 정적 파일 호스팅 서비스(GitHub Pages, Netlify 등)에 배포하기 쉬워져. "서버 관리? 그게 뭐죠? 먹는 건가요?"

**언제 불려 나오냐?**

*   **Route announcements:** 스벨트킷 앱에서 클라이언트 사이드 라우팅으로 페이지가 전환될 때마다 자동으로 작동해. 개발자가 `<svelte:head>` 안에 `<title>`만 잘 넣어주면 돼.
*   **Prerendering server routes:** `+page.js`나 `+server.js` 파일에 `export const prerender = true;` (또는 명시적으로 `false`로 설정하지 않은 경우)를 설정하고 빌드할 때 작동해.

**쓸 때 꿀팁 및 주의사항:**

*   **Route announcements:**
    *   **모든 페이지에 유니크한 `<title>`은 국룰:** 복붙하거나 대충 쓰지 말고, 각 페이지 내용을 잘 요약하는 제목을 달아줘. "제목만 봐도 내용을 알 수 있게!"
    *   **동적 제목도 가능:** `load` 함수에서 가져온 데이터로 제목을 동적으로 만들 수도 있어. 예를 들어 블로그 글 제목을 페이지 타이틀로 쓰는 거지.
*   **Prerendering server routes:**
    *   **모든 API가 사전 렌더링 가능한 건 아냐:** 사용자별 데이터나 실시간으로 변하는 데이터는 사전 렌더링하면 안 되겠지? "어제 주식 시세를 오늘 보여줄 순 없잖아." 이런 건 `export const prerender = false;`로 명시적으로 꺼줘야 해.
    *   **`fetch` 경로 주의:** `load` 함수 안에서 `fetch`로 서버 라우트를 호출할 때, 상대 경로를 쓰면 빌드 시점에 스벨트킷이 알아서 잘 처리해줘.
    *   **빌드 시간 증가 가능성:** 사전 렌더링할 게 많아지면 당연히 빌드 시간이 길어질 수 있어. "세상에 공짜는 없다."
    *   **데이터 의존성 파악:** 페이지가 특정 서버 라우트 데이터에 의존하고 그 페이지가 사전 렌더링 대상이면, 해당 서버 라우트도 같이 사전 렌더링될 가능성이 높아. 이 관계를 잘 이해하고 있어야 "왜 이것까지 빌드되고 있지?" 하는 삽질을 막을 수 있어.