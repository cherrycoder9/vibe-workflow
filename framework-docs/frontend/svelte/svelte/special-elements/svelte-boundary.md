`<svelte:boundary>`
`<svelte:boundary onerror={handler}>...</svelte:boundary>`
이 기능은 Svelte 5.3.0 버전에 추가됐습니다.

바운더리는 앱의 일부에서 발생한 오류가 앱 전체를 먹통으로 만드는 걸 막아주고, 그 오류로부터 회복할 수 있게 해줍니다.

`<svelte:boundary>`의 자식 요소들을 렌더링하거나 업데이트하는 도중, 또는 그 안에 포함된 `$effect` 함수를 실행하는 중에 오류가 발생하면, 해당 내용은 화면에서 사라집니다.

렌더링 과정 밖에서 발생하는 오류(예: 이벤트 핸들러, `setTimeout` 또는 비동기 작업 후)는 에러 바운더리가 잡아내지 못합니다.

**속성**
바운더리가 뭔가 하려면 `failed`나 `onerror` 둘 중 하나 또는 둘 다 있어야 합니다.

*   `failed`
    `failed` 스니펫이 제공되면, 발생한 오류와 내용을 다시 만드는 `reset` 함수와 함께 렌더링됩니다 (데모 참고):

    ```svelte
    <svelte:boundary>
    	<FlakyComponent />

    	{#snippet failed(error, reset)}
    		<button onclick={reset}>이런! 다시 시도</button>
    	{/snippet}
    </svelte:boundary>
    ```

    컴포넌트에 전달되는 스니펫처럼, `failed` 스니펫은 명시적으로 속성으로 전달될 수도 있고...

    ```svelte
    <svelte:boundary {failed}>...</svelte:boundary>
    ```

    ...위 예시처럼 바운더리 내부에 직접 선언하여 암시적으로 전달될 수도 있습니다.

*   `onerror`
    `onerror` 함수가 제공되면, 동일한 `error`와 `reset` 두 인자와 함께 호출됩니다. 이건 오류 추적 서비스로 오류를 기록하거나...

    ```svelte
    <svelte:boundary onerror={(e) => report(e)}>
    	...
    </svelte:boundary>
    ```

    ...바운더리 외부에서 `error`와 `reset`을 사용하는 데 유용합니다:

    ```svelte
    <script>
    	let error = $state(null);
    	let reset = $state(() => {});

    	function onerror(e, r) {
    		error = e;
    		reset = r;
    	}
    </script>

    <svelte:boundary {onerror}>
    	<FlakyComponent />
    </svelte:boundary>

    {#if error}
    	<button onclick={() => {
    		error = null;
    		reset();
    	}}>
    		이런! 다시 시도
    	</button>
    {/if}
    ```

    만약 `onerror` 함수 내부에서 오류가 발생하거나 (또는 오류를 다시 던지면), 상위 바운더리가 있다면 그놈이 처리합니다.

---

**얘 뭐 하는 애냐? (기능 및 목적)**
`<svelte:boundary>`는 Svelte 앱의 특정 구역에 "방화벽"을 치는 녀석입니다. 이 구역 안에서 뭔가 터져도 앱 전체가 "으앙 주금 ㅠㅠ" 하는 대참사를 막아줍니다. 마치 영화에서 폭탄 터지기 직전에 방폭문 닫아서 피해를 최소화하는 장면이랑 비슷하죠. 오류가 나면 해당 부분만 쏙 빼고, 사용자에게 "문제가 생겼는데 다시 해볼텨?" 하고 물어보거나, 개발자에게 "여기서 에러났어요!" 하고 알려주는 역할을 합니다.

**왜 쓰는데?**
1.  **앱 안정성 확보**: 특정 컴포넌트나 기능에서 오류가 나도 전체 앱이 하얗게 질리거나 멈추는 걸 방지합니다. "한 놈 때문에 다 죽을 순 없잖아?"
2.  **사용자 경험 개선**: 오류 발생 시 "죄송합니다. 다시 시도해주세요." 같은 친절한 안내와 함께 복구 옵션(예: `reset` 버튼)을 제공해서 사용자가 덜 당황하게 만듭니다. "고객님, 많이 놀라셨죠?"
3.  **오류 추적 및 로깅**: `onerror` 콜백으로 오류 정보를 외부 서비스(Sentry, LogRocket 등)에 보내서 뭐가 문제인지 파악하고 디버깅하는 데 써먹습니다. "범인은 이 안에 있어!"

**언제 불려 나오냐?**
*   외부 API 호출 결과가 불안정해서 렌더링 중에 에러가 터질 가능성이 있는 컴포넌트를 감쌀 때.
*   복잡한 로직을 가진 컴포넌트가 예기치 않게 뻗을까 봐 걱정될 때.
*   특정 기능(예: 댓글 목록, 실시간 차트)이 오류 나더라도 다른 핵심 기능은 멀쩡하게 돌아가야 할 때.
*   한마디로, "얘는 좀 불안한데... 얘가 터져도 다른 애들은 살아야 해!" 싶을 때 `<svelte:boundary>`로 감싸줍니다.

**쓸 때 꿀팁 및 주의사항:**
*   **`failed` 스니펫 vs `onerror` 함수**:
    *   `failed` 스니펫: 오류 발생 시 사용자에게 보여줄 UI (예: "다시 시도" 버튼)를 바운더리 안에 바로 정의할 때 편합니다. "UI는 여기서 바로 처리!"
    *   `onerror` 함수: 오류 로깅, 상태 업데이트 등 좀 더 복잡한 로직을 처리하거나, 오류 정보를 바운더리 밖으로 꺼내서 쓰고 싶을 때 씁니다. "데이터는 내가 따로 관리할게."
    *   둘 다 쓸 수도 있습니다. `onerror`로 로깅하고, `failed`로 UI 보여주고.
*   **`reset()` 함수는 마법의 지우개**: `failed` 스니펫이나 `onerror` 함수로 받는 `reset()` 함수를 호출하면, 바운더리 안의 자식 컴포넌트들을 다시 렌더링하려고 시도합니다. "Ctrl+Z 같은 느낌으로다가."
*   **모든 오류를 다 막아주진 못함**: 이벤트 핸들러(`on:click` 등), `setTimeout`, `setInterval`, 비동기 작업(`async/await`의 `await` 이후 부분)에서 터지는 오류는 못 잡습니다. 걔네는 렌더링 파이프라인이랑 다른 동네 애들이라 그렇습니다. 이런 오류는 전통적인 `try...catch`나 `.catch()`로 잡아야 합니다. "내 관할이 아니야."
*   **너무 남발하면 곤란**: 앱 전체를 `<svelte:boundary>`로 도배하는 건 좋은 생각이 아닙니다. 오류를 너무 숨기면 오히려 뭐가 문제인지 파악하기 어려워질 수 있습니다. 꼭 필요한 곳, "여긴 터질 수 있겠다" 싶은 곳에 전략적으로 사용하세요. "과유불급!"
*   **Svelte 5.3.0 이상 필수**: 이 기능은 Svelte 5.3.0부터 들어갔으니, 그 이하 버전에서는 "그런 거 없는데?" 하고 에러 납니다. 버전 확인 필수!