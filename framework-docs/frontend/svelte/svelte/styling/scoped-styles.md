**Scoped styles (범위 지정 스타일)**

Svelte 컴포넌트 안에는 해당 컴포넌트 전용 CSS를 담는 `<style>` 태그를 넣을 수 있습니다. 이 CSS는 기본적으로 **범위가 지정**되는데, 이게 무슨 말이냐면 스타일이 해당 컴포넌트 바깥의 다른 어떤 요소에도 영향을 주지 않는다는 뜻입니다. "내 구역은 내가 알아서 한다, 남의 집엔 신경 안 써!" 같은 거죠.

이건 영향을 받는 요소에 클래스를 추가하는 방식으로 작동하는데, 이 클래스는 컴포넌트 스타일의 해시값(예: `svelte-123xyz`)을 기반으로 만들어집니다.

```html
<style>
	p {
		/* 이 스타일은 이 컴포넌트 안의 <p> 태그에만 적용됨 */
		color: burlywood; /* 칙칙한 나무색... 센스 하고는. */
	}
</style>
```

**Specificity (명시도)**

범위가 지정된 각 선택자는 선택자에 범위 지정 클래스(예: `.svelte-123xyz`)가 추가되면서 명시도가 `0-1-0`만큼 증가합니다. 이게 뭘 의미하냐면, 예를 들어 컴포넌트 안에 정의된 `p` 선택자가 전역 스타일시트에 정의된 `p` 선택자보다 우선권을 갖게 된다는 겁니다. 설령 전역 스타일시트가 나중에 로드되더라도 말이죠. "내 집 안에서는 내 법이 먼저다!"

경우에 따라서는 범위 지정 클래스를 선택자에 여러 번 추가해야 할 수도 있는데, 첫 번째 이후로는 명시도를 더 이상 높이지 않기 위해 `:where(.svelte-xyz123)` 형태로 추가됩니다. "너무 세게 나가진 않을게, 적당히 하자."

**Scoped keyframes (범위 지정 키프레임)**

컴포넌트가 `@keyframes`를 정의하면, 그 이름도 동일한 해싱 방식을 사용해서 컴포넌트로 범위가 지정됩니다. 컴포넌트 안의 모든 애니메이션 규칙도 비슷하게 조정됩니다.

```html
<style>
	.bouncy {
		animation: bounce 10s; /* 10초 동안 튕기라고? 지루하겠다. */
	}

	/* 이 키프레임은 이 컴포넌트 안에서만 접근 가능 */
	@keyframes bounce {
		/* ... (애니메이션 내용) */
	}
</style>
```

---

**얘 뭐 하는 애냐? (기능 및 목적)**
Svelte의 Scoped Styles는 컴포넌트별로 CSS 스타일을 독립적으로 관리하게 해주는 기능입니다. 각 컴포넌트의 `<style>` 태그 안에 작성된 CSS는 마법처럼 해당 컴포넌트 내부 요소에만 적용되고, 다른 컴포넌트나 전역 스타일에 영향을 주지 않습니다. "CSS야, 너는 딱 이 안에서만 놀아라!" 하고 울타리를 쳐주는 거죠. 이렇게 하면 스타일 충돌 걱정 없이 컴포넌트를 레고 블록처럼 자유롭게 조립하고 재사용할 수 있습니다.

**왜 쓰는데?**
1.  **스타일 충돌 방지**: 여러 컴포넌트에서 같은 클래스 이름이나 태그 선택자를 써도 서로 엉키지 않습니다. "옆집이랑 똑같은 이름표 달았다고 싸울 일 없다!" 전역 CSS 지옥에서 해방되는 거죠.
2.  **모듈성 향상**: 컴포넌트가 자기 스타일을 스스로 책임지니까, 컴포넌트를 다른 프로젝트에 가져다 써도 스타일이 깨질 걱정이 줄어듭니다. "이삿짐 싸는데 인테리어까지 통째로 들고 가는 격."
3.  **유지보수 용이**: 특정 컴포넌트의 스타일을 수정하고 싶으면 해당 컴포넌트 파일만 보면 됩니다. 다른 곳에 영향을 줄까 봐 전전긍긍할 필요가 없죠. "내 코드는 내가 책임진다."
4.  **CSS 번들 크기 최적화 (간접적)**: 컴포넌트별로 필요한 스타일만 가지므로, 나중에 빌드 과정에서 사용되지 않는 스타일을 제거(tree-shaking)하기 용이해집니다. 물론 Svelte가 알아서 잘 해줍니다.

**언제 불려 나오냐?**
Svelte 컴포넌트(`.svelte` 파일) 안에 `<style>` 태그를 작성하면 자동으로 이 기능이 적용됩니다. 별도로 뭘 호출하거나 설정할 필요 없이 그냥 쓰면 됩니다. "Svelte 쓰면 기본으로 따라오는 편의 기능!"

**쓸 때 꿀팁 및 주의사항:**
*   **명시도 전쟁에서 우위 선점**: Scoped Style은 일반 전역 스타일보다 우선순위가 높습니다. (`.svelte-xxxxxx` 같은 클래스가 붙어서 명시도가 올라가기 때문). 그래서 전역으로 `p { color: blue; }` 해놔도, 컴포넌트에서 `p { color: red; }` 하면 빨간색이 됩니다. "내 컴포넌트에선 내가 왕이다!"
*   **전역 스타일 먹이고 싶을 땐 `:global()`**: 가끔은 컴포넌트 안에서 전역 스타일을 건드려야 할 때가 있습니다. 그럴 땐 `:global(선택자)` 문법을 사용하면 됩니다. 예를 들어 `<style> :global(body) { background-color: lightblue; } </style>` 이런 식이죠. "가끔은 월권도 필요하다." 하지만 남용은 금물!
*   **자식 컴포넌트 스타일은 못 건드림 (기본적으론)**: 부모 컴포넌트의 Scoped Style은 자식 컴포넌트 내부 요소에 직접 적용되지 않습니다. 자식 컴포넌트도 자기만의 울타리가 있으니까요. 자식에게 스타일을 전달하려면 props를 사용하거나 CSS 변수(custom properties)를 활용하는 게 정석입니다. "애들 옷은 애들한테 맞는 걸로."
*   **해시 클래스는 Svelte가 알아서**: `.svelte-123xyz` 같은 클래스 이름은 Svelte 컴파일러가 자동으로 생성하고 관리합니다. 우리가 직접 저 클래스 이름을 CSS에서 사용하거나 신경 쓸 필요는 없습니다. "Svelte 믿고 그냥 쓰면 된다."
*   **`@keyframes`도 스코프 적용**: 애니메이션 이름도 컴포넌트별로 고유하게 만들어줘서 이름 충돌 걱정 없이 쓸 수 있습니다. "내 애니메이션은 나만 쓸 수 있지!"