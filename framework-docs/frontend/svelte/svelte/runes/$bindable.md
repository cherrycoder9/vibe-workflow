`$bindable`
원래 프롭(props)은 부모에서 자식으로, 한 방향으로만 흘러갑니다. 그래야 앱 전체에서 데이터가 어떻게 돌아가는지 파악하기 쉽거든요.

Svelte에서는 컴포넌트 프롭을 '바인딩'할 수 있는데, 이건 데이터가 자식에서 부모로 역류할 수도 있다는 뜻입니다. 자주 쓸 기능은 아니지만, 아껴 쓰고 조심해서 쓰면 코드가 더 간결해질 수 있습니다.

또한, 자식 컴포넌트에서 상태 프록시(state proxy)를 직접 수정할 수도 있게 됩니다.

일반 프롭도 수정 자체는 가능하지만, 강력하게 비추합니다. Svelte는 컴포넌트가 '자기 소유가 아닌' 상태를 수정하려고 하면 경고를 날릴 겁니다. "네 것도 아닌데 왜 건드려!" 하는 거죠.

프롭을 바인딩 가능하게 만들려면 `$bindable` 룬(rune)을 씁니다:

**FancyInput.svelte (자식 컴포넌트)**
```svelte
<script lang="ts">
	let { value = $bindable(), ...props } = $props();
</script>

<input bind:value={value} {...props} />

<style>
	input {
		font-family: 'Comic Sans MS'; /* 폰트는 못 참지! */
		color: deeppink;
	}
</style>
```

이제 `<FancyInput>`을 사용하는 부모 컴포넌트는 `bind:` 디렉티브를 쓸 수 있습니다 (데모 참고):

**App.svelte (부모 컴포넌트)**
```svelte
<script lang="ts">
	import FancyInput from './FancyInput.svelte';

	let message = $state('hello');
</script>

<FancyInput bind:value={message} />
<p>{message}</p>
```

부모 컴포넌트가 꼭 `bind:`를 써야 하는 건 아닙니다. 그냥 일반 프롭으로 값을 전달할 수도 있죠. 어떤 부모는 자식 말 듣기 싫어하니까요. "내 말만 들어!"

이 경우, 프롭이 아예 전달되지 않았을 때를 위한 기본값을 지정할 수 있습니다:

**FancyInput.svelte (자식 컴포넌트 - 기본값 추가)**
```svelte
let { value = $bindable('fallback'), ...props } = $props();
```

---

**얘 뭐 하는 애냐? (기능 및 목적)**
`$bindable`은 Svelte 5 (룬 도입 이후)에서 자식 컴포넌트의 프롭이 부모 컴포넌트의 상태와 양방향으로 묶일 수 있게 해주는 마법의 주문입니다. 원래 데이터는 위(부모)에서 아래(자식)로 흐르는 게 국룰인데, `$bindable`을 쓰면 자식이 "아빠, 나 용돈 다 썼어요. 다시 채워줘요!" 하고 부모 지갑(상태)에 직접 손을 댈 수 있게 됩니다. 좀 더 정확히는, 자식 쪽에서 변경된 값이 부모 쪽 상태에도 바로 반영되게 하는 거죠. "이제 자식도 목소리를 낸다!"

**왜 쓰는데?**
1.  **폼(Form) 요소 간편화**: `<input>` 같은 폼 요소 값을 부모 상태와 쉽게 동기화할 때 씁니다. 예전 `bind:value`를 룬 방식으로 구현한 거죠. 자식 인풋에 글자 쓰면 부모 상태가 실시간으로 바뀌는 마법!
2.  **양방향 데이터 흐름 필요시**: 아주 가끔, 정말 가끔 자식의 상태 변화를 부모가 즉시 알아야 하고, 그 값을 부모도 수정할 수 있어야 할 때 씁니다. "데이터 핑퐁!"
3.  **코드 간결화 (잘 쓰면)**: 복잡한 이벤트 핸들러와 콜백 함수 없이도 양방향 바인딩을 깔끔하게 처리할 수 있습니다. "이벤트 지옥 탈출 넘버원!"

**언제 불려 나오냐?**
자식 컴포넌트의 프롭 정의할 때, `$props()` 구조 분해 할당 안에서 특정 프롭에 `$bindable()`을 붙여서 사용합니다. 부모에서는 해당 프롭에 `bind:프롭이름={상태}` 형태로 연결하고요.

**쓸 때 꿀팁 및 주의사항:**
*   **남용은 금물, 독이 될 수 있음**: 양방향 바인딩은 데이터 흐름을 복잡하게 만들어서 디버깅을 어렵게 할 수 있습니다. "이 값 대체 어디서 바뀐 거야?!" 소리 나오기 쉽죠. 정말 필요할 때만, 신중하게 사용해야 합니다. "아껴 쓰자, `$bindable`!"
*   **단방향이 기본, 양방향은 옵션**: Svelte의 기본 철학은 단방향 데이터 흐름입니다. 이게 예측 가능하고 관리하기 쉽기 때문이죠. `$bindable`은 이 원칙을 깨는 예외적인 경우에만 쓰는 게 좋습니다.
*   **기본값 설정 가능**: `$bindable('기본값')`처럼 기본값을 줄 수 있습니다. 부모에서 `bind:`로 연결 안 하거나 아예 프롭을 안 넘겼을 때 이 값이 쓰입니다. "혹시나 해서 준비했어."
*   **소유권 명확히**: `$bindable`을 쓰면 자식이 부모 상태를 건드릴 수 있게 되므로, 데이터의 '소유권'이 누구에게 있는지 헷갈릴 수 있습니다. 설계 단계부터 데이터 흐름을 명확히 하는 게 중요합니다. "이 데이터 주인 누구냐, 나와!"
*   **Svelte 5 룬 기능**: 이건 Svelte 5부터 도입된 룬(Rune) 시스템의 일부입니다. 이전 버전 Svelte에서는 다른 방식으로 양방향 바인딩을 처리했으니 (주로 `bind:value` 문법), 버전 확인은 필수! "옛날 방식이랑 헷갈리면 곤란해."