`$derived`는 Svelte 5에 도입된 "룬(rune)"이라는 특별한 문법으로, 다른 상태값으로부터 파생되는 값을 선언할 때 씁니다.

```svelte
<script>
  // count라는 상태값을 0으로 초기화 (이건 $state 룬)
  let count = $state(0);
  // count가 바뀔 때마다 알아서 count * 2 로 계산되는 doubled 값
  let doubled = $derived(count * 2);
</script>

<button onclick={() => count++}>
  {doubled} <!-- 버튼 누르면 count 올라가고, doubled도 자동으로 바뀜 -->
</button>

<p>{count} doubled is {doubled}</p>
```

`$derived(...)` 안의 표현식은 부수 효과(side-effect)가 없어야 합니다. 즉, `$derived` 안에서 `count++`처럼 상태를 직접 바꾸는 짓은 Svelte가 막아버립니다. "계산만 해, 딴짓하지 말고!"

`$state`처럼 클래스 필드에도 `$derived`를 붙여서 쓸 수 있습니다.

Svelte 컴포넌트 안의 코드는 기본적으로 맨 처음에 딱 한 번 실행됩니다. 만약 `$derived` 룬이 없다면, `doubled` 값은 `count`가 바뀌어도 처음 계산된 값을 그대로 유지할 겁니다. "한 번 정한 값은 영원하다!" (물론 `$derived`가 있으면 아님)

**`$derived.by`**

가끔은 한 줄짜리 표현식으로 담기 어려운 복잡한 파생값을 만들어야 할 때가 있습니다. 그럴 땐 함수를 인자로 받는 `$derived.by`를 쓰면 됩니다.

```svelte
<script>
  let numbers = $state([1, 2, 3]); // 숫자 배열 상태
  // numbers 배열의 모든 요소를 더한 값을 계산하는 total
  let total = $derived.by(() => {
    let sum = 0;
    for (const n of numbers) {
      sum += n;
    }
    return sum;
  });
</script>

<button onclick={() => numbers.push(numbers.length + 1)}>
  {numbers.join(' + ')} = {total} <!-- 버튼 누르면 배열에 숫자 추가되고, total도 알아서 업데이트 -->
</button>
```

사실 `$derived(표현식)`은 `$derived.by(() => 표현식)`과 똑같은 놈입니다. 그냥 짧게 쓰려고 만들어준 거죠.

**의존성 이해하기**

`$derived` 표현식이나 `$derived.by` 함수 본문 안에서 동기적으로 읽히는 모든 것은 해당 파생 상태의 "의존성"으로 간주됩니다. 이 의존성 중 하나라도 바뀌면, 파생값은 "더티(dirty)" 상태가 되고, 다음에 그 값을 읽으려고 할 때 재계산됩니다. "네가 바뀌면 나도 바뀐다!"

만약 어떤 상태값을 의존성에서 빼고 싶다면 `untrack`이라는 걸 쓰면 됩니다. (여기선 자세히 안 다룸)

**파생값 덮어쓰기**

파생 표현식은 의존성이 바뀔 때 재계산되지만, `const`로 선언하지 않았다면 값을 직접 재할당해서 임시로 덮어쓸 수 있습니다. 이건 "낙관적 UI (optimistic UI)" 같은 거 만들 때 유용합니다. 서버에서 오는 진짜 데이터(`post.likes`)로부터 파생된 값(`likes`)이 있지만, 사용자에게 즉각적인 피드백을 보여주고 싶을 때 쓰는 거죠.

```svelte
<script>
  // props로 post 객체와 like 함수를 받는다고 가정
  let { post, like } = $props();

  // post.likes로부터 likes 파생값을 만듦
  let likes = $derived(post.likes);

  async function onclick() {
    // 일단 likes 값을 바로 1 증가시킴 (사용자 눈에는 바로 반영)
    likes += 1;

    // 그리고 서버에 진짜로 "좋아요" 요청을 보냄 (이게 성공하면 post.likes가 바뀔 것)
    try {
      await like();
    } catch {
      // 서버 요청 실패! 원래대로 되돌림
      likes -= 1;
    }
  }
</script>

<button {onclick}>🧡 {likes}</button>
```

Svelte 5.25 버전 이전에는 `$derived`로 만들어진 값은 읽기 전용이었습니다. "감히 네가 날 바꿔?" 하던 시절이 있었죠.

**`$derived`와 반응성**

`$state`는 객체나 배열을 깊은 반응형 프록시(deeply reactive proxy)로 만드는 반면, `$derived` 값은 있는 그대로 둡니다. 예를 들어 이런 경우...

```svelte
let items = $state([...]); // items는 깊은 반응형 배열
let index = $state(0);
let selected = $derived(items[index]); // selected는 items의 특정 요소
```

...`selected`의 속성을 바꾸거나 `bind:`로 연결하면, 원본 `items` 배열에도 영향을 줍니다. 만약 `items`가 깊은 반응형이 아니었다면, `selected`를 아무리 바꿔봤자 `items`에는 아무 일도 일어나지 않을 겁니다. "넌 내 분신일 뿐!"

**업데이트 전파 방식**

Svelte는 "푸시-풀 반응성(push-pull reactivity)"이라는 방식을 씁니다. 상태가 업데이트되면, 그 상태에 직간접적으로 의존하는 모든 것들에게 "나 바뀌었어!" 하고 즉시 알립니다 (이게 '푸시'). 하지만 파생값들은 실제로 그 값을 읽으려고 할 때까지 재계산되지 않습니다 (이게 '풀'). "필요할 때만 일한다!"

만약 파생값의 새 값이 이전 값과 참조적으로 동일하다면 (즉, 가리키는 메모리 주소가 같다면), 그 아래로 이어지는 업데이트는 건너뜁니다. 다시 말해, 아래 예제에서 `large`는 `count`에 의존하지만, `count`가 바뀔 때마다 버튼 안의 텍스트가 항상 업데이트되는 건 아닙니다. `large`의 실제 값 (`true` 또는 `false`)이 바뀔 때만 업데이트됩니다.

```svelte
<script>
  let count = $state(0);
  // count가 10보다 클 때만 true가 되는 large
  let large = $derived(count > 10);
</script>

<button onclick={() => count++}>
  {large} <!-- count가 0~10일 때는 false, 11부터 true. 이 boolean 값이 바뀔 때만 버튼 텍스트가 다시 렌더링됨 -->
</button>
```

---

**얘 뭐 하는 애냐? (기능 및 목적)**
`$derived`는 Svelte 5에서 "계산된 속성" 혹은 "파생된 상태"를 만드는 녀석입니다. 이미 존재하는 다른 상태(`$state`로 만들어진 값 등)를 가지고 새로운 값을 만들어내는데, 원본 상태가 바뀌면 이 파생된 값도 알아서 척척 업데이트됩니다. 엑셀 시트에서 특정 셀 값이 바뀌면 다른 셀의 수식 결과도 자동으로 바뀌는 거랑 비슷하다고 보면 됩니다. "네가 변하면 나도 변해!"

**왜 쓰는데?**
1.  **코드 간결성**: 복잡한 로직으로 계산되는 값을 매번 직접 계산하거나, 상태 변경될 때마다 수동으로 업데이트하는 코드를 줄여줍니다. "보일러플레이트 코드 꺼져!"
2.  **자동 업데이트**: 의존하는 상태가 바뀌면 알아서 재계산되니, 개발자가 깜빡하고 업데이트 안 해서 생기는 버그를 막아줍니다. "Svelte가 다 알아서 해준다니깐!"
3.  **성능 최적화 (일부)**: Svelte의 "푸시-풀" 반응성 덕분에, 파생값이 실제로 필요할 때만 계산됩니다. 그리고 파생된 값 자체가 변하지 않으면 그 값을 사용하는 UI 부분은 업데이트되지 않으니 불필요한 렌더링을 줄일 수 있습니다. "낭비는 금물!"

**언제 불려 나오냐?**
Svelte 컴포넌트의 `<script>` 태그 안에서, 다른 상태값에 기반해서 동적으로 변해야 하는 값을 정의할 때 씁니다. 예를 들어, 사용자 입력값(`firstName`, `lastName`)을 합쳐서 전체 이름(`fullName`)을 보여줘야 할 때, 장바구니 아이템 목록(`cartItems`)으로부터 총액(`totalPrice`)을 계산해야 할 때 등등 "A가 바뀌면 B도 바뀌어야 해!" 하는 상황이면 어김없이 등장합니다.

**쓸 때 꿀팁 및 주의사항:**
*   **순수 함수처럼**: `$derived(...)` 안의 표현식이나 `$derived.by(...)`의 함수는 부수 효과(side effects)가 없어야 합니다. 즉, 이 안에서 다른 상태를 직접 변경하거나 외부 API를 호출하는 등의 "딴짓"을 하면 안 됩니다. 오직 계산만! "계산기는 계산만 하라고!"
*   **의존성 자동 감지**: `$derived`는 똑똑해서 표현식 안에서 어떤 상태를 읽는지 자동으로 파악하고, 그 상태들이 바뀔 때만 재계산합니다. 개발자가 수동으로 "얘랑 쟤가 바뀌면 나도 업데이트해줘"라고 지정할 필요가 없습니다.
*   **복잡하면 `$derived.by`**: 간단한 한 줄짜리 계산은 `$derived(표현식)`으로 충분하지만, 여러 줄의 로직이나 루프가 필요하면 `$derived.by(() => { ... })`를 쓰세요. 가독성이 훨씬 좋아집니다.
*   **덮어쓰기는 신중하게 (낙관적 UI용)**: `$derived`로 만들어진 값을 직접 수정하는 건 주로 사용자 경험을 즉각적으로 좋게 만들기 위한 "낙관적 업데이트" 시나리오에서 제한적으로 사용됩니다. 서버 응답이 실패하면 원래대로 되돌리는 로직(롤백)을 반드시 함께 구현해야 합니다. "섣부른 낙관은 버그를 부른다!"
*   **`$state`와 `$derived`의 반응성 차이**: `$state`는 객체나 배열을 만들면 그 내부까지 싹 다 반응형으로 만들지만, `$derived`는 그렇게까지 하지는 않습니다. `$derived`로 얻은 객체나 배열의 내부 값을 직접 수정하면, 그게 원본 `$state` 객체/배열의 일부였다면 원본도 같이 바뀔 수 있다는 점을 기억하세요. "뿌리가 같으면 운명도 같다!"
*   **`const`로 선언하면 덮어쓰기 불가**: `$derived` 값을 `let` 대신 `const`로 선언하면, 위에서 말한 "덮어쓰기" 기능이 막힙니다. 정말로 읽기 전용으로만 쓰고 싶다면 `const`를 쓰세요.