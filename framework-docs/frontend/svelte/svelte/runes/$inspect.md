`$inspect`는 개발 중에만 작동하는 녀석입니다. 프로덕션 빌드에서는 아무것도 안 하는 빈 껍데기가 되죠. "실전에서는 조용히 사라져주는 센스!"

`$inspect` 룬(Svelte 5의 반응성 시스템 단위)은 `console.log`랑 비슷하지만, 인자로 전달된 값이 바뀔 때마다 다시 실행된다는 차이가 있습니다. 이놈은 반응형 상태를 아주 깊숙이 추적해서, 객체나 배열 내부의 작은 변화까지 감지하고 다시 실행됩니다. (데모를 보면 이해가 빠를 겁니다)

```svelte
<script>
	let count = $state(0); // count라는 반응형 상태, 초기값 0
	let message = $state('hello'); // message라는 반응형 상태, 초기값 'hello'

	// count나 message가 바뀔 때마다 콘솔에 로그를 찍음
	$inspect(count, message);
</script>

<button onclick={() => count++}>숫자 증가</button>
<input bind:value={message} />
```

**`$inspect(...).with`**

`$inspect`는 `with`라는 속성을 반환하는데, 여기에 콜백 함수를 넘겨주면 `console.log` 대신 그 콜백 함수가 실행됩니다. 콜백 함수의 첫 번째 인자는 "init"(초기 실행) 또는 "update"(업데이트 시 실행)이고, 그 뒤로는 `$inspect`에 전달했던 값들이 따라옵니다. (이것도 데모를 보세요)

```svelte
<script>
	let count = $state(0);

	$inspect(count).with((type, count) => {
		if (type === 'update') {
			debugger; // 또는 console.trace 등 원하는 디버깅 코드를 넣을 수 있음
		}
	});
</script>

<button onclick={() => count++}>숫자 증가</button>
```

어떤 변경이 어디서 시작됐는지 찾는 편리한 방법은 `console.trace`를 `with`에 넘기는 겁니다:

```javascript
$inspect(stuff).with(console.trace); // "어이, 이 값 바꾼 놈 누구냐? 자수해!"
```

**`$inspect.trace(...)`**

이 룬은 (Svelte 5.14 버전에 추가됨) 개발 중에 자신을 감싸고 있는 함수를 추적하게 만듭니다. 이 함수가 어떤 이펙트(effect)나 파생(derived) 상태의 일부로 다시 실행될 때마다, 어떤 반응형 상태 때문에 실행됐는지에 대한 정보가 콘솔에 찍힙니다. "CSI: Svelte 반응성 추적반"

```svelte
<script>
	import { doSomeWork } from './elsewhere';

	$effect(() => {
		// $inspect.trace는 함수 본문의 첫 번째 문장이어야 함. "나부터 조사해!"
		$inspect.trace();
		doSomeWork();
	});
</script>
```

`$inspect.trace`는 선택적으로 첫 번째 인자로 라벨을 받을 수 있습니다. 이 라벨은 콘솔 출력에 사용됩니다.

---

**얘 뭐 하는 애냐? (기능 및 목적)**
`$inspect`는 Svelte 5에서 반응형 상태(state)가 어떻게 변하는지 실시간으로 까보고 싶을 때 쓰는 디버깅용 돋보기입니다. `console.log`랑 비슷한데, 값이 바뀔 때마다 알아서 다시 찍어주니 "새로고침 그만! F5 뽑힐라"를 외칠 필요가 없죠. 특히 복잡한 객체나 배열 내부의 변화까지 귀신같이 잡아냅니다. `with`를 쓰면 단순 로그 말고도 원하는 디버깅 로직(예: `debugger;`)을 끼워 넣을 수 있고, `$inspect.trace`는 함수가 왜 다시 실행되는지 그 원인을 추적해주는 탐정 역할을 합니다.

**왜 쓰는데?**
1.  **반응성 디버깅 끝판왕**: "이 값 왜 안 바뀌지?", "이건 또 언제 바뀐 거야?" 같은 의문이 들 때, `$inspect`를 걸어두면 변화의 순간을 포착해서 알려줍니다.
2.  **코드 흐름 파악**: `$inspect.trace`를 쓰면 특정 함수가 어떤 반응형 상태 때문에 재실행되는지 그 호출 스택과 원인을 보여줘서, 복잡한 반응성 로직을 이해하는 데 도움을 줍니다. "네 죄를 네가 알렸다!"
3.  **커스텀 디버깅 액션**: `.with()`를 사용하면 단순히 콘솔에 찍는 것 이상으로, 특정 조건에서 `debugger`를 실행하거나, 특정 값을 다른 곳으로 보내는 등의 맞춤형 디버깅이 가능합니다.

**언제 불려 나오냐?**
Svelte 5 컴포넌트의 `<script>` 태그 안에서, 반응형 상태(`$state`로 선언된 변수 등)의 변화를 추적하고 싶을 때, 또는 `$effect` 등으로 만들어진 함수가 왜 자꾸 실행되는지 궁금할 때 호출합니다. 개발 중에만 쓰고, 프로덕션 빌드에서는 자동으로 제거되니 안심하고 팍팍 쓰세요.

**쓸 때 꿀팁 및 주의사항:**
*   **개발 전용, 실전 투입 금지**: `$inspect`는 개발 편의를 위한 도구입니다. 프로덕션 코드에 남아있으면 성능에 영향을 줄 수...는 없지만 (자동으로 제거되니까), 그래도 개발용이라는 걸 명심하세요.
*   **`$inspect.trace()`는 함수 맨 앞에**: 이놈은 함수 몸체의 가장 첫 줄에 위치해야 제대로 작동합니다. "내가 이 구역의 감시자다!" 선언하는 거죠.
*   **깊은 복사 vs 얕은 복사 주의**: 객체나 배열을 추적할 때, 내부 값만 바뀌어도 `$inspect`는 반응합니다. 이게 장점이자 단점인데, 너무 큰 객체를 통째로 넣으면 콘솔이 난리날 수 있으니 필요한 부분만 찍어보는 게 좋습니다.
*   **`.with(console.trace)`는 마법의 주문**: "이 값 대체 어디서 바뀐 거야?!" 싶을 때 `console.trace`를 넘기면 변경을 일으킨 코드의 호출 스택을 보여줘서 범인 검거에 매우 유용합니다.
*   **너무 많이 쓰면 콘솔 폭탄**: 편리하다고 여기저기 `$inspect`를 심어두면, 작은 변화 하나에도 콘솔 로그가 수십 줄씩 찍히는 대참사가 벌어질 수 있습니다. "과유불급! 필요한 곳에만 콕콕."
*   **Svelte 5 전용**: 이건 Svelte 5의 룬 시스템과 함께 등장한 기능입니다. 구버전 Svelte에서는 못 써요.