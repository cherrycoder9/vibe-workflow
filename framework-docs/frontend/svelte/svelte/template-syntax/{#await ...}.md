`{#await ...}` 블록은 Promise의 세 가지 상태(대기 중, 성공, 실패)에 따라 다른 내용을 보여줄 수 있게 해주는 Svelte의 마법입니다.

**기본 구조**

```svelte
{#await 어떤_Promise_표현식}
	<!-- Promise가 대기 중일 때 (로딩 중...) -->
	<p>Promise가 처리되길 기다리는 중...</p>
{:then 성공했을때_받을_변수명}
	<!-- Promise가 성공했거나, 애초에 Promise가 아니었을 때 -->
	<p>결과값은 {성공했을때_받을_변수명} 입니다.</p>
{:catch 실패했을때_받을_에러_변수명}
	<!-- Promise가 실패했을 때 -->
	<p>문제가 발생했습니다: {실패했을때_받을_에러_변수명.message}</p>
{/await}
```

서버 사이드 렌더링(SSR) 중에는 오직 대기 중(`pending`) 상태의 내용만 렌더링됩니다. "서버는 일단 로딩 중 화면만 던져주고, 나머진 브라우저 니가 알아서 해!" 이런 느낌이죠.

만약 `{#await ...}`에 전달된 표현식이 Promise가 아니라면, 서버 사이드 렌더링을 포함해서 항상 `:then` 블록의 내용만 렌더링됩니다. "Promise 아니면 성공이지 뭐."

Promise가 실패했을 때 아무것도 보여줄 필요가 없거나 에러 발생 가능성이 없다면 `:catch` 블록은 생략해도 됩니다.

```svelte
{#await 어떤_Promise}
	<!-- Promise가 대기 중일 때 -->
	<p>Promise가 처리되길 기다리는 중...</p>
{:then 성공값}
	<!-- Promise가 성공했을 때 -->
	<p>결과값은 {성공값} 입니다.</p>
{/await}
```

만약 대기 중 상태를 신경 쓰지 않는다면, 초기 블록(pending 상태)도 생략 가능합니다.

```svelte
{#await 어떤_Promise then 성공값}
	<p>결과값은 {성공값} 입니다.</p>
{/await}
```

비슷하게, 에러 상태만 보여주고 싶다면 `:then` 블록을 생략할 수 있습니다.

```svelte
{#await 어떤_Promise catch 에러값}
	<p>에러 내용은 {에러값} 입니다.</p>
{/await}
```

`#await`를 `import(...)`와 함께 사용하면 컴포넌트를 지연 로딩(필요할 때만 불러오기)할 수 있습니다.

```svelte
{#await import('./내_컴포넌트.svelte') then { default: 내컴포넌트 }}
	<내컴포넌트 />
{/await}
```

---

**얘 뭐 하는 애냐? (기능 및 목적)**
`{#await ...}` 블록은 비동기 작업(주로 API 호출 같은 거)의 결과를 화면에 표시할 때 쓰는 Svelte의 템플릿 문법입니다. 데이터 로딩 중일 땐 "로딩 중..." 메시지를, 성공하면 데이터를, 실패하면 에러 메시지를 보여주는 식으로 사용자 경험(UX)을 매끄럽게 만들어줍니다. "기다리는 동안 지루하지 않게, 결과는 확실하게!" 이게 이 녀석의 모토입니다.

**왜 쓰는데?**
1.  **비동기 처리 상태 시각화**: 로딩, 성공, 실패 각 상황에 맞는 UI를 깔끔하게 분리해서 보여줄 수 있습니다. 자바스크립트에서 `if (loading) ... else if (error) ... else ...` 같은 복잡한 조건 분기를 HTML스럽게 처리하는 거죠. "코드가 예뻐진다!"
2.  **사용자 경험 향상**: 데이터 받아오는 동안 멍하니 흰 화면만 보여주는 것보다 로딩 스피너라도 돌려주면 사용자가 덜 답답해합니다. 에러 났을 때도 "뭔가 잘못됐어요 ㅠㅠ" 하고 알려주는 게 친절하죠.
3.  **코드 가독성 증가**: 비동기 로직이 템플릿 안에 명확하게 드러나서 "아, 이 부분은 데이터 받아와서 뿌려주는구나" 하고 이해하기 쉬워집니다.
4.  **컴포넌트 지연 로딩**: 당장 필요 없는 무거운 컴포넌트는 `import('./MyHeavyComponent.svelte')` 와 함께 써서 실제 화면에 보여줄 시점에 로딩하게 만들 수 있습니다. 초기 로딩 속도 개선에 아주 효과적이죠. "일단 가볍게 시작하고, 필요하면 그때그때 가져와!"

**언제 불려 나오냐?**
*   페이지 로드 시 외부 API에서 데이터를 가져와야 할 때.
*   사용자 액션(버튼 클릭 등)에 따라 비동기 데이터를 불러와야 할 때.
*   큰 이미지나 무거운 컴포넌트를 "나중에" 로딩하고 싶을 때.
*   한마디로, "언제 끝날지 모르는 작업 기다렸다가 결과에 따라 뭔가 보여줘야 할 때" 등판합니다.

**쓸 때 꿀팁 및 주의사항:**
*   **SSR의 한계**: 서버에서는 `:pending` 블록만 렌더링됩니다. 즉, 서버에서 데이터를 다 받아와서 `:then` 블록까지 완성된 HTML을 내려주진 않습니다 (SvelteKit의 `load` 함수를 쓰면 다르게 동작 가능하지만, 순수 `#await` 블록은 그렇습니다). "SSR은 맛보기만, 진짜는 브라우저에서!"
*   **Promise 아니면 무조건 `:then`**: `#await`에 넘긴 값이 Promise가 아니면 (예: 그냥 일반 객체나 숫자) 무조건 성공으로 간주하고 `:then` 블록을 실행합니다. 실수로 Promise 아닌 값을 넘기지 않도록 주의!
*   **에러 처리 꼼꼼하게**: `:catch` 블록에서 에러 메시지를 사용자에게 친절하게 보여주는 게 좋습니다. `error.message` 외에도 다른 유용한 정보가 있을 수 있으니 `console.log(error)`로 찍어보는 것도 방법. "에러 났다고 그냥 뻗어버리면 사용자 빡친다."
*   **블록 생략은 신중히**:
    *   `:pending` 생략 (`{#await promise then value}`): 로딩 상태를 아예 안 보여줘도 괜찮을 때만. 데이터가 빨리 올 거라 확신하거나, 다른 곳에 이미 로딩 표시가 있을 때.
    *   `:catch` 생략: 에러가 절대 안 날 거라고 확신하거나 (과연 그럴까?), 에러 나도 사용자에게 알릴 필요 없을 때. 보통은 넣어주는 게 안전빵.
    *   `:then` 생략 (`{#await promise catch error}`): 성공 데이터는 필요 없고, 오직 에러 상황만 처리하고 싶을 때. (흔한 케이스는 아님)
*   **지연 로딩 시 `default`**: `import('./Component.svelte')`의 결과는 `{ default: Component }` 형태의 모듈 객체입니다. 그래서 `:then { default: Component }` 처럼 구조 분해 할당으로 실제 컴포넌트를 꺼내 써야 합니다. "Svelte 컴포넌트 가져올 땐 `default`를 기억해!"
*   **너무 많은 `#await`는 혼란**: 한 컴포넌트 안에 `#await` 블록이 너무 중첩되거나 많아지면 가독성이 떨어질 수 있습니다. 적절히 컴포넌트로 분리하거나 스토어(store)를 활용하는 걸 고려해보세요.