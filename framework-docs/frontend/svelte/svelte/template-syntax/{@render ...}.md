`{@render ...}` 태그는 미리 정의된 코드 조각(스니펫)을 화면에 그려주는 역할을 합니다. "복붙 노가다 방지용 마법 주문"이라고 생각하면 쉽습니다.

**예시**

```svelte
{#snippet sum(a, b)}
	<p>{a} + {b} = {a + b}</p>
{/snippet}

{@render sum(1, 2)}
{@render sum(3, 4)}
{@render sum(5, 6)}
```

위 코드에서 `{#snippet sum(a, b)} ... {/snippet}` 부분은 `sum`이라는 이름의 스니펫을 정의한 겁니다. `a`와 `b`라는 두 개의 숫자를 받아서 덧셈 결과를 `<p>` 태그로 보여주죠.

그리고 `{@render sum(1, 2)}`는 이렇게 정의된 `sum` 스니펫을 실제로 호출해서 화면에 내용을 찍어내는 부분입니다. 마치 함수 호출하듯이 인자를 넘겨줄 수 있죠. 결과적으로 화면에는 "1 + 2 = 3", "3 + 4 = 7", "5 + 6 = 11" 이렇게 세 줄이 찍히게 됩니다.

스니펫 이름(`sum`)을 직접 쓸 수도 있고, 자바스크립트 표현식을 사용해서 동적으로 어떤 스니펫을 렌더링할지 결정할 수도 있습니다.

```svelte
{@render (cool ? coolSnippet : lameSnippet)()}
```

이건 `cool`이라는 변수가 참이면 `coolSnippet`을, 거짓이면 `lameSnippet`을 렌더링하라는 뜻입니다. "상황 봐서 알아서 골라 그려!"

**선택적 스니펫 (Optional snippets)**

만약 스니펫이 정의되지 않았을 수도 있는 상황이라면 (예: 부모 컴포넌트에서 props로 넘어오는데 안 넘어올 수도 있을 때), 옵셔널 체이닝(`?.`)을 써서 스니펫이 존재할 때만 렌더링하도록 할 수 있습니다.

```svelte
{@render children?.()}
```

`children` 스니펫이 있으면 그리고, 없으면 그냥 무시합니다. "있으면 쓰고, 없으면 말고."

아니면 `{#if ...}` 블록과 `:else`를 사용해서 스니펫이 없을 경우 대체 콘텐츠를 보여줄 수도 있습니다.

```svelte
{#if children}
	{@render children()}
{:else}
	<p>대체 콘텐츠</p>
{/if}
```

`children` 스니펫이 있으면 그걸 그리고, 없으면 `<p>대체 콘텐츠</p>`를 보여줍니다. "플랜 B는 항상 준비되어 있지."

---

**얘 뭐 하는 애냐? (기능 및 목적)**
`{@render ...}` 태그는 Svelte에서 재사용 가능한 UI 조각, 즉 스니펫을 정의하고 화면에 표시할 때 사용합니다. 특정 로직과 마크업을 묶어서 "부품"처럼 만들어두고, 필요할 때마다 `{@render}`로 가져다 쓰는 거죠. 코드 중복을 줄이고, 컴포넌트를 더 깔끔하게 관리할 수 있게 해줍니다. "레고 블록 조립하듯 UI 만들기"라고 보면 됩니다.

**왜 쓰는데?**
1.  **코드 재사용성 극대화**: 똑같은 UI 패턴이나 로직을 여러 곳에서 복붙할 필요 없이, 스니펫 하나 만들어두고 `{@render}`로 돌려쓰면 됩니다. "Ctrl+C, Ctrl+V는 이제 그만!"
2.  **가독성 및 유지보수 향상**: 복잡한 컴포넌트를 여러 개의 작은 스니펫으로 나누면 코드가 훨씬 읽기 쉬워지고, 수정하기도 편해집니다. "잘게 쪼개면 다루기 쉽다."
3.  **유연한 콘텐츠 주입 (슬롯과 비슷하지만 다름)**: 부모 컴포넌트에서 자식 컴포넌트의 특정 영역에 내용을 채워 넣는 슬롯(slot)과 비슷한 역할을 하지만, 스니펫은 좀 더 동적으로, 프로그래매틱하게 제어할 수 있는 여지를 줍니다. 특히 스니펫 자체를 props로 넘겨서 렌더링할 내용을 완전히 커스터마이징할 때 유용합니다.

**언제 불려 나오냐?**
*   컴포넌트 내에서 반복적으로 사용되는 UI 조각이 있을 때.
*   테이블의 행(row) 템플릿, 리스트의 아이템 템플릿처럼 데이터에 따라 조금씩 다른 내용을 반복해서 그려야 할 때.
*   부모 컴포넌트가 자식 컴포넌트의 특정 부분 렌더링 방식을 직접 정의해서 넘겨주고 싶을 때 (스니펫을 props로 전달).

**쓸 때 꿀팁 및 주의사항:**
*   **스니펫 정의는 `{#snippet ...}`**: 스니펫을 사용하려면 먼저 `{#snippet 이름(인자)} ... {/snippet}` 블록으로 정의해야 합니다. 이름 안 지어주면 못 불러요.
*   **인자 전달은 함수처럼**: `{@render 스니펫이름(값1, 값2)}` 형태로 스니펫에 필요한 데이터를 전달할 수 있습니다. 스니펫 내부에서는 이 인자들을 변수처럼 사용 가능합니다.
*   **옵셔널 체이닝(`?.`) 적극 활용**: 스니펫이 props로 넘어오거나 동적으로 결정될 때는 `{@render 스니펫이름?.()}`처럼 옵셔널 체이닝을 써서 스니펫이 없을 때 에러 나는 걸 방지하세요. "안전제일!"
*   **`{#if}` 블록으로 대체 콘텐츠**: 스니펫이 없을 때 뭔가 다른 걸 보여주고 싶다면 `{#if 스니펫이름} {@render 스니펫이름()} {:else} <p>없어요</p> {/if}` 구조를 활용하세요.
*   **슬롯(Slot)과의 차이점 인지**: 슬롯은 주로 정적인 콘텐츠를 끼워 넣는 데 사용되고, 스코프도 다릅니다. 스니펫은 자바스크립트 함수처럼 동작하며, 인자를 받아 동적으로 내용을 생성하고, 정의된 곳의 스코프를 가집니다. "비슷해 보이지만 근본이 다르다!"
*   **너무 잘게 쪼개는 건 오버엔지니어링**: 재사용성이 명확하거나 코드가 너무 길어져서 분리가 필요할 때만 스니펫을 쓰세요. 모든 걸 스니펫으로 만들면 오히려 코드가 더 복잡해 보일 수 있습니다. "과유불급."