`bind:` 디렉티브는 데이터 흐름을 역전시키는 마법입니다. 보통 데이터는 부모에서 자식으로 흐르는데, `bind:`를 쓰면 자식에서 부모로 데이터가 거꾸로 올라갈 수 있게 되죠. "야, 내 말도 좀 들어봐!" 하고 자식이 부모에게 값을 전달하는 격입니다.

기본 문법은 `bind:속성이름={표현식}`입니다. 여기서 `표현식`은 값을 할당받을 수 있는 변수나 객체 속성(lvalue)이어야 해요. 만약 표현식(변수 이름)이랑 속성 이름이 같다면, `{표현식}` 부분을 생략할 수 있습니다. 아래 두 코드는 같은 의미죠.

```svelte
<input bind:value={value} />
<input bind:value />
```

Svelte는 이렇게 연결된 값을 업데이트하기 위해 이벤트 리스너를 만듭니다. 만약 해당 요소에 이미 같은 이벤트에 대한 리스너가 있다면, 그 리스너가 먼저 실행되고 나서 `bind:`로 연결된 값이 업데이트됩니다. "내가 먼저 처리하고, 그 다음에 네가 가져가!" 하는 식이죠.

대부분의 바인딩은 양방향입니다. 즉, 변수 값이 바뀌면 요소에 반영되고, 요소의 값이 바뀌면 변수에도 반영됩니다. 하지만 일부 바인딩은 읽기 전용이라, 변수 값을 바꿔도 요소에는 아무런 영향을 주지 못합니다. "넌 보기만 해, 만지는 건 안 돼."

**함수 바인딩 (Svelte 5.9.0 이상)**
`bind:속성이름={가져오기함수, 설정함수}` 형태로 함수를 사용할 수도 있습니다. 이걸로 값 검증이나 변환 같은 고급진 작업을 할 수 있죠.

```svelte
<input bind:value={
	() => value, // 값을 가져올 때 실행
	(v) => value = v.toLowerCase() // 값이 설정될 때 실행 (소문자로 바꿔서 저장)
} />
```

`clientWidth`처럼 읽기 전용인 속성에 함수 바인딩을 쓸 때는 `가져오기함수` 자리에 `null`을 넣습니다.

```svelte
<div
	bind:clientWidth={null, redraw}
	bind:clientHeight={null, redraw}
>...</div>
```

---

**얘 뭐 하는 애냐? (기능 및 목적)**
`bind:` 디렉티브는 Svelte에서 **양방향 데이터 바인딩**을 구현하는 핵심 기능입니다. 쉽게 말해, HTML 요소의 특정 속성(예: `<input>`의 `value`)과 스크립트의 변수를 끈으로 묶어서, 한쪽이 바뀌면 다른 쪽도 자동으로 따라서 바뀌게 만드는 겁니다. 부모 컴포넌트와 자식 컴포넌트 사이에서도 자식의 상태를 부모로 쉽게 전달할 수 있게 해줍니다. "너랑 나는 이제 한 몸이야!"

**왜 쓰는데?**
1.  **폼 입력 처리 간소화**: 사용자가 입력 필드에 뭔가 적으면, 그 값을 자바스크립트 변수에 바로바로 업데이트. 반대로 변수 값을 바꾸면 입력 필드 내용도 뿅! 하고 바뀝니다. "일일이 이벤트 리스너 달고 `value` 가져오고... 그런 노가다 이제 안녕~"
2.  **컴포넌트 간 상태 동기화**: 자식 컴포넌트에서 일어난 변화를 부모 컴포넌트가 바로 알아채고 반응해야 할 때 씁니다. 예를 들어, 모달창 닫기 버튼(자식)을 누르면 부모가 모달창을 닫도록 상태를 전달하는 거죠. "자식아, 네 상태는 내가 다 보고 있다."
3.  **DOM 요소 직접 참조**: `bind:this`를 쓰면 DOM 요소 자체를 변수에 담아서 직접 조작할 수 있습니다. 캔버스에 그림을 그리거나, 특정 요소에 포커스를 주는 등의 작업이 가능해집니다. "이 DOM은 이제 제 겁니다."
4.  **다양한 요소 속성 바인딩**: `<input>`의 `value`, `checked`, `group`, `files` 뿐만 아니라 `<select>`의 `value`, `<audio>/<video>`의 재생 상태, 심지어 일반 `<div>`의 크기(`clientWidth`, `offsetHeight`)까지 다양한 속성을 묶을 수 있습니다. "못 묶는 게 뭐니?"

**언제 불려 나오냐?**
*   사용자 입력(텍스트, 체크박스, 라디오 버튼, 파일 선택 등)을 실시간으로 변수에 반영하고 싶을 때.
*   자식 컴포넌트의 내부 상태 변화를 부모 컴포넌트에서 알고 싶거나 제어하고 싶을 때.
*   DOM 요소의 크기나 특정 상태(예: `<details>`의 `open` 상태)를 변수로 받아와서 활용하고 싶을 때.
*   `<audio>`, `<video>` 같은 미디어 요소의 재생 시간, 볼륨 등을 제어하거나 상태를 알고 싶을 때.

**쓸 때 꿀팁 및 주의사항:**
*   **양방향 vs 단방향**: 대부분은 양방향이지만, `clientWidth` 같은 크기 관련 속성이나 `<audio>/<video>`의 `duration` 같은 건 읽기 전용입니다. 즉, 변수 값을 바꾼다고 요소 크기나 영상 길이가 바뀌진 않아요. "바꿀 수 있는 것과 없는 것을 구분하자."
*   **`bind:value`와 타입**: `<input type="number">`나 `<input type="range">`에 `bind:value`를 쓰면 값이 숫자로 자동 변환됩니다. 입력이 비거나 유효하지 않으면 `undefined`가 될 수 있으니 주의. "숫자 아니면 `undefined` 폭탄 맞는다!"
*   **`bind:group`은 같은 컴포넌트 내에서만**: 라디오 버튼이나 체크박스 그룹을 만들 때 쓰는 `bind:group`은 같은 Svelte 컴포넌트 안에 있는 입력 요소들끼리만 작동합니다. "가족끼리만 묶인다."
*   **`bind:files`와 `FileList`**: 파일 입력(`type="file"`)에 `bind:files`를 쓰면 `FileList` 객체를 받습니다. 이 `FileList`는 직접 수정이 안 돼서, 파일을 추가하거나 삭제하려면 `DataTransfer` 객체를 써서 새 `FileList`를 만들어야 하는 좀 귀찮은 점이 있습니다. "파일 목록, 보기엔 쉬워도 다루긴 까다롭네."
*   **`bind:this`와 컴포넌트 생명주기**: `bind:this`로 DOM 노드를 참조할 때, 컴포넌트가 마운트되기 전까지는 해당 변수 값이 `undefined`입니다. `$effect`나 이벤트 핸들러 안에서 사용해야 안전합니다. "DOM 노드? 마운트되고 나서 불러줘."
*   **컴포넌트 `prop` 바인딩과 `$bindable`**: 자식 컴포넌트의 `prop`에 `bind:`를 쓰려면, 자식 컴포넌트에서 해당 `prop`을 `$bindable()`로 선언해야 합니다. 그래야 자식에서 바뀐 값이 부모로 역류할 수 있습니다. 안 그러면 "데이터는 위에서 아래로만 흐른다"는 기본 원칙에 막힙니다. `$bindable`에 기본값을 줄 수도 있는데, `bind:`로 연결되면 부모가 `undefined`가 아닌 값을 줘야 합니다. 안 그러면 에러! "역방향 티켓 끊으려면 `$bindable` 도장 받아와!"
*   **함수 바인딩은 Svelte 5.9.0+**: `bind:property={get, set}` 형태의 함수 바인딩은 최신 Svelte 버전에서만 가능하니 버전 확인 필수. "옛날 Svelte에선 안 돌아가요~"