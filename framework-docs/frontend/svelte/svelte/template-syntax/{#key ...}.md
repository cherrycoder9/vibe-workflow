`{#key ...}` 블록은 표현식의 값이 바뀔 때마다 그 안의 내용을 부쉈다가 다시 만듭니다. 컴포넌트에 사용하면, 해당 컴포넌트가 완전히 새로 만들어지고 초기화되는 효과가 있죠.

```svelte
{#key value}
	<Component />
{/key}
```

값이 바뀔 때마다 트랜지션(애니메이션 효과 같은 거)을 재생하고 싶을 때도 유용합니다.

```svelte
{#key value}
	<div transition:fade>{value}</div>
{/key}
```

---

**얘 뭐 하는 애냐? (기능 및 목적)**
`{#key ...}` 블록은 감시하고 있는 `expression` (표현식)의 값이 바뀔 때마다, 블록 안에 있는 모든 것을 "리셋" 시켜버리는 녀석입니다. 그냥 데이터만 업데이트하는 게 아니라, 아예 싹 밀고 처음부터 다시 만드는 거죠. 마치 게임 캐릭터가 죽으면 부활 지점에서 새로 시작하는 것과 비슷합니다. "너, 지금부터 처음이야!"

**왜 쓰는데?**
1.  **강제 컴포넌트 재생성/초기화**: 가끔 컴포넌트 내부 상태를 완전히 초기화하고 싶을 때가 있습니다. props만 바꾼다고 내부 상태까지 깔끔하게 리셋되지 않을 수 있거든요. 이럴 때 `{#key someValue}`로 감싸고 `someValue`를 바꿔버리면, `<Component />`는 죽었다가 새로 태어납니다. 내부 `onMount` 함수도 다시 실행되고, 모든 게 새삥이 되죠. "더러운 건 못 참지! 새 걸로 갈아 끼워!"
2.  **값 변경 시 트랜지션 실행**: 어떤 값이 바뀔 때마다 애니메이션 효과(트랜지션)를 주고 싶을 때 씁니다. `{#key value}` 안의 내용물은 `value`가 바뀔 때마다 파괴되고 재생성되므로, Svelte의 `transition:` 디렉티브가 다시 동작하게 됩니다. "값이 바뀔 때마다 짠! 하고 나타나거나 사라지게 해줘!"
3.  **리스트 아이템의 고유성 유지**: `{#each}` 블록 안에서 아이템의 순서가 바뀌거나 삭제/추가될 때, 각 아이템이 자신만의 상태를 유지하거나 올바르게 트랜지션되도록 하려면 각 아이템에 고유한 키를 제공해야 합니다. 이때 `{#key item.id}` 같은 형태로 쓰이기도 하지만, 이 경우는 `{#each list as item (item.id)}` 방식이 더 일반적이고 권장됩니다. `{#key}`는 좀 더 범용적인 "강제 리렌더링" 스위치에 가깝죠.

**언제 불려 나오냐?**
Svelte 템플릿(.svelte 파일) 안에서 특정 값의 변경에 따라 컴포넌트나 DOM 요소를 완전히 새로 그려야 할 필요가 있을 때 사용합니다.

**쓸 때 꿀팁 및 주의사항:**
*   **성능 생각은 하고 쓰자**: 뭐든지 부수고 다시 만드는 건 비용이 듭니다. 정말 필요할 때만 써야지, 남용하면 앱이 버벅거리는 수가 있습니다. "망치질도 때와 장소를 가려서!"
*   **`expression`은 신중하게**: `{#key}`에 들어가는 표현식은 값이 진짜 "변경"되었을 때만 리렌더링을 유발합니다. 객체나 배열의 내부 값만 바뀌고 참조 자체는 그대로면, Svelte는 변경을 감지 못할 수 있습니다. 이럴 땐 객체/배열 자체를 새 것으로 교체하거나, 정말 원시값(숫자, 문자열 등)이 바뀌도록 해야 합니다. "겉모습만 같다고 속으면 안 돼, 속까지 봐야지!"
*   **트랜지션과의 궁합**: `transition:fade` 같은 Svelte 트랜지션과 함께 쓰면, 값이 바뀔 때마다 해당 트랜지션이 다시 실행됩니다. 등장/퇴장 애니메이션을 값 변경과 연동시키기 딱 좋죠.
*   **단순 업데이트와 구분**: 그냥 화면 내용만 바꾸고 싶다면 `{#key}` 블록은 필요 없습니다. Svelte는 기본적으로 데이터 변경에 반응하여 DOM을 효율적으로 업데이트합니다. `{#key}`는 그 이상의 "파괴와 창조"가 필요할 때 쓰는 비장의 카드입니다. "모기 잡는데 칼 쓸 필요 없잖아?"
*   **컴포넌트 라이프사이클**: `{#key}` 블록 안의 컴포넌트는 값이 바뀔 때마다 `onDestroy`가 호출되고, 다시 `onMount`가 호출됩니다. 컴포넌트 생명주기에 의존하는 로직이 있다면 이 점을 명확히 인지하고 사용해야 합니다. "죽었다 살아나면 기억도 리셋된다고!"