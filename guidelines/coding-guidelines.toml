group_id = "coding-guidelines"
title = "LLM 코딩 실전 가이드: 삽질 방지 및 효율 극대화"
description = "LLM이 실제 프로젝트에서 코드를 찍어낼 때, 욕 안 먹고 사랑받기 위해 반드시 숙지해야 할 개발, API 최적화, 암호화, 그리고 코드 확장성에 대한 핵심 가이드라인."

[[guidelines]]
id = "api-optimization"
title = "API 호출 최적화: 지갑도 지키고 UX도 살리고"
content = """
API 호출, 잘못하면 돈 나가고 사용자 떠난다. 특히 실시간으로 뭔가 보여줘야 할 때는 정신 바짝 차려야 돼.

**이건 무조건 써먹어라:**
*   **디바운싱 (Debounce):** 사용자 입력 끝나고 300~500ms 뒤에 딱 한 번만 호출. 검색창, 실시간 폼 검증 같은 데 필수.
*   **클라이언트 캐싱:** 똑같은 거 또 물어보지 마. 로컬/세션/메모리에 저장해뒀다가 꺼내 써. 데이터가 자주 안 바뀌는 놈들한테 좋고, 만료 시간(TTL)이랑 폐기 전략도 같이 고민해야 됨.
*   **요청 중복 제거:** 따따블 클릭이나 자동 호출로 같은 요청 여러 번 날아오면, 첫 번째 놈 결과 재활용.

**코딩할 때 명심할 것:**
1.  **최적화는 기본 옵션:** 디바운싱, 클라이언트 캐싱, 중복 제거부터 박고 시작해.
2.  **데이터는 필요한 만큼만:** 대용량 데이터는 페이지네이션이나 레이지 로딩으로 잘라 보내. GraphQL 쓴다면 필요한 필드만 콕 집어서 요청하고, 쿼리 배칭/지속 쿼리 적극 활용.
3.  **네트워크도 아껴 쓰자:** 요청 묶어 보내기(배치)랑 HTTP 캐싱은 습관처럼.
4.  **터져도 괜찮게:** 실패하면 지수 백오프로 재시도하고, API 호출 제한(레이트 리밋) 걸리면 알아서 쉬었다 가게 만들어.
"""

[[guidelines]]
id = "development-standards"
title = "개발 표준 및 일관성: 혼자 하는 거 아니잖아?"
content = """
코드도 단체 생활이다. 규칙 지켜서 서로 편하게, 생산성 쭉쭉 올리자.

**코드 스타일:**
*   **대원칙:** 이미 있는 규칙(언어별, 프레임워크별)이 1순위. 없으면 아래 참고.
*   **들여쓰기:** 파이썬은 스페이스 4칸, 나머진 2칸. 탭 쓰면 혼난다.
*   **이름짓기:** 변수/함수/파라미터는 `camelCase`(JS/TS) 아니면 `snake_case`(Python). 클래스/타입/Enum은 `PascalCase`. 상수는 `UPPER_SNAKE_CASE`. 파일명은 `kebab-case`나 `snake_case` 쓰는데, React 컴포넌트는 `PascalCase.tsx` 국룰.
*   **한 줄 길이:** 88자 넘기지 마. 모니터 넓다고 막 쓰지 말고.
*   **함수 길이:** 25줄 넘어가면 뭔가 잘못되고 있다는 신호.
*   **주석:** '왜(why)' 이렇게 짰는지, 핵심만 간단하게. '무엇을(what)' 하는지는 코드로 보여줘.

**Git 워크플로:**
*   **브랜치 전략:** GitHub Flow (`main`은 항상 배포 가능한 상태, PR만이 살길).
*   **브랜치명:** `feat/<이슈번호>-기능요약`, `fix/<이슈번호>-버그픽스`, `refactor/<리팩토링-내용>`, `docs/<문서-작업>`, `chore/<자잘한-작업>` 이런 식으로. 이슈번호 없으면 생략 가능.
*   **커밋 메시지:** Gitmoji 써서 한눈에 딱! (예: `✨ feat: JWT 리프레시 토큰 야무지게 추가`)
*   **PR 규칙:** PR 템플릿 쓰고, 동료 한 명 이상 리뷰 받고, CI 통과해야 머지 가능. PR은 작고 명확하게.

**테스트:**
*   **어디다 짜냐:** 소스 파일 옆이나 `tests/` 폴더 밑에.
*   **커버리지:** 일단 80% 목표로.
*   **종류:** 유닛, 통합, E2E 테스트 골고루.

**문서화:**
*   **README.md:** 프로젝트 설명, 설치/실행 방법, 기여 방법 정도는 기본.
*   **API 명세:** REST API는 OpenAPI v3 (`api-contract.yaml`), GraphQL은 SDL이랑 관련 도구 써서 깔끔하게.

**기타 등등:**
*   **남의 바퀴 또 만들지 마:** 새 기능 추가할 때, 기존 코드나 라이브러리 중에 써먹을 거 없는지 눈 크게 뜨고 찾아봐. **프레임워크나 기존 코드 패턴에 최대한 맞춰 짜는 게 기본.**
*   **구조부터 생각:** 새 기능 넣을 때, 폴더나 파일 구조, 혹은 아키텍처 변경이 필요한지 먼저 고민해. **확장성 있는 코드는 여기서부터 시작된다.**
*   **의존성 관리:** 새 패키지 함부로 추가하지 마. 팀이랑 상의하고, 취약점 있는지 꼭 확인. Lock 파일은 무조건 커밋.
*   **보안은 기본 소양:** 비밀키 코드에 박아두면 진짜 큰일 난다. 환경 변수나 시크릿 매니저 써. 사용자 입력값은 절대 믿지 말고 검증 철저히.
*   **에러 처리 & 로깅:** 모든 에러는 잡아서 처리하고, 사용자한테는 친절하게 알려줘. 로그에는 디버깅 정보 충분히 남기되, 개인정보 같은 민감 정보는 절대 금지. 구조화된 로깅 쓰면 나중에 편하다.
*   **함수는 심플하게:** 함수 하나는 딱 한 가지 일만(SRP). 파라미터는 4개 넘기지 않도록 노력하고, 부수 효과(side effect)는 최소화.
"""

[[guidelines]]
id = "cryptography-standards"
title = "암호화 가이드라인: 어설프게 건드리면 훅 간다"
content = """
암호화, 잘못 쓰면 안 하느니만 못하다. 검증된 방법으로 안전하게!

**핵심 원칙:**
1.  **단순함이 최고:** 잘 알려진 표준 알고리즘 하나 골라서 제대로 쓰는 게 장땡.
2.  **메모리-하드 KDF:** `Argon2id`처럼 메모리 많이 먹는 놈으로.
3.  **가성비 따져라:** 관리하기 너무 어려운데 보안 효과 별로면, 더 단순하고 안전한 방법 찾아봐.
4.  **Salt는 공개, Pepper는 비밀:** Salt는 사용자마다 다르고 공개해도 OK. Pepper는 서버만 아는 비밀.
5.  **Nonce/키 재사용 절대 금지:** AEAD 암호화 쓸 때 (키, Nonce) 똑같은 거 또 쓰면 그냥 다 뚫리는 거.

**패스워드 해싱 / 키 스트레칭:**
*   **추천 KDF:** `Argon2id` (libsodium의 `crypto_pwhash` 함수 강추).
*   **Salt:** 사용자마다 최소 16바이트 이상, 암호학적으로 안전한 랜덤 값으로 만들어서, 해시된 패스워드랑 같이 DB에 저장.
*   **Pepper (선택 사항):** 최소 32바이트 이상, 환경 변수나 HSM, Secrets Manager 같은 안전한 곳에 보관. DB에 절대 저장 금지.
*   **패스워드 비교:** 시간 기반 공격 막으려면 무조건 Constant-Time 비교 함수 써야 함.

**대칭키 데이터 암호화 (AEAD 방식 필수):**
*   **추천 AEAD 알고리즘:** XChaCha20-Poly1305 (어디서든 잘 돌아감).
*   **절대 금지 (CRITICAL):** AES-GCM에서 Nonce 재사용, 듣도 보도 못한 암호화 모드 조합해서 쓰는 거.

**키 파생 및 도메인 분리:**
*   **HKDF 적극 활용:** `HKDF(root_key, salt, info, length)`. `info`에 이 키 어디다 쓰는지 명확하게 적어둬.

**구현 전 체크리스트:**
*   Salt: 16바이트 이상, CSPRNG로 생성, 유저별로 고유하게 저장했나?
*   Pepper: 32바이트 이상, 안전하게 보관 중인가?
*   KDF 파라미터: OWASP 권고 수준 이상인가?
*   Nonce: (키, Nonce) 재사용 안 하게 막았나?
*   인증 태그 검증은 확실한가?
*   Constant-Time 비교 함수 사용했나?
*   검증된 라이브러리만 썼나?

**이런 짓은 하지 마라 (안티패턴):**
*   KDF 여러 번 돌리기, AEAD 이중 암호화, PBKDF2/bcrypt 새로 도입 (Argon2 써!), Pepper를 DB에 저장, Nonce 고정해서 쓰기, 직접 만든 암호화 알고리즘 쓰기.
"""
