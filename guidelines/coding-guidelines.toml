group_id = "coding-guidelines"
title = "코딩 가이드라인"
description = "LLM이 코딩 작업 시 참고해야 할 개발, API 최적화, 암호화 관련 핵심 가이드라인입니다."

[[guidelines]]
id = "api-optimization"
title = "API 호출 최적화 및 비용 절감"
content = """
API 호출을 효율적으로 다듬어 사용자 경험을 높이고, 서버 부하와 비용을 줄이는 것이 목표입니다.
특히 검색 자동 완성이나 실시간 유효성 검사처럼 사용자 입력에 반응하는 기능에서는 호출 최소화가 핵심입니다.

**필수 적용 패턴:**
*   **디바운싱 (Debounce):** 마지막 입력 후 300~500ms가 지나면 한 번만 호출. 검색 창, 입력 폼 실시간 검증 등에 적용.
*   **클라이언트 캐싱:** 동일 요청에 대해 로컬 스토리지/세션/메모리에 응답 저장. 자주 변하지 않는 데이터에 적용하며, TTL(만료 시간)과 무효화 전략을 함께 설계.
*   **요청 중복 제거:** 동일 요청이 동시에 여러 번 발생하면 첫 요청 결과를 재사용. 빠른 연속 클릭이나 자동 호출 방지.

**코딩 가이드라인:**
1.  **최적화는 기본:** 디바운싱, 클라이언트 캐싱, 요청 중복 제거를 우선 구현.
2.  **데이터 효율:** 대량 데이터는 페이지네이션 또는 레이지 로딩 적용. GraphQL 사용 시 필드 최소화, 쿼리 배칭/지속 쿼리 권장.
3.  **네트워크 효율:** 요청 배치와 HTTP 캐싱을 적극 활용.
4.  **안정성:** 실패 시 지수 백오프 재시도 로직 포함. 레이트 리밋 준수 로직 구현.
"""

[[guidelines]]
id = "development-standards"
title = "개발 표준 및 일관성"
content = """
프로젝트 코드의 일관성을 지키고, 생산성과 품질을 높이기 위한 규칙입니다.

**코드 스타일:**
*   언어 또는 프레임워크별 규칙이 있다면 해당 규칙을 우선합니다.
*   **들여쓰기:** Python은 공백 4칸, 그 외는 공백 2칸.
*   **네이밍:** 변수/함수/파라미터는 `camelCase` (JS/TS) 또는 `snake_case` (Python). 클래스/타입/Enum은 `PascalCase`. 상수는 `UPPER_SNAKE_CASE`. 파일명은 `kebab-case` 또는 `snake_case`, React 컴포넌트는 `PascalCase.tsx`.
*   **라인 길이:** 88자 제한.
*   **함수 길이:** 최대 25줄 권장.
*   **주석:** 중요한 이유(why)만 간결하게.

**Git 워크플로:**
*   **브랜치 전략:** GitHub Flow (`main` 브랜치는 배포 가능 상태 유지, PR로만 병합).
*   **브랜치명:** `feat/<번호>-설명`, `fix/<번호>-설명`, `refactor/<설명>`, `docs/<설명>`, `chore/<설명>` 등.
*   **커밋 메시지:** Gitmoji 사용 (예: `✨ feat: JWT 리프레시 토큰 추가`).
*   **PR 규칙:** PR 템플릿 활용, 최소 1명 리뷰, CI 통과 필수, 작고 집중된 PR 생성.

**테스트:**
*   **위치:** 소스 파일과 동일 디렉터리 또는 `tests/` 아래.
*   **커버리지:** 목표 80% 이상.
*   **유형:** 단위, 통합, E2E 균형 있게 작성.

**문서화:**
*   **README.md:** 개요, 설치, 실행, 기여 방법.
*   **API 명세:** REST는 OpenAPI v3 (`api-contract.yaml`), GraphQL은 SDL 및 도구 활용.

**기타 규칙:**
*   **의존성:** 새 패키지 추가 전 팀 논의 및 취약점 검사. Lock 파일 반드시 커밋.
*   **보안:** 비밀키 하드코딩 금지, 환경 변수/시크릿 매니저 사용, 입력 검증.
*   **에러 처리 & 로깅:** 모든 오류 명시적 처리, 사용자에겐 친절한 메시지, 로그엔 충분한 디버깅 정보, 민감 정보 로그 금지, 구조화된 로깅 사용.
*   **함수 설계:** 단일 책임 원칙(SRP), 매개변수 4개 이하 권장, 부수 효과 최소화.
"""

[[guidelines]]
id = "cryptography-standards"
title = "암호화 가이드라인"
content = """
안전하고 효율적인 암호화 구현을 위한 핵심 지침입니다.

**핵심 원칙:**
1.  **단순함이 강력함:** 검증된 표준 알고리즘 하나를 선택하고 올바르게 사용.
2.  **메모리-하드(Memory-Hard) KDF:** `Argon2id`와 같이 메모리 사용량이 높은 KDF 사용.
3.  **운용 난이도 vs. 보안 이득:** 관리 복잡성이 보안 이득보다 크다면 더 단순하고 안전한 방식 고려.
4.  **Salt는 공개, Pepper는 비밀:** Salt는 사용자별 고유한 공개 값, Pepper는 서버 측 비밀 값.
5.  **Nonce/키 재사용 절대 금지:** AEAD 암호화 방식 사용 시 동일한 (키, Nonce) 쌍 재사용 금지.

**패스워드 해싱 / 키 스트레칭:**
*   **주요 KDF:** `Argon2id` (libsodium의 `crypto_pwhash` 함수 사용 권장).
*   **Salt:** 사용자마다 최소 16바이트 이상의 암호학적으로 안전한 랜덤 값으로 생성, 해시된 패스워드와 함께 DB에 저장.
*   **Pepper (선택 사항):** 최소 32바이트 이상, 안전하게 보관 (환경 변수, HSM, Secrets Manager), 절대 DB에 저장 금지.
*   **패스워드 비교:** 반드시 Constant-Time 비교 함수 사용.

**대칭키 데이터 암호화 (AEAD 방식 필수):**
*   **권장 AEAD 알고리즘:** XChaCha20-Poly1305 (모든 플랫폼 권장).
*   **금지 (CRITICAL):** AES-GCM에서 Nonce 재사용, 자체 암호화 모드 조합.

**키 파생 및 도메인 분리:**
*   **HKDF 사용 권장:** `HKDF(root_key, salt, info, length)`. `info`에 키 용도를 명확하게 표시.

**구현 체크리스트:**;
*   Salt: 16바이트 이상, CSPRNG, 고유 저장
*   Pepper: 32바이트 이상, 안전 보관
*   KDF 파라미터: OWASP 권고 이상
*   Nonce: (키,Nonce) 재사용 금지
*   인증 태그 검증 필수
*   Constant-Time 비교 사용
*   검증된 라이브러리만 사용

**흔한 안티패턴:**
*   KDF 중첩, 이중 AEAD 암호화, PBKDF2/bcrypt 신규 도입, Pepper를 DB에 저장, 고정 Nonce 사용, 자체 암호화 알고리즘 사용.
"""
