# 코딩 컨벤션

이 문서는 프로젝트의 코딩 표준 및 컨벤션을 정의합니다. 모든 코드는 이 가이드라인을 엄격히 준수해야 합니다.

## 일반 원칙

- **명확성**: 코드는 읽기 쉽고 이해하기 쉬워야 합니다.
- **일관성**: 프로젝트 전체에서 일관된 스타일을 유지합니다.
- **간결성**: 불필요한 복잡성을 피하고 간결하게 작성합니다.
- **타입 명확성**: `any` 타입의 남발을 지양하고, 가능한 한 구체적인 타입을 명시합니다.
  - **목적**: 코드의 안정성과 예측 가능성을 높이고, 개발 도구의 지원을 최대한 활용합니다.
- **디버깅 출력**: 개발 단계에서 사용된 `console.log`와 같은 디버깅 출력은 프로덕션 코드에 포함되지 않도록 합니다.
  - **목적**: 불필요한 로그로 인한 성능 저하를 방지하고, 민감한 정보 노출 위험을 줄입니다.

### 패키지 매니저

- 프로젝트의 패키지 관리는 `pnpm`을 사용합니다.
  - **목적**: 효율적인 의존성 관리와 디스크 공간 절약을 위함입니다.
  - **설치**: `npm install -g pnpm` 명령어를 사용하여 pnpm을 설치할 수 있습니다.

## 코드 구조 및 형식

### 함수 설계

- **단일 책임 원칙(SRP)**: 함수는 하나의 책임만 가지도록 설계합니다.
  - **목적**: 함수의 응집도를 높이고, 유지보수 및 테스트를 용이하게 합니다.
- **매개변수 수 제한**: 함수의 매개변수는 4개 이하로 제한하는 것을 권장합니다.
  - **해결책**: 매개변수가 4개를 초과할 경우, 관련 매개변수들을 하나의 객체로 묶어 전달하는 것을 고려합니다.
  - **목적**: 함수의 복잡도를 줄이고, 호출 시 인자 전달의 명확성을 높입니다.
- **부수 효과 최소화**: 함수는 가능한 한 부수 효과(Side Effect)를 최소화하도록 설계합니다.
  - **목적**: 함수의 예측 가능성을 높이고, 디버깅을 용이하게 하며, 병렬 처리 시 발생할 수 있는 문제를 줄입니다.

### 함수 길이

- **함수 라인 수 제한**: 함수 하나의 총 라인 수는 24줄을 초과해서는 안 됩니다. (주석, 빈 줄 제외)
  - **목적**: 함수의 복잡도를 낮추고, 가독성을 높이며, 재사용 가능한 작은 단위로 분리하도록 유도합니다.
  - **예외**: 특정 프레임워크의 요구사항이나 불가피하게 긴 로직이 필요한 경우, 충분한 주석과 함께 예외를 인정할 수 있으나, 최대한 24줄 이내로 유지하도록 노력해야 합니다.

### 라인 길이

- **한 줄 문자 수 제한**: 라인 한 줄은 띄어쓰기를 포함하여 64자를 초과해서는 안 됩니다.
  - **목적**: 코드 가독성을 높이고, 여러 개발자가 동시에 작업할 때 충돌을 줄이며, 작은 화면에서도 코드를 쉽게 볼 수 있도록 합니다.
  - **예외**: URL, 긴 문자열 리터럴, 정규 표현식, import 문 등 불가피하게 긴 라인이 필요한 경우 예외를 인정할 수 있습니다. 이 경우에도 가독성을 해치지 않는 선에서 최대한 줄이도록 노력해야 합니다.

### 주석

- 주석은 한국어로 작성합니다.
- 코드를 이해하는 데 필요한 경우에만 주석을 사용합니다.
- 주석은 코드의 '무엇'이 아닌 '왜'를 설명해야 합니다.

### 들여쓰기

- 들여쓰기는 2칸 공백을 사용합니다. (탭 사용 금지)
  - **목적**: 코드의 일관된 가독성을 유지하고, 협업 시 발생할 수 있는 들여쓰기 관련 문제를 방지합니다.

### 변수 및 함수명

- 변수명과 함수명은 의미를 명확하게 전달해야 합니다.
- 카멜 케이스(camelCase) 또는 스네이크 케이스(snake_case) 등 프로젝트의 표준을 따릅니다.

### 파일 및 URL 명명

- URL 경로 및 파일명은 소문자와 하이픈(`-`)을 사용하여 작성합니다. (스네이크 케이스나 카멜 케이스 사용 금지)
  - **목적**: 일관된 명명 규칙을 통해 가독성을 높이고, 플랫폼 간 호환성 문제를 방지하며, RESTful API 원칙에 따라 자원 중심의 URL을 만듭니다.
  - **예시**: `user-profile.js`, `/api/v1/users` (GET 요청 시 사용자 목록, POST 요청 시 사용자 생성 등)
  - **참고**: `/api/v1/users`와 같이 `api` 접두사와 버전(`v1`)을 포함하는 방식은 API 버전 관리와 명확한 API 엔드포인트 구분을 위해 권장됩니다. 단순히 `/users`를 사용하는 것보다 확장성과 유지보수 측면에서 유리합니다.

## 커밋 메시지

- 커밋 메시지는 [Gitmoji](https://gitmoji.dev/) 컨벤션을 따릅니다.
  - **목적**: 커밋 히스토리를 시각적으로 명확하게 하고, 커밋의 목적을 쉽게 파악할 수 있도록 합니다.
  - **형식**: `[이모지] [타입]: [설명]` (타입과 설명은 영어로 작성)
    - **예시**: `✨ feat: Add JWT refresh token`
    - **주요 이모지**:
      - `✨ feat`: 새로운 기능 추가
      - `🐛 fix`: 버그 수정
      - `📝 docs`: 문서 수정 또는 추가
      - `♻️ refactor`: 코드 리팩토링 (기능 변경 없음)
      - `✅ test`: 테스트 코드 추가 또는 수정
      - `🚀 chore`: 빌드 시스템, 패키지 관리 등 기타 변경
      - `⚡️ perf`: 성능 개선
      - `🔒 security`: 보안 관련 변경

## 에러 처리

- 에러는 명확하게 처리하고, 사용자에게 적절한 피드백을 제공합니다.
- 예외 처리는 예측 가능한 상황에만 사용하고, 흐름 제어에 남용하지 않습니다.

## 동기/비동기 및 스레딩

- **동기/비동기 처리**:
  - I/O 작업(네트워크 요청, 파일 시스템 접근, 데이터베이스 쿼리 등)이 포함된 로직은 비동기 방식으로 처리하여 애플리케이션의 응답성을 유지합니다.
  - 비동기 코드 작성 시 콜백 헬(Callback Hell)을 피하고, Promise, async/await 등 최신 비동기 패턴을 활용하여 가독성을 높입니다.
- **싱글/멀티스레드 고려**:
  - 주로 사용하는 프레임워크나 언어의 스레딩 모델(예: Node.js의 싱글 스레드 이벤트 루프, Python의 GIL, Java의 멀티스레드)을 이해하고, 이에 맞춰 코드를 설계합니다.
  - 싱글 스레드 환경에서는 블로킹(Blocking) 작업을 최소화하고, 멀티스레드 환경에서는 스레드 안전성(Thread Safety)을 고려하여 동시성 문제를 방지합니다.
  - 공유 자원 접근 시 락(Lock) 또는 뮤텍스(Mutex)와 같은 동기화 메커니즘을 적절히 사용합니다.

## 보안

- **비밀키 하드코딩 금지**: API 키, 데이터베이스 비밀번호 등 민감한 정보는 코드에 직접 하드코딩하지 않습니다.
  - **해결책**: 환경 변수, 시크릿 매니저(예: AWS Secrets Manager, HashiCorp Vault) 또는 안전한 설정 파일을 통해 관리합니다.
- **입력 검증**: 모든 사용자 입력 및 외부 데이터를 철저히 검증하여 XSS(Cross-Site Scripting), SQL Injection 등 보안 취약점을 방지합니다.
  - **해결책**: 적절한 라이브러리나 프레임워크 기능을 활용하여 입력 값을 이스케이프하거나 필터링합니다.

## 성능

- **자료구조 선택**: 데이터의 특성(크기, 접근 패턴, 변경 빈도 등)과 연산의 복잡도(시간/공간)를 고려하여 가장 효율적인 자료구조를 선택합니다.
  - **예시**:
    - 순차적 접근 및 삽입/삭제가 빈번하면 연결 리스트(Linked List)를 고려합니다.
    - 빠른 검색이 중요하고 데이터가 정적이면 해시 테이블(Hash Table)이나 트리(Tree) 구조를 고려합니다.
    - 고정 크기 데이터의 빠른 인덱스 접근이 필요하면 배열(Array)을 사용합니다.
- 성능 최적화는 필요한 경우에만 수행하며, 가독성을 해치지 않는 선에서 진행합니다.
- 불필요한 연산이나 반복을 피합니다.
