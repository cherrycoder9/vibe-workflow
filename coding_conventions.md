# 코딩 컨벤션

이 문서는 프로젝트의 코딩 표준 및 컨벤션을 정의합니다. 모든 코드는 이 가이드라인을 엄격히 준수해야 합니다.

## 일반 원칙

- **명확성**: 코드는 읽기 쉽고 이해하기 쉬워야 합니다.
- **일관성**: 프로젝트 전체에서 일관된 스타일을 유지합니다.
- **간결성**: 불필요한 복잡성을 피하고 간결하게 작성합니다.
- **타입 명확성**: `any` 타입의 남발을 지양하고, 가능한 한 구체적인 타입을 명시합니다.
  - **목적**: 코드의 안정성과 예측 가능성을 높이고, 개발 도구의 지원을 최대한 활용합니다.
- **디버깅 출력**: 개발 단계에서 사용된 `console.log`와 같은 디버깅 출력은 프로덕션 코드에 포함되지 않도록 합니다.
  - **목적**: 불필요한 로그로 인한 성능 저하를 방지하고, 민감한 정보 노출 위험을 줄입니다.

### 패키지 매니저

- 프로젝트의 패키지 관리는 `pnpm`을 사용합니다.
  - **목적**: 효율적인 의존성 관리와 디스크 공간 절약을 위함입니다.
  - **설치**: `npm install -g pnpm` 명령어를 사용하여 pnpm을 설치할 수 있습니다.

## 코드 구조 및 형식

### 함수 설계

- **단일 책임 원칙(SRP)**: 함수는 하나의 책임만 가지도록 설계합니다.
  - **목적**: 함수의 응집도를 높이고, 유지보수 및 테스트를 용이하게 합니다.
- **매개변수 수 제한**: 함수의 매개변수는 4개 이하로 제한하는 것을 권장합니다.
  - **해결책**: 매개변수가 4개를 초과할 경우, 관련 매개변수들을 하나의 객체로 묶어 전달하는 것을 고려합니다.
  - **목적**: 함수의 복잡도를 줄이고, 호출 시 인자 전달의 명확성을 높입니다.
- **부수 효과 최소화**: 함수는 가능한 한 부수 효과(Side Effect)를 최소화하도록 설계합니다.
  - **목적**: 함수의 예측 가능성을 높이고, 디버깅을 용이하게 하며, 병렬 처리 시 발생할 수 있는 문제를 줄입니다.

### 함수 길이

- **함수 라인 수 제한**: 함수 하나의 총 라인 수는 32줄을 초과해서는 안 됩니다. (주석, 빈 줄 포함)
  - **목적**: 함수의 복잡도를 낮추고, 가독성을 높이며, 재사용 가능한 작은 단위로 분리하도록 유도합니다.
  - **예외**: 특정 프레임워크의 요구사항이나 불가피하게 긴 로직이 필요한 경우, 충분한 주석과 함께 예외를 인정할 수 있으나, 최대한 32줄 이내로 유지하도록 노력해야 합니다.

### 라인 길이

- **한 줄 문자 수 제한**: 라인 한 줄은 띄어쓰기를 포함하여 64자를 초과해서는 안 됩니다.
  - **목적**: 코드 가독성을 높이고, 여러 개발자가 동시에 작업할 때 충돌을 줄이며, 작은 화면에서도 코드를 쉽게 볼 수 있도록 합니다.
  - **예외**: URL, 긴 문자열 리터럴, 정규 표현식, import 문 등 불가피하게 긴 라인이 필요한 경우 예외를 인정할 수 있습니다. 이 경우에도 가독성을 해치지 않는 선에서 최대한 줄이도록 노력해야 합니다.

### 주석

- 주석은 한국어로 작성합니다.
- 코드를 이해하는 데 필요한 경우에만 주석을 사용합니다.
- 주석은 코드의 '무엇'이 아닌 '왜'를 설명해야 합니다.
- **Svelte 컴포넌트 주석**: Svelte 컴포넌트에는 일반 HTML 주석 외에 `@component` 주석을 활용하여 IDE에서 컴포넌트에 대한 설명을 표시할 수 있습니다. 이는 협업과 유지보수에 유리합니다.
  - **예시**:

    ```svelte
    <!--
      @component
      이 컴포넌트는 사용자 프로필 정보를 표시합니다.
      @param {string} name - 사용자의 이름
      @param {number} age - 사용자의 나이
    -->
    <script>
      export let name;
      export let age;
    </script>

    <div>
      <h1>{name}</h1>
      <p>{age}세</p>
    </div>
    ```

### 들여쓰기

- 들여쓰기는 2칸 공백을 사용합니다. (탭 사용 금지)
  - **목적**: 코드의 일관된 가독성을 유지하고, 협업 시 발생할 수 있는 들여쓰기 관련 문제를 방지합니다.

### 변수 및 함수명

- 변수명과 함수명은 의미를 명확하게 전달해야 합니다.
- 카멜 케이스(camelCase) 또는 스네이크 케이스(snake_case) 등 프로젝트의 표준을 따릅니다.

### 파일 및 URL 명명

- URL 경로 및 파일명은 소문자와 하이픈(`-`)을 사용하여 작성합니다. (스네이크 케이스나 카멜 케이스 사용 금지)
  - **목적**: 일관된 명명 규칙을 통해 가독성을 높이고, 플랫폼 간 호환성 문제를 방지하며, RESTful API 원칙에 따라 자원 중심의 URL을 만듭니다.
  - **예시**: `user-profile.js`, `/api/v1/users` (GET 요청 시 사용자 목록, POST 요청 시 사용자 생성 등)
  - **참고**: `/api/v1/users`와 같이 `api` 접두사와 버전(`v1`)을 포함하는 방식은 API 버전 관리와 명확한 API 엔드포인트 구분을 위해 권장됩니다. 단순히 `/users`를 사용하는 것보다 확장성과 유지보수 측면에서 유리합니다.

## 커밋 메시지

- 커밋 메시지는 [Gitmoji](https://gitmoji.dev/) 컨벤션을 따릅니다.
  - **목적**: 커밋 히스토리를 시각적으로 명확하게 하고, 커밋의 목적을 쉽게 파악할 수 있도록 합니다.
  - **형식**: `[이모지] [타입]: [설명]` (타입과 설명은 영어로 작성)
    - **예시**: `✨ feat: Add JWT refresh token`
    - **주요 이모지**:
      - `✨ feat`: 새로운 기능 추가
      - `🐛 fix`: 버그 수정
      - `📝 docs`: 문서 수정 또는 추가
      - `♻️ refactor`: 코드 리팩토링 (기능 변경 없음)
      - `✅ test`: 테스트 코드 추가 또는 수정
      - `🚀 chore`: 빌드 시스템, 패키지 관리 등 기타 변경
      - `⚡️ perf`: 성능 개선
      - `🔒 security`: 보안 관련 변경

## 에러 처리

- 에러는 명확하게 처리하고, 사용자에게 적절한 피드백을 제공합니다.
- 예외 처리는 예측 가능한 상황에만 사용하고, 흐름 제어에 남용하지 않습니다.

## 동기/비동기 및 스레딩

- **동기/비동기 처리**:
  - I/O 작업(네트워크 요청, 파일 시스템 접근, 데이터베이스 쿼리 등)이 포함된 로직은 비동기 방식으로 처리하여 애플리케이션의 응답성을 유지합니다.
  - 비동기 코드 작성 시 콜백 헬(Callback Hell)을 피하고, Promise, async/await 등 최신 비동기 패턴을 활용하여 가독성을 높입니다.
- **싱글/멀티스레드 고려**:
  - 주로 사용하는 프레임워크나 언어의 스레딩 모델(예: Node.js의 싱글 스레드 이벤트 루프, Python의 GIL, Java의 멀티스레드)을 이해하고, 이에 맞춰 코드를 설계합니다.
  - 싱글 스레드 환경에서는 블로킹(Blocking) 작업을 최소화하고, 멀티스레드 환경에서는 스레드 안전성(Thread Safety)을 고려하여 동시성 문제를 방지합니다.
  - 공유 자원 접근 시 락(Lock) 또는 뮤텍스(Mutex)와 같은 동기화 메커니즘을 적절히 사용합니다.

## 보안

- **비밀키 하드코딩 금지**: API 키, 데이터베이스 비밀번호 등 민감한 정보는 코드에 직접 하드코딩하지 않습니다.
  - **해결책**: 환경 변수, 시크릿 매니저(예: AWS Secrets Manager, HashiCorp Vault) 또는 안전한 설정 파일을 통해 관리합니다.
- **입력 검증**: 모든 사용자 입력 및 외부 데이터를 철저히 검증하여 XSS(Cross-Site Scripting), SQL Injection 등 보안 취약점을 방지합니다.
  - **해결책**: 적절한 라이브러리나 프레임워크 기능을 활용하여 입력 값을 이스케이프하거나 필터링합니다.

## 성능

- **자료구조 선택**: 데이터의 특성(크기, 접근 패턴, 변경 빈도 등)과 연산의 복잡도(시간/공간)를 고려하여 가장 효율적인 자료구조를 선택합니다.
  - **예시**:
    - 순차적 접근 및 삽입/삭제가 빈번하면 연결 리스트(Linked List)를 고려합니다.
    - 빠른 검색이 중요하고 데이터가 정적이면 해시 테이블(Hash Table)이나 트리(Tree) 구조를 고려합니다.
    - 고정 크기 데이터의 빠른 인덱스 접근이 필요하면 배열(Array)을 사용합니다.
- 성능 최적화는 필요한 경우에만 수행하며, 가독성을 해치지 않는 선에서 진행합니다.
- 불필요한 연산이나 반복을 피합니다.

## SvelteKit 개발 시 주의사항

SvelteKit은 생산성과 성능이 뛰어나지만, 대규모 프로젝트나 고급 기능 사용 시 예상치 못한 문제가 발생할 수 있습니다. 특히 SSR 환경에서의 상태 관리, 폼 처리, 성능 최적화, 훅 사용법, UI 일관성 및 대규모 프로젝트 확장성 측면에서 주의가 필요합니다.

### 1. SSR에서의 상태 관리

- **전역 싱글톤 스토어 위험**: SSR 환경에서 `writable` 스토어를 최상위 레벨에서 선언하면 모든 사용자 요청 간에 공유되어 데이터 유출 위험이 있습니다.
  - **해결책**: `getContext`, `setContext`를 사용하여 요청별로 스토어를 스코핑하거나, `onMount`에서 컴포넌트 인스턴스별로 초기화합니다. Svelte 5 룬 사용 시에도 스코핑에 주의합니다.
- **`event.locals` 및 `stuff` 데이터 불일치**: `event.locals` 데이터는 서버 요청 처리 중에만 유효하며, 클라이언트 네비게이션 시 자동 업데이트되지 않아 오래된 데이터 문제가 발생할 수 있습니다.
  - **해결책**: `invalidate` 함수로 `load` 함수를 명시적으로 재실행하거나, Svelte 스토어를 활용하여 클라이언트 상태와 서버 데이터를 동기화합니다.
- **반응성 누락**: 객체/배열의 내부 속성 변경 시 Svelte의 할당 기반 반응성으로 인해 UI 업데이트가 누락될 수 있습니다.
  - **해결책**: 변경 후 객체/배열을 재할당(`obj = obj;`, `arr = [...arr, item];`)하거나, Svelte 5의 `$state` 룬을 올바르게 사용합니다. 불필요한 재렌더링을 피하고 `{#each}` 블록에서 `key`를 올바르게 사용합니다.

### 2. 견고한 폼 처리 및 액션

- **서버 측 유효성 검사 필수**: 클라이언트 측 유효성 검사는 우회될 수 있으므로, `Zod`와 같은 라이브러리를 사용하여 서버 측에서 반드시 유효성 검사를 수행합니다. "클라이언트를 신뢰하지 말라"는 원칙을 준수합니다.
- **`fail()`을 통한 우아한 오류 처리**: 서버 액션 실패 시 `fail(status, data)` 함수를 사용하여 오류 메시지와 유효했던 입력값을 클라이언트에 반환하여 사용자 경험을 개선합니다. 웹 접근성(`aria-invalid`, `aria-describedby`)도 고려합니다.
- **리디렉션 및 오류 전파 주의**: `throw redirect()`나 `error()` 함수는 SvelteKit의 제어 흐름을 변경하므로, `try...catch` 블록에서 이들을 "삼키지(swallow)" 않도록 주의합니다. SvelteKit의 독특한 오류 처리 메커니즘을 이해해야 합니다.
- **CSRF 및 입력값 신뢰**: SvelteKit은 기본 CSRF 보호를 제공하지만, `+server.js` API 라우트나 특정 요구사항에 따라 추가적인 사용자 정의 CSRF 미들웨어 구현을 고려합니다. 입력값은 항상 검증하고, 프레임워크의 기본 보안 기능에만 의존하지 않습니다.

### 3. SSR 및 성능 최적화

- **`load` 함수의 실행 컨텍스트 및 직렬화**: `load` 함수는 서버/클라이언트 양쪽에서 실행될 수 있으며, 서버 `load` 함수에서 반환되는 데이터는 반드시 직렬화 가능해야 합니다. 함수, `Date` 객체, 클래스 인스턴스 등은 직렬화 오류를 일으킬 수 있으므로 변환이 필요합니다.
- **하이드레이션 문제**: 프리렌더링된 페이지에서 `window`, `document` 등 브라우저 전역 객체에 접근 시 오류가 발생할 수 있습니다. 브라우저 전용 API는 `onMount`나 `if (browser)` 조건문으로 감싸서 브라우저 환경에서만 실행되도록 합니다. `export const ssr = false;` 및 `prerender = false;` 설정도 고려합니다.
- **대용량 데이터 스트리밍**: `load` 함수에서 프로미스를 반환하여 데이터를 스트리밍하면 인지 성능을 향상시킬 수 있습니다. 그러나 LCP에 중요한 콘텐츠는 스트리밍을 피하고, 과도한 스트리밍은 UI 불일치를 야기할 수 있으므로 전략적으로 적용합니다.
- **`onDestroy` 및 SSR 호환성**: `onDestroy`는 SSR 과정에서도 실행될 수 있으므로, 브라우저 전용 객체 접근 시 `if (browser)` 조건문을 사용하여 서버 환경에서의 오류를 방지합니다. 메모리 누수 방지를 위해 정리 작업을 철저히 합니다.

### 4. 고급 훅 사용법 및 오류 처리

- **`handle`, `handleError`, `handleFetch` 활용**: 이 서버 훅들은 요청 처리 과정을 정교하게 제어할 수 있지만, 오용 시 디버깅하기 어려운 문제를 야기할 수 있습니다. `event.locals` 관리, 오류 로깅, API 요청 가로채기 등에 신중하게 사용합니다.
- **`sequence` 헬퍼**: 여러 `handle` 훅을 순서대로 실행하여 코드 모듈성을 높일 수 있습니다. 그러나 훅 간의 복잡한 상호작용이나 숨겨진 의존성에 주의하고, 각 훅이 명확한 책임을 가지도록 설계합니다.
- **예상된/예기치 않은 오류 구분**: `error()` 함수로 발생시킨 예상된 오류는 `handleError` 훅을 거치지 않고 `+error.svelte` 컴포넌트를 렌더링합니다. `try...catch` 블록에서 `error()`로 발생된 오류를 "삼키지" 않도록 주의하고, 두 가지 오류 유형의 처리 경로를 명확히 이해합니다.

### 5. UI 일관성 및 비동기 작업

- **`{#await}` 블록 및 `<svelte:boundary>`**: `{#await}` 블록은 프로미스 처리를 간소화하지만, 경쟁 조건이나 UI 불일치를 야기할 수 있습니다. Svelte 5의 `<svelte:boundary>`는 비동기 UI를 통합 관리하는 데 도움이 되지만, 룬과의 상호작용이나 오류 전파 방식에 주의해야 합니다.
- **`tick()` 함수의 오용**: `tick()` 함수는 DOM 업데이트 후 로직 실행에 유용하지만, 남용 시 코드를 복잡하게 만들고 성능 저하를 야기할 수 있습니다. Svelte 5의 `$derived`, `$effect` 룬으로 인해 필요성이 줄어들었으므로, 최후의 수단으로 사용하고 반응성 로직을 재검토합니다.

### 6. 대규모 SvelteKit 프로젝트의 확장성 문제

- **개발자 경험(DX) 저하**: 수천 개의 컴포넌트와 수십만 라인 코드의 대규모 프로젝트에서 Svelte Language Server 초기화 지연, 자동 완성 기능 저하, 높은 RAM 사용량, 빌드/개발 서버 시작 지연 등 IDE 및 빌드 성능 문제가 보고되었습니다.
- **해결책**: 프로젝트 구조화, 개발자 하드웨어 업그레이드, 더 빠른 빌드 도구(esbuild, swc, rspack)에서의 Svelte 지원 진행 상황 추적 등 완화 전략을 모색해야 합니다. JS/TS 도구 생태계의 잠재적 약점을 인지하고 장기 프로젝트 계획 시 고려합니다.

## Hono 개발 시 주의사항

Hono는 경량성과 빠른 속도를 자랑하지만, 복잡한 API 구축 시 미들웨어 처리, 컨텍스트 관리, 보안 등에서 주의가 필요합니다.

### 1. 미들웨어 복잡성 탐색

- **실행 순서 마스터하기**: Hono 미들웨어는 "양파 모델"을 따르며, `app.use()` 순서대로 요청 단계에서 위에서 아래로, 응답 단계에서 아래에서 위로 실행됩니다. 오류 핸들러, 유효성 검사, 로깅 등 미들웨어 간 상호 의존성을 고려한 정교한 순서 배치가 중요합니다. `await next()`를 사용하여 비동기 미들웨어의 실행 흐름을 올바르게 제어합니다.
- **타입 안전성 및 `BlankEnv` 회피**: `createMiddleware` 체이닝 시 사용자 정의 컨텍스트 타입이 손실되고 `BlankEnv`로 되돌아가는 문제가 발생할 수 있습니다. `new Hono<UserContext>()`와 같은 Hono 인스턴스 타입 지정이나 `ContextVariableMap` 확장을 고려하되, 런타임 `undefined` 접근 오류를 방지하기 위해 방어적인 코딩 습관을 유지합니다.
- **사용자 정의 유효성 검사 미들웨어**: `@hono/zod-validator`의 `zValidator`는 기본적으로 전체 `ZodError` 객체를 반환하므로, 프로덕션에서는 `hook` 콜백을 사용하여 일관된 오류 응답 형식(예: RFC 7807 Problem Details)을 제공하는 커스텀 유효성 검사 미들웨어를 구축합니다.
- **프로덕션 환경 오류 처리 및 로깅**: `app.onError`를 통해 루트 레벨 오류를 처리하고, 사용자 정의 오류 클래스, 구조화된 오류 응답, 상세 로깅, Sentry 등 외부 모니터링 도구 통합을 통해 프로덕션 등급의 오류 관리 시스템 구축을 고려합니다.

### 2. Hono 컨텍스트 (`c`) 관리 시 주의사항

- **안전한 비동기 수정**: `c.set()`, `c.get()`을 통한 컨텍스트 데이터 공유 시 비동기 미들웨어 간 타이밍 문제에 주의합니다. `AsyncLocalStorage`를 사용하는 `contextStorage()` 미들웨어를 고려할 수 있으나, 이는 논리적 경쟁 조건 자체를 해결하지 않으므로 비동기 작업 완료 순서와 컨텍스트 값 의존 관계를 명확히 이해해야 합니다.
- **`c.set()`, `c.get()`, `c.var` 사용 모범 사례**: `c.var`와 제네릭을 통한 타입 지정(`new Hono<{ Variables: { message: string } }>()`)은 문자열 기반 `c.get()`보다 강력한 타입 안전성을 제공합니다. `ContextVariableMap` 확장은 타입 오류를 숨길 수 있으므로 신중하게 사용하고, 명시적인 타입 관리를 표준으로 삼습니다.

### 3. Hono API 보안 고려 사항

- **기본 인증 이상**: Hono 미들웨어는 인증 로직 구현에 유용하지만, 이를 유일한 보안 계층으로 간주해서는 안 됩니다. "심층 방어" 원칙을 적용하여 라우트 미들웨어 외에 서비스 계층이나 데이터 접근 계층에서 세분화된 권한 부여 로직을 구현합니다. 미들웨어의 우회 가능성, 세분화된 제어의 어려움, 단일 실패 지점 위험을 인지합니다.

### 4. SvelteKit 및 Hono 통합 과제 탐색

- **RPC를 통한 엔드투엔드 타입 안전성**: `hono/client (hc)`를 SvelteKit과 함께 사용하여 타입 안전한 API 호출을 구현합니다. SvelteKit의 `load` 함수나 서버 액션 내에서 `hc` 사용 시 SvelteKit이 제공하는 커스텀 `fetch` 함수를 `hc`에 전달하여 SSR 최적화 및 쿠키/자격 증명 처리를 보장합니다. 모노레포에서 `tsserver` 성능 저하 시, Hono 라우터 타입 직접 추론 대신 OpenAPI 명세 기반 클라이언트 생성이나 타입 미리 컴파일을 고려합니다.
- **아키텍처 결정**: SvelteKit과 Hono를 긴밀하게 결합하는 방식은 초기 개발에 유리하지만, 복잡한 애플리케이션에서는 다중 테넌시, 백그라운드 작업, 다양한 클라이언트 지원 등에서 한계가 있습니다. 별도의 Hono 백엔드를 사용하는 방식은 관심사 분리와 독립적 확장에 유리하지만, 인증 복잡성, 운영 오버헤드, 타입 안전성 손실 가능성이 있습니다. Hono를 마이크로서비스로 활용하는 것은 확장성과 탄력성을 높이지만, 운영 복잡성 증가, 초기 개발 비용 증가, 분산 시스템 문제, 생태계 제약, 과잉 적용 위험이 있습니다. 프로젝트의 현재 및 미래 요구사항을 고려하여 합리적인 아키텍처를 선택합니다.
- **고급 데이터 처리 및 동기화**:
  - **API 응답 스트리밍**: Hono의 `stream()` 헬퍼와 SvelteKit 서버 `load` 함수의 프로미스 반환 기능을 결합하여 대용량 데이터나 실시간 업데이트를 효율적으로 스트리밍하고 인지 성능을 향상시킵니다.
  - **효과적인 캐싱 전략**: Hono 캐싱 미들웨어와 SvelteKit의 내장 캐싱 메커니즘을 포함한 풀스택 캐싱 계층(클라이언트, 애플리케이션, 데이터베이스)을 통합적으로 관리합니다. 캐싱 정책 간의 충돌을 피하고, 데이터 최신성과 성능 목표를 동시에 달성하도록 설계합니다.
  - **프론트엔드 상태 동기화**: 변경 작업 후 `invalidateAll()` 대신 `invalidate(url)`을 사용하여 관련 `load` 함수만 선택적으로 재실행하거나, 낙관적 UI 업데이트, 수동 상태 업데이트를 고려합니다. Hono 백엔드로부터 최신 데이터를 가져와 프론트엔드 상태를 효과적으로 재동기화하는 것이 중요합니다.
- **보안 파일 업로드 및 실시간 통신**:
  - **안전하고 효율적인 파일 업로드**: Hono의 파일 업로드 처리 기능을 활용하되, 클라이언트/서버 양쪽에서 파일 타입/크기 검증, 안전한 파일 저장(웹 루트 외부, 무작위 파일명)을 수행합니다. 대용량 파일은 청크 업로드, 클라이언트 사이드 압축, 웹 워커 활용, 그리고 SvelteKit 액션에서 `request.body`를 Hono 엔드포인트로 직접 스트리밍하는 엔드투엔드 스트리밍을 고려합니다.
  - **WebSocket 통합**: Hono와 SvelteKit 간 WebSocket 통신 구현 시 인증(핸드셰이크 시 쿠키, 연결 수립 후 토큰 전송), 권한 부여, 그리고 특히 서버리스/엣지 환경에서의 상태 관리(Redis, Cloudflare Durable Objects 등 외부 상태 저장소 활용)에 대한 명확한 전략을 수립합니다.
