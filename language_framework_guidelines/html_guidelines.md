# HTML 코딩 가이드라인

HTML은 웹 애플리케이션 구축의 기본이며, 견고하고 유지보수 가능한 코드를 위해 다음 사항들을 준수해야 합니다.

## 1. 문서의 기본 선언 (청사진)

모든 HTML 문서는 브라우저가 올바르게 해석하고 렌더링하도록 다음 기본 선언을 포함해야 합니다.

-   **DOCTYPE 선언**: 항상 `<!DOCTYPE html>`을 문서 최상단에 선언합니다. 누락 시 비표준 모드(quirks mode)로 렌더링될 수 있습니다.
-   **언어 지정 (`lang` 속성)**: `<html>` 요소에 `lang` 속성을 사용하여 문서의 주 언어를 명시합니다 (예: `<html lang="ko">`). 이는 접근성, SEO, 현지화에 중요합니다.
-   **문자 인코딩 (`charset`)**: `<head>` 내에 `<meta charset="utf-8" />`을 정의합니다. UTF-8은 대부분의 문자를 지원하므로 특별한 이유가 없는 한 권장됩니다.
-   **Viewport 설정**: 모바일 반응형 디자인을 위해 `<meta name="viewport" content="width=device-width, initial-scale=1.0">`을 `<head>`에 포함합니다.

## 2. 속성 사용의 정밀성

HTML 속성을 작성할 때 일관되고 정확한 규칙을 따르는 것은 코드의 가독성, 유지보수성, 오류 방지에 중요합니다.

-   **속성값 따옴표**: 항상 큰따옴표(`"`)를 사용하는 것이 좋습니다.
-   **Boolean 속성**: `required`, `checked`, `disabled`와 같은 Boolean 속성은 속성 이름만 적는 것이 올바른 표현입니다 (예: `<input type="checkbox" checked />`).
-   **대소문자 일관성**: DOCTYPE 선언, HTML 요소 이름, 속성 이름 및 값은 모두 소문자로 작성하는 것이 권장됩니다.

## 3. DOM 크기 및 깊이 관리

문서 객체 모델(DOM)의 크기와 깊이는 웹 페이지 성능에 직접적인 영향을 미칩니다.

-   **DOM 크기**: DOM 노드 수가 800개를 초과하면 경고, 1,400개를 초과하면 오류로 간주될 수 있습니다. 큰 DOM은 LCP, INP와 같은 성능 지표에 부정적인 영향을 줍니다.
-   **DOM 깊이 및 자식 요소**: `<body>`로부터 30 레벨 미만을 목표로 하며, 특정 노드에 많은 자식 요소가 집중되지 않도록 합니다.
-   **해결 방안**: 의미 없는 `<div>` 요소의 남용("divitis")을 피하고, CSS Grid나 Flexbox를 활용하여 HTML 구조를 평탄화합니다. 불필요하게 깊게 중첩되거나 중복되는 요소는 피해야 합니다.


## 5. 사용자 정의 데이터 속성 (`data-*` 및 `dataset` API)

HTML5의 `data-*` 속성은 HTML 요소에 스크립트가 사용할 임의의 데이터를 저장하는 표준화된 방법을 제공합니다.

-   **명명 규칙**: HTML 속성 이름은 `data-` 접두사 뒤에 케밥 케이스(kebab-case)를 사용합니다 (예: `data-item-id`). JavaScript `dataset` 속성에서는 카멜 케이스(camelCase)로 변환됩니다 (예: `dataset.itemId`).
-   **사용법**: 요소의 상태 정보, 설정 값, 스크립트가 참조해야 하는 간단한 데이터를 저장하는 데 유용합니다.
-   **주의사항**: `data-*` 속성은 남용되거나 표준 HTML 의미론을 대체하는 용도로 사용되어서는 안 됩니다. 예를 들어, 요소의 역할을 설명하기 위해 `data-role="button"` 대신 실제 `role="button"` ARIA 속성을 사용해야 합니다. 스크립트를 위한 "독점적인 정보"를 저장하는 데 신중하게 사용합니다.

## 5. 시맨틱 HTML 마스터하기

시맨틱 HTML은 웹 페이지의 구조와 콘텐츠에 의미를 부여하여 접근성, SEO, 코드 유지보수성을 향상시킵니다.

### 5.1. "Divitis"의 폐해: 일반 컨테이너의 과용

`<div>` 요소의 과도한 사용("Divitis")은 접근성 저하, SEO 불이익, 코드 유지보수성 악화를 야기합니다. `<div>`는 "다른 적절한 요소가 없을 때 사용하는 최후의 수단"으로 간주해야 합니다.

### 5.2. 의미 있는 콘텐츠 구조화

다음 시맨틱 HTML5 요소를 사용하여 콘텐츠에 명확한 의미를 부여합니다.

-   `<header>`: 페이지 또는 섹션의 소개 콘텐츠 (로고, 제목, 탐색 링크 등).
-   `<footer>`: 페이지 또는 섹션의 마무리 콘텐츠 (저작권 정보, 관련 링크 등).
-   `<nav>`: 주요 탐색 링크 블록 (메뉴, 목차, 색인 등).
-   `<main>`: 문서의 주요하고 고유한 콘텐츠. 페이지 당 하나만 사용합니다.
-   `<article>`: 독립적으로 배포하거나 재사용할 수 있는 자립형 콘텐츠 (블로그 게시물, 뉴스 기사 등).
-   `<section>`: 문서나 애플리케이션의 일반적인 구획. 주로 제목을 포함하는 주제별 그룹화.
-   `<aside>`: 문서의 주요 내용과 간접적으로 관련된 부분 (사이드바, 인용구, 광고 등).

특히 `<article>`은 그 자체로 완전한 콘텐츠 단위이며, `<section>`은 더 큰 문서의 일부로서 특정 주제를 다루는 구획입니다. 시각적 레이아웃이 아닌 콘텐츠의 의미론적 관계에 기반하여 사용해야 합니다.

### 5.3. 제목 계층 구조의 중요성 (`<h1>`-`<h6>`)

HTML 제목 요소는 문서 콘텐츠의 계층적 구조를 정의합니다.

-   **단일 `<h1>`**: 각 페이지에는 주된 내용을 나타내는 최상위 제목으로 `<h1>` 태그를 한 번만 사용합니다.
-   **논리적 순서**: 제목 태그는 `<h1>` 다음 `<h2>`, `<h2>` 다음 `<h3>`와 같이 논리적인 계층 구조를 따라 순차적으로 사용합니다.
-   **의미론적 사용**: 제목 태그는 스타일링 목적이 아닌, 콘텐츠의 구조와 중요도에 따라 의미론적으로 사용해야 합니다.

### 5.4. 파급 효과: 접근성, SEO, 유지보수성에 미치는 영향

시맨틱 HTML의 올바른 사용은 웹사이트의 여러 측면에 긍정적인 영향을 미칩니다.

-   **접근성 향상**: 보조 기술에 명확한 구조적 단서를 제공하여 장애를 가진 사용자가 콘텐츠를 더 쉽게 이해하고 탐색할 수 있도록 돕습니다.
-   **SEO 강화**: 검색 엔진이 콘텐츠 구조와 중요도를 더 잘 파악하여 검색 결과 순위 향상에 기여합니다.
-   **유지보수성 증진**: 가독성이 높아 코드 수정, 기능 추가, 디버깅 등의 유지보수 작업을 효율적으로 만듭니다.

결론적으로, 시맨틱 HTML은 더 접근하기 쉽고, 검색 엔진에 친화적이며, 장기적으로 유지보수하기 용이한 웹사이트를 구축하는 데 필수적인 기본 원칙입니다.

## 6. 설계에 의한 접근성(a11y): 포괄적인 HTML을 위한 핵심 고려 사항

웹 접근성은 모든 사용자가 웹 콘텐츠를 인지하고, 운영하고, 이해하며, 상호작용할 수 있도록 보장하는 것을 목표로 합니다. HTML은 접근성의 기초를 형성하며, 올바른 HTML 작성 관행은 WCAG(Web Content Accessibility Guidelines) 원칙을 준수하는 데 매우 중요합니다.

### 6.1. HTML에서의 WCAG 네 가지 원칙 (POUR)

-   **인지 용이성 (Perceivable)**:
    -   텍스트 아닌 콘텐츠에 대한 텍스트 대안 (예: 이미지 `alt` 속성).
    -   적응 가능한 콘텐츠 구조 (시맨틱 HTML 요소 사용).
-   **운용 용이성 (Operable)**:
    -   키보드 접근성 (모든 기능은 키보드만으로 사용 가능).
    -   탐색 용이성 (명확한 페이지 제목, 시맨틱 HTML을 통한 랜드마크 제공).
-   **이해 용이성 (Understandable)**:
    -   가독성 (`lang` 속성 명시, 명확하고 간결한 언어 사용).
    -   예측 가능성 (일관된 내비게이션 및 페이지 구조).
    -   입력 지원 (명확한 레이블, 입력 형식 지침, 오류 메시지).
-   **견고성 (Robust)**:
    -   호환성 (표준을 준수하는 잘 구성된 HTML, 필요한 경우 ARIA 속성 사용).

### 6.2. ARIA (Accessible Rich Internet Applications): 올바른 사용과 오용

ARIA는 네이티브 HTML만으로는 의미를 충분히 전달하기 어려운 고급 UI 컨트롤의 접근성을 향상시킵니다. 그러나 오용될 경우 오히려 접근성을 해칠 수 있으므로 신중하게 사용해야 합니다.

#### 6.2.1. ARIA 사용의 5가지 기본 규칙

1.  **네이티브 HTML 요소를 우선 사용**: 네이티브 요소로 구현 가능하다면 ARIA 대신 네이티브 요소를 사용합니다.
2.  **네이티브 시맨틱을 변경하지 마라**: HTML 요소가 가진 고유한 의미를 ARIA로 덮어쓰지 않습니다.
3.  **모든 인터랙티브 ARIA 컨트롤은 키보드로 조작 가능해야 한다**: 커스텀 컨트롤은 키보드만으로 완벽하게 작동하도록 구현합니다.
4.  **포커스 가능하고 인터랙티브한 요소에 `role="presentation"` 또는 `aria-hidden="true"`를 사용하지 마라**: 상호작용 가능한 요소를 보조 기술로부터 숨기지 않습니다.
5.   **모든 인터랙티브 요소에는 접근 가능한 이름(accessible name)을 제공하라**: `aria-label`, `aria-labelledby` 또는 텍스트 콘텐츠를 통해 명확한 이름을 제공합니다.

#### 6.2.2. 일반적인 ARIA 함정

-   보이는 텍스트와 다른 `aria-label` 제공.
-   `aria-errormessage`의 낮은 지원율 (대신 `aria-describedby` 고려).
-   잘못되거나 누락된 ID 참조.
-   ARIA 속성 이름 오타.
-   필수 ARIA 구조(부모/자식 관계) 누락.
-   속성 우선순위 오해 (`aria-labelledby`가 `aria-label`보다 우선).
-   `aria-live` 영역 동적 주입 문제 (페이지 로드 시 DOM에 존재하도록).
-   ARIA가 기능을 추가할 것이라는 기대 (기능은 JavaScript로 구현).
-   불필요한 ARIA 추가 (네이티브 HTML이 충분할 때).
-   상호작용 후 ARIA 속성 동적 추가 (초기 상태 명시 필요).

ARIA 사용 시에는 항상 실제 스크린 리더로 테스트하는 것이 중요합니다.

### 6.3. 키보드 내비게이션: 많은 사용자의 생명줄

키보드 접근성은 마우스를 사용할 수 없는 사용자에게 필수적입니다.

-   **포커스 가능 및 조작 가능**: 모든 인터랙티브 요소는 키보드로 포커스를 받고 기능을 실행할 수 있어야 합니다.
-   **`tabindex` 속성**:
    -   `tabindex="0"`: 기본적으로 포커스를 받지 않는 요소에 키보드 포커스를 부여 (JavaScript로 인터랙티브하게 만들어야 함).
    -   `tabindex="-1"`: 탭 순서에서 제외하지만 스크립트를 통해 프로그래밍 방식으로 포커스 가능.
    -   `tabindex > 0` (양수 값): 사용을 피해야 합니다. 논리적인 DOM 순서가 탭 순서가 되도록 마크업을 구성합니다.
-   **보이는 포커스 표시**: 키보드 포커스를 받은 요소는 시각적으로 명확하게 구분되는 표시자를 가져야 합니다 (`:focus` 또는 `:focus-visible`).
-   **논리적인 DOM 순서**: DOM 요소 순서는 시각적 배치 순서와 일치하며 논리적인 흐름을 가져야 합니다.
-   **콘텐츠 건너뛰기 링크**: 페이지 상단에 "메인 콘텐츠로 건너뛰기" 링크를 제공하여 키보드 사용자의 탐색을 돕습니다.

### 6.4. 이미지 접근성: `alt` 텍스트의 힘

`alt` (대체) 텍스트는 시각적으로 이미지를 인지할 수 없는 사용자에게 이미지 정보를 전달하는 핵심 수단입니다.

-   **정보 전달 이미지**: `alt` 속성을 통해 이미지의 목적과 내용을 간결하고 명확하게 전달합니다.
-   **장식용 이미지**: `alt=""` (빈 문자열)로 지정하여 스크린 리더가 무시하도록 합니다.
-   **일반적인 `alt` 텍스트 실수**: 누락, 의미 없음, 지나치게 장황/간략, 불필요한 문구 반복.
-   **복잡한 이미지**: `alt` 텍스트는 간략한 요약만 제공하고, 주변 텍스트나 링크를 통해 상세 설명을 제공합니다.
-   **텍스트가 포함된 이미지**: 중요한 텍스트 정보는 이미지 내에 포함하지 않도록 피합니다.

### 6.5. 양식 접근성: 레이블, 그룹화, 오류 처리

온라인 양식은 접근성을 고려하여 제작되어야 합니다.

-   **명시적인 레이블 (`<label>`)**: 모든 양식 컨트롤에 `for` 속성을 사용하여 `<label>` 요소를 명시적으로 연결합니다. `placeholder`를 레이블 대용으로 사용하지 않습니다.
-   **관련 컨트롤 그룹화 (`<fieldset>`, `<legend>`)**: 관련된 양식 컨트롤을 `<fieldset>`으로 그룹화하고 `<legend>`로 목적을 설명합니다.
-   **명확한 오류 식별 및 안내**: 오류 발생 시 어떤 필드에 오류가 있는지 명확히 표시하고, 원인과 해결 방법을 구체적으로 안내합니다.

## 7. 최고 성능을 위한 HTML 최적화

HTML 구조와 리소스 로딩 방식은 웹 페이지 성능에 큰 영향을 미칩니다.

### 7.1. 효율적인 리소스 로딩 전략

#### 7.1.1. HTTP 요청 최소화

브라우저가 웹 페이지를 렌더링하기 위해 서버에 보내는 HTTP 요청 수를 줄입니다.

-   **파일 결합**: 여러 CSS/JavaScript 파일을 하나로 결합합니다.
-   **CSS 스프라이트**: 여러 작은 이미지를 하나의 큰 이미지 파일로 통합합니다.
-   **인라인 SVG**: 간단한 아이콘/그래픽은 HTML에 직접 인라인으로 삽입합니다.

#### 7.1.2. 스크립트 로딩 최적화: `async`, `defer`, 그리고 배치

JavaScript 파일의 파서 차단(parser-blocking)을 방지하여 페이지 렌더링 지연을 줄입니다.

-   **스크립트 배치**: 중요하지 않은 스크립트는 `<body>` 태그 닫히기 직전에 배치합니다.
-   **`async` 속성**: HTML 파싱과 병행하여 스크립트를 다운로드하고 즉시 실행합니다. 독립적인 스크립트에 적합합니다.
-   **`defer` 속성**: HTML 파싱과 병행하여 스크립트를 다운로드하지만, HTML 파싱이 끝난 후 `DOMContentLoaded` 이벤트 직전에 순서대로 실행합니다. DOM 조작이나 스크립트 실행 순서가 중요한 경우에 유용합니다.

#### 7.1.3. 파서 차단 및 지연 발견 리소스 방지

브라우저의 리소스 발견을 지연시키거나 파싱을 중단시키는 패턴을 피합니다.

-   **파서 차단 리소스**: `async`나 `defer` 속성이 없는 동기식 `<script>` 태그를 피합니다.
-   **지연 발견 리소스**: CSS `background-image`, JavaScript로 동적으로 삽입되는 `<script>` 태그, CSS `@import` 선언 등을 피하거나 `<link rel="preload">`를 사용합니다.

#### 7.1.4. `<link rel="preload">`를 사용한 중요 에셋 사전 로드

브라우저에게 특정 리소스가 현재 페이지에 중요하며 가능한 한 빨리 가져와야 함을 알립니다.

-   예: `<link rel="preload" href="critical.css" as="style">`
-   `as` 속성으로 리소스 유형을 명시하여 올바른 우선순위를 설정합니다.

#### 7.1.5. 중요 CSS 인라인 처리

페이지의 초기 렌더링에 필수적인 CSS 규칙들을 HTML 문서의 `<head>` 내 `<style>` 태그 안에 직접 인라인으로 삽입하여 FCP 및 LCP를 개선합니다.

-   **장점**: 별도의 네트워크 요청 제거.
-   **단점**: HTML 문서 크기 증가, 캐싱 이점 상실. 최소한의 중요 CSS만 인라인 처리하고 자동화 도구를 활용합니다.

성능 최적화는 여러 요소 간의 균형을 맞추는 과정이며, 초기 계획 단계부터 성능 예산을 설정하고 리소스 감사를 수행하는 것이 중요합니다.

### 7.2. HTML에서의 이미지 최적화 기법

이미지 최적화는 웹 페이지 성능 향상에 매우 중요하며, HTML은 다양한 기법을 지원합니다.

#### 7.2.1. 반응형 이미지: `<picture>`, `srcset`, `sizes`

다양한 화면 크기와 해상도에 최적화된 이미지를 제공합니다.

-   **`<picture>` 요소**: "아트 디렉션"을 위해 사용되며, 뷰포트 크기나 조건에 따라 완전히 다른 이미지를 보여줄 때 유용합니다. `<source>` 요소와 `<img>` 요소를 포함합니다.
-   **`<img>` 요소의 `srcset` 및 `sizes` 속성**: "해상도 전환"을 위해 사용되며, 동일한 이미지를 다양한 크기나 해상도로 제공하여 브라우저가 가장 적절한 파일을 선택하도록 합니다.
    -   `srcset`: 다양한 이미지 파일 경로와 해당 이미지의 너비 또는 픽셀 밀도를 나열합니다.
    -   `sizes`: 미디어 조건과 해당 조건에서 이미지가 차지할 레이아웃 너비를 명시합니다.

#### 7.2.2. 지연 로딩: `loading="lazy"` 및 `preload="none"`

페이지 초기 로드 시 화면에 보이지 않는 이미지나 iframe의 로딩을 지연시킵니다.

-   **`loading="lazy"` 속성**: `<img>` 및 `<iframe>` 요소에 추가하여 브라우저가 자동으로 지연 로딩을 처리하도록 합니다.
-   **`<video>`의 `preload="none"`**: 비디오 콘텐츠의 사전 로드를 방지하여 성능을 향상시킵니다.

#### 7.2.3. 레이아웃 이동 방지: 이미지 크기 명시

이미지가 로드되면서 페이지 레이아웃이 갑자기 변경되는 현상(Layout Shift, CLS)을 방지합니다.

-   **`width` 및 `height` 속성**: `<img>` (및 가능한 경우 `<video>`, `<iframe>`) 요소에 `width`와 `height` 속성을 명시하여 브라우저가 이미지 공간을 미리 확보하도록 합니다.


### 7.3. `<iframe>` 딜레마: 성능 고려 사항

`<iframe>` 요소는 성능에 상당한 영향을 미칠 수 있으므로 신중하게 사용해야 합니다.

-   **사용 최소화**: 반드시 필요한 경우가 아니라면 `<iframe>` 사용을 피하고, `fetch()` API와 DOM 스크립팅을 통한 콘텐츠 로드를 고려합니다.
-   **지연 로딩**: 화면 밖에 있는 `<iframe>`의 경우 `loading="lazy"` 속성을 적용하여 초기 페이지 로드 성능에 미치는 영향을 줄입니다.
-   **주의 사항**: `<iframe>` 내 콘텐츠는 부모 페이지와 별도로 처리되며, 캐시된 자산을 공유하지 못할 수 있습니다.

## 8. 최신 HTML5 기능의 올바른 활용

HTML5는 웹 개발의 가능성을 확장하는 다양하고 강력한 기능들을 도입했습니다.

### 8.1. 리치 미디어 통합: `<audio>` 및 `<video>`

`<audio>` 및 `<video>` 태그를 사용하여 오디오 및 비디오 콘텐츠를 네이티브하게 임베딩합니다.

-   **기본 사용법**: `src` 속성과 `controls` 속성을 사용합니다.
-   **`<source>` 요소**: 다양한 브라우저 호환성을 위해 여러 파일 형식을 제공할 수 있습니다.
-   **주요 속성**: `controls`, `autoplay` (음소거 상태에서 신중하게 사용), `loop`, `muted`, `poster` (비디오 미리보기 이미지), `preload` (대역폭 절약을 위해 `none` 또는 `metadata` 고려).
-   **접근성**: 자막, 설명, 스크립트 등을 `<track>` 요소를 통해 제공하여 접근성을 보장합니다.

### 8.2. 시맨틱 미디어 그룹화: `<figure>` 및 `<figcaption>`

`<figure>`와 `<figcaption>` 요소는 이미지, 다이어그램, 코드 스니펫 등 독립적으로 분리될 수 있는 콘텐츠 단위를 시맨틱하게 그룹화하고 설명을 제공합니다.

-   **`<figure>`**: 독립적인 콘텐츠 단위를 감쌉니다.
-   **`<figcaption>`**: `<figure>` 요소 내부에 위치하며, 해당 `<figure>` 콘텐츠에 대한 캡션(설명)을 제공합니다.

이러한 마크업은 콘텐츠와 설명 간의 의미론적 관계를 명확하게 나타내어 보조 기술 사용자나 검색 엔진이 콘텐츠를 더 잘 이해하도록 돕습니다.

### 8.3. 향상된 양식: 새로운 입력 유형 및 속성

HTML5는 사용자 경험 개선 및 클라이언트 측 유효성 검사를 위해 다양한 새로운 입력 유형과 속성을 도입했습니다.

-   **새로운 입력 유형**: `email`, `url`, `tel`, `number`, `date`, `time`, `datetime-local`, `month`, `week`, `range`, `color`, `search` 등.
-   **새로운 속성**: `placeholder`, `required`, `pattern`, `autofocus`, `autocomplete`, `multiple`, `formaction` 등.
-   **주의사항**: `placeholder`를 `label` 대용으로 사용하지 않으며, 클라이언트 측 유효성 검사는 보안을 위한 것이 아니므로 서버 측 유효성 검사가 필수적입니다.

### 8.4. 인터랙티브한 정보 공개: `<details>` 및 `<summary>`

사용자가 추가 정보를 보거나 숨길 수 있는 네이티브 HTML 인터랙티브 위젯("아코디언" 또는 "토글")을 만듭니다.

-   **`<details>`**: 숨겨진 추가 정보를 담는 컨테이너. `open` 속성으로 초기 상태를 제어합니다.
-   **`<summary>`**: `<details>`의 첫 번째 자식으로, 항상 보이는 제목 역할을 합니다.

JavaScript 없이 간단한 정보 공개 기능을 구현하고 기본적으로 접근성을 지원합니다.

### 8.5. 진행 상태 표현: `<progress>` 및 `<meter>`

작업의 진행 상태나 특정 범위 내의 측정값을 시맨틱하게 표현합니다.

-   **`<progress>` 요소**: 작업의 완료 진행률을 나타냅니다 (`value`, `max` 속성). `value`가 없으면 불확정 진행 상태를 나타냅니다.
-   **`<meter>` 요소**: 알려진 범위 내에서의 스칼라 측정값 또는 백분율 값을 나타냅니다 (`value`, `min`, `max`, `low`, `high`, `optimum` 속성).

`<progress>`는 '완료' 과정을, `<meter>`는 특정 시점의 '양'이나 '수준'을 나타냅니다.
