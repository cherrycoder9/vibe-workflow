# SvelteKit 개발 시 주의사항

SvelteKit은 생산성과 성능이 뛰어나지만, 대규모 프로젝트나 고급 기능 사용 시 예상치 못한 문제가 발생할 수 있습니다. 특히 SSR 환경에서의 상태 관리, 폼 처리, 성능 최적화, 훅 사용법, UI 일관성 및 대규모 프로젝트 확장성 측면에서 주의가 필요합니다.

## Svelte 컴포넌트 주석

Svelte 컴포넌트에는 일반 HTML 주석 외에 `@component` 주석을 활용하여 IDE에서 컴포넌트에 대한 설명을 표시할 수 있습니다. 이는 협업과 유지보수에 유리합니다.

- **예시**:

  ```svelte
  <!--
    @component
    이 컴포넌트는 사용자 프로필 정보를 표시합니다.
    @param {string} name - 사용자의 이름
    @param {number} age - 사용자의 나이
  -->
  <script>
    export let name;
    export let age;
  </script>

  <div>
    <h1>{name}</h1>
    <p>{age}세</p>
  </div>
  ```

## 1. SSR에서의 상태 관리

- **전역 싱글톤 스토어 위험**: SSR 환경에서 `writable` 스토어를 최상위 레벨에서 선언하면 모든 사용자 요청 간에 공유되어 데이터 유출 위험이 있습니다.
  - **해결책**: `getContext`, `setContext`를 사용하여 요청별로 스토어를 스코핑하거나, `onMount`에서 컴포넌트 인스턴스별로 초기화합니다. Svelte 5 룬 사용 시에도 스코핑에 주의합니다.
- **`event.locals` 및 `stuff` 데이터 불일치**: `event.locals` 데이터는 서버 요청 처리 중에만 유효하며, 클라이언트 네비게이션 시 자동 업데이트되지 않아 오래된 데이터 문제가 발생할 수 있습니다.
  - **해결책**: `invalidate` 함수로 `load` 함수를 명시적으로 재실행하거나, Svelte 스토어를 활용하여 클라이언트 상태와 서버 데이터를 동기화합니다.
- **반응성 누락**: 객체/배열의 내부 속성 변경 시 Svelte의 할당 기반 반응성으로 인해 UI 업데이트가 누락될 수 있습니다.
  - **해결책**: 변경 후 객체/배열을 재할당(`obj = obj;`, `arr = [...arr, item];`)하거나, Svelte 5의 `$state` 룬을 올바르게 사용합니다. 불필요한 재렌더링을 피하고 `{#each}` 블록에서 `key`를 올바르게 사용합니다.

## 2. 견고한 폼 처리 및 액션

- **서버 측 유효성 검사 필수**: 클라이언트 측 유효성 검사는 우회될 수 있으므로, `Zod`와 같은 라이브러리를 사용하여 서버 측에서 반드시 유효성 검사를 수행합니다. "클라이언트를 신뢰하지 말라"는 원칙을 준수합니다.
- **`fail()`을 통한 우아한 오류 처리**: 서버 액션 실패 시 `fail(status, data)` 함수를 사용하여 오류 메시지와 유효했던 입력값을 클라이언트에 반환하여 사용자 경험을 개선합니다. 웹 접근성(`aria-invalid`, `aria-describedby`)도 고려합니다.
- **리디렉션 및 오류 전파 주의**: `throw redirect()`나 `error()` 함수는 SvelteKit의 제어 흐름을 변경하므로, `try...catch` 블록에서 이들을 "삼키지(swallow)" 않도록 주의합니다. SvelteKit의 독특한 오류 처리 메커니즘을 이해해야 합니다.
- **CSRF 및 입력값 신뢰**: SvelteKit은 기본 CSRF 보호를 제공하지만, `+server.js` API 라우트나 특정 요구사항에 따라 추가적인 사용자 정의 CSRF 미들웨어 구현을 고려합니다. 입력값은 항상 검증하고, 프레임워크의 기본 보안 기능에만 의존하지 않습니다.

## 3. SSR 및 성능 최적화

- **`load` 함수의 실행 컨텍스트 및 직렬화**: `load` 함수는 서버/클라이언트 양쪽에서 실행될 수 있으며, 서버 `load` 함수에서 반환되는 데이터는 반드시 직렬화 가능해야 합니다. 함수, `Date` 객체, 클래스 인스턴스 등은 직렬화 오류를 일으킬 수 있으므로 변환이 필요합니다.
- **하이드레이션 문제**: 프리렌더링된 페이지에서 `window`, `document` 등 브라우저 전역 객체에 접근 시 오류가 발생할 수 있습니다. 브라우저 전용 API는 `onMount`나 `if (browser)` 조건문으로 감싸서 브라우저 환경에서만 실행되도록 합니다. `export const ssr = false;` 및 `prerender = false;` 설정도 고려합니다.
- **대용량 데이터 스트리밍**: `load` 함수에서 프로미스를 반환하여 데이터를 스트리밍하면 인지 성능을 향상시킬 수 있습니다. 그러나 LCP에 중요한 콘텐츠는 스트리밍을 피하고, 과도한 스트리밍은 UI 불일치를 야기할 수 있으므로 전략적으로 적용합니다.
- **`onDestroy` 및 SSR 호환성**: `onDestroy`는 SSR 과정에서도 실행될 수 있으므로, 브라우저 전용 객체 접근 시 `if (browser)` 조건문을 사용하여 서버 환경에서의 오류를 방지합니다. 메모리 누수 방지를 위해 정리 작업을 철저히 합니다.

## 4. 고급 훅 사용법 및 오류 처리

- **`handle`, `handleError`, `handleFetch` 활용**: 이 서버 훅들은 요청 처리 과정을 정교하게 제어할 수 있지만, 오용 시 디버깅하기 어려운 문제를 야기할 수 있습니다. `event.locals` 관리, 오류 로깅, API 요청 가로채기 등에 신중하게 사용합니다.
- **`sequence` 헬퍼**: 여러 `handle` 훅을 순서대로 실행하여 코드 모듈성을 높일 수 있습니다. 그러나 훅 간의 복잡한 상호작용이나 숨겨진 의존성에 주의하고, 각 훅이 명확한 책임을 가지도록 설계합니다.
- **예상된/예기치 않은 오류 구분**: `error()` 함수로 발생시킨 예상된 오류는 `handleError` 훅을 거치지 않고 `+error.svelte` 컴포넌트를 렌더링합니다. `try...catch` 블록에서 `error()`로 발생된 오류를 "삼키지" 않도록 주의하고, 두 가지 오류 유형의 처리 경로를 명확히 이해합니다.

## 5. UI 일관성 및 비동기 작업

- **`{#await}` 블록 및 `<svelte:boundary>`**: `{#await}` 블록은 프로미스 처리를 간소화하지만, 경쟁 조건이나 UI 불일치를 야기할 수 있습니다. Svelte 5의 `<svelte:boundary>`는 비동기 UI를 통합 관리하는 데 도움이 되지만, 룬과의 상호작용이나 오류 전파 방식에 주의해야 합니다.
- **`tick()` 함수의 오용**: `tick()` 함수는 DOM 업데이트 후 로직 실행에 유용하지만, 남용 시 코드를 복잡하게 만들고 성능 저하를 야기할 수 있습니다. Svelte 5의 `$derived`, `$effect` 룬으로 인해 필요성이 줄어들었으므로, 최후의 수단으로 사용하고 반응성 로직을 재검토합니다.

## 6. 대규모 SvelteKit 프로젝트의 확장성 문제

- **개발자 경험(DX) 저하**: 수천 개의 컴포넌트와 수십만 라인 코드의 대규모 프로젝트에서 Svelte Language Server 초기화 지연, 자동 완성 기능 저하, 높은 RAM 사용량, 빌드/개발 서버 시작 지연 등 IDE 및 빌드 성능 문제가 보고되었습니다.
- **해결책**: 프로젝트 구조화, 개발자 하드웨어 업그레이드, 더 빠른 빌드 도구(esbuild, swc, rspack)에서의 Svelte 지원 진행 상황 추적 등 완화 전략을 모색해야 합니다. JS/TS 도구 생태계의 잠재적 약점을 인지하고 장기 프로젝트 계획 시 고려합니다.
