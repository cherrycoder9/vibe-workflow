# SvelteKit (Svelte 5) 사용 가이드라인

Svelte 5의 룬(Runes) 시스템은 기존 반응성 모델을 근본적으로 변화시켰다. 이는 코드의 명확성을 높이고 일관된 반응성을 제공하지만, 새로운 학습 곡선과 오해의 소지가 있다.

## 1. 반응성(Reactivity) 메커니즘 이해

**오해:** Svelte 4의 암묵적 반응성에서 Svelte 5의 명시적, 런타임 강화 반응성(룬 기반)으로 전환된 핵심 원리를 이해하지 못하고 코드를 작성하는 경우. `$state` 객체/배열 내부 속성 변경 시 반응성을 기대하지 못하거나, `$derived`를 순수 함수가 아닌 부수 효과(side effect)를 포함하는 함수로 사용, `$effect` 사용 후 정리(cleanup) 함수를 반환하지 않아 메모리 누수 발생.

**주의사항:**
*   룬은 Svelte의 반응성 시스템을 더욱 명시적이고 예측 가능하게 만든다.
*   `$state`: 상태의 근원.
*   `$derived`: 파생된 읽기 전용 상태. 항상 순수 함수여야 하며, 입력 값에만 의존하여 결과를 반환해야 한다. 복잡한 파생 로직은 여러 개의 작은 `$derived`로 분리하거나 일반 함수로 추출 후 `$derived`에서 호출.
*   `$effect`: 상태 변화에 따른 부수 효과. 반환 값이 없으며, 오직 부수 효과 실행에만 집중해야 한다. DOM 이벤트 리스너 등록, 타이머 설정, 외부 라이브러리 연동 등 부수 효과 발생 후 컴포넌트 소멸 시 해당 효과를 정리하는 함수를 반드시 반환해야 한다.

## 2. `$state`의 적절한 사용

**오해:** SSR(서버 사이드 렌더링) 환경에서 모듈 최상위 스코프에 `$state`를 선언하여 여러 사용자 요청 간에 상태가 공유되는 데이터 유출 문제 야기. TypeScript 사용 시 `$state` 변수의 타입을 명시적으로 지정하지 않거나 잘못된 방식으로 재할당하여 타입 에러 또는 반응성 문제 발생.

**주의사항:**
*   전역 상태 관리가 필요하다면 요청별로 격리되는 컨텍스트 API나 스토어 패턴을 고려해야 한다.
*   `$state`를 모듈 수준에서 사용할 때는 SSR의 특성을 반드시 이해하고, 상태가 요청 간에 격리되도록 설계해야 한다.
*   TypeScript 사용 시 룬으로 선언된 변수의 타입 추론에 의존하기보다 명시적인 타입 정의를 통해 코드의 안정성을 높이는 것이 권장된다.

## 3. `$props` 및 `$bindable`의 올바른 사용

**오해:** `$props()` 룬으로 변경된 컴포넌트 props 선언 방식을 TypeScript와 함께 사용할 때 적절한 타입 인터페이스를 정의하지 않거나 잘못된 방식으로 구조 분해 할당하여 타입 안정성을 해침. 양방향 바인딩이 필요한 prop에 `$bindable` 룬을 사용해야 함을 인지하지 못하거나 잘못 적용.

**주의사항:**
*   `$props()`를 사용할 때는 반드시 해당 props의 타입을 정의하는 인터페이스를 작성하고, 구조 분해 할당 시 해당 타입을 명시해야 한다. 예: `let { propName }: PropsInterface = $props();`
*   양방향 바인딩이 필요한 prop은 `let { value = $bindable(initialValue) }: PropsInterface = $props();`와 같이 `$bindable`을 사용하여 명시적으로 선언해야 한다.

## 4. 데이터 로딩 (load 함수)의 효율적 관리

SvelteKit의 `load` 함수는 라우트 진입 전에 데이터를 미리 로드하는 핵심 기능이지만, 서버 `load`와 유니버설 `load`의 역할을 혼동하거나 비효율적으로 사용하면 성능 저하 및 보안 문제를 야기할 수 있다.

### 서버 load와 유니버설 load의 혼동

**함정:** 민감한 데이터 접근이나 데이터베이스 직접 쿼리와 같이 반드시 서버에서만 실행되어야 하는 로직을 유니버설 `load` 함수(`+page.js` 또는 `+layout.js`)에 구현하거나, 반대로 순수하게 클라이언트 측 상태 초기화나 UI 로직을 서버 `load` 함수(`+page.server.js` 또는 `+layout.server.js`)에서 처리하려는 경우. 이는 불필요한 서버 부하를 유발하거나 보안에 취약점을 만들 수 있다.

**주의사항:**
*   데이터베이스 접근, 파일 시스템 조작, 비공개 API 키 사용 등은 반드시 서버 `load` 함수에서 수행해야 한다. 서버 `load` 함수는 직렬화 가능한 데이터만 반환해야 한다.
*   공개 API 호출, 서버 `load`에서 받은 데이터 가공, 컴포넌트 생성자 반환 등은 유니버설 `load`에서 처리할 수 있다.
*   두 함수가 공존할 경우 서버 `load`가 먼저 실행되고 그 결과가 유니버설 `load`로 전달됨을 이해해야 한다.

### 데이터 페칭 워터폴(Waterfall) 발생

**함정:** `load` 함수 내에서 여러 비동기 데이터 요청을 순차적으로 `await` 하거나, `await parent()`를 부적절하게 사용하여 부모 `load` 함수의 완료를 기다리는 과정에서 데이터 로딩이 병렬적으로 처리되지 못하고 순차적으로 지연되는 워터폴 현상이 발생하는 경우. 이는 페이지 로딩 시간을 크게 증가시킬 수 있다.

**주의사항:**
*   여러 독립적인 데이터 소스로부터 데이터를 가져와야 할 경우, `Promise.all`이나 `Promise.allSettled`를 사용하여 병렬로 요청을 보내고 한 번에 결과를 기다리는 패턴을 사용해야 한다.
*   SvelteKit은 기본적으로 `load` 함수들을 병렬 실행하려고 시도하지만, 함수 내부의 로직이 순차적이면 효과가 없다.

### 캐싱 및 데이터 무효화(Invalidation) 전략 부재

**함정:** `load` 함수에서 가져온 데이터에 대해 적절한 HTTP 캐싱 헤더(`Cache-Control`, `ETag` 등)를 설정하지 않아 불필요한 반복 요청이 발생하거나, 반대로 너무 공격적인 캐싱으로 인해 데이터가 업데이트되지 않는 문제가 발생하는 경우. 또한, 데이터 변경 후 `invalidateAll()`이나 특정 URL에 대한 `invalidate(url)` 함수를 적절히 사용하지 않아 클라이언트 측에 캐시된 데이터가 최신 상태로 갱신되지 않는 경우.

**주의사항:**
*   `load` 함수 내에서 `setHeaders`를 사용하여 응답에 캐싱 관련 HTTP 헤더를 명시적으로 설정해야 한다.
*   데이터 변경이 발생했을 때는 해당 데이터에 의존하는 `load` 함수들이 다시 실행되도록 `invalidate` 함수를 적절히 호출하여 클라이언트 데이터를 최신 상태로 유지해야 한다.

### load 함수 내 에러 처리 미흡

**함정:** 데이터 페칭 중 발생할 수 있는 네트워크 오류나 API 오류 등을 `load` 함수 내에서 제대로 처리하지 않거나, `@sveltejs/kit`에서 제공하는 `error` 헬퍼 함수를 사용하지 않고 일반 `Error` 객체를 `throw`하여 SvelteKit의 에러 처리 메커니즘을 제대로 활용하지 못하는 경우. 이로 인해 사용자에게 적절한 오류 페이지가 표시되지 않거나, 민감한 에러 정보가 노출될 위험이 있다.

**주의사항:**
*   `load` 함수 내에서 `fetch` 요청 시 `try...catch` 블록을 사용하여 예외를 처리하고, 예상된 오류(예: "찾을 수 없음")에 대해서는 `error(statusCode, message)` 헬퍼를 사용하여 명시적인 HTTP 상태 코드와 메시지를 전달해야 한다. 이를 통해 SvelteKit은 가장 가까운 `+error.svelte` 컴포넌트를 렌더링한다.

## 5. 비효율적인 폼 핸들링 및 액션

SvelteKit의 폼 액션은 서버와의 상호작용을 간결하게 만들지만, 기본 액션과 명명된 액션의 혼용, 프로그레시브 인핸스먼트의 오해, 서버 사이드 유효성 검사 미흡 등은 문제를 일으킬 수 있다.

### 기본(Default) 액션과 명명된(Named) 액션의 혼용 문제

**함정:** 하나의 라우트(`+page.server.js`) 내에 기본 POST 액션(이름 없는 `export const actions = { default: async () => {...} }`)과 여러 개의 명명된 POST 액션(예: `export const actions = { updateName: async () => {...}, deleteAccount: async () => {...} }`)을 함께 정의하려고 시도하는 경우. SvelteKit은 이를 허용하지 않는다. 또한, 명명된 액션을 사용한 후 명시적으로 리디렉션(`redirect`)을 하지 않으면, 폼 제출 시 사용된 쿼리 파라미터가 URL에 남아있게 되어 이후 동일 페이지에서 기본 POST 요청(만약 다른 방식으로 트리거된다면)이나 페이지 새로고침 시 의도치 않은 동작을 유발할 수 있다.

**주의사항:**
*   하나의 라우트 파일에는 기본 액션 하나만을 사용하거나, 여러 개의 명명된 액션들만을 사용해야 한다.
*   명명된 액션 처리 후에는 일반적으로 `redirect`를 사용하여 사용자를 다른 페이지로 안내하거나, 현재 페이지를 다시 로드하여 URL을 정리하는 것이 좋다.
*   프로그레시브 인핸스먼트를 사용할 경우, `enhance` 콜백 내에서 URL을 수동으로 정리하거나 상태를 업데이트하여 이러한 문제를 회피할 수도 있다.

### 프로그레시브 인핸스먼트(`use:enhance`)의 오해 또는 미활용

**함정:** `use:enhance` 액션을 폼에 적용했을 때의 기본 동작(폼 요소 리셋, `invalidateAll()` 호출로 인한 모든 `load` 함수 재실행 등)을 정확히 이해하지 못하고 사용하는 경우. 특히, 커스텀 콜백 함수를 `use:enhance`에 제공하면서 콜백 내에서 `update` 함수를 호출하지 않아 SvelteKit의 기본 폼 처리 로직(에러 메시지 표시, `form` prop 업데이트 등)이 누락되는 경우가 있다. 또한, `applyAction` 함수를 부적절하게 사용하여 의도치 않은 데이터 업데이트나 에러 처리가 발생할 수도 있다. 근본적으로 JavaScript 없이도 폼이 정상적으로 동작해야 한다는 프로그레시브 인핸스먼트의 기본 원칙을 간과하고 JavaScript에만 의존적인 폼을 설계하는 것도 문제이다.

**주의사항:**
*   `use:enhance`를 사용할 때는 기본 동작 방식을 숙지해야 한다.
*   커스텀 로직이 필요하여 콜백 함수를 제공할 경우, 콜백 내에서 `update` 함수나 `applyAction` 함수를 상황에 맞게 적절히 호출하여 SvelteKit의 내장 기능을 활용해야 한다.
*   가장 중요한 것은, 항상 JavaScript가 비활성화된 환경에서도 폼이 정상적으로 제출되고 서버에서 처리될 수 있도록 기본 HTML 폼 기능을 기반으로 설계해야 한다는 점이다.

### 서버 사이드 유효성 검사 및 에러 처리 미흡

**함정:** 사용자 입력값에 대한 유효성 검사를 클라이언트 사이드에서만 수행하고, 정작 중요한 서버 사이드 유효성 검사를 누락하는 경우. 또는 서버 액션 함수에서 유효성 검사 실패 시, `@sveltejs/kit`의 `fail(status, data)` 함수를 사용하여 사용자에게 유효성 검사 오류를 명확하게 전달하는 표준적인 방법을 사용하지 않고, 임의의 방식으로 에러를 처리하여 SvelteKit이 제공하는 `form` prop 업데이트와 같은 내장 기능을 제대로 활용하지 못하는 경우.

**주의사항:**
*   모든 사용자 입력은 반드시 서버 사이드에서 다시 한번 유효성을 검사해야 한다. 이는 보안의 기본 원칙이다.
*   유효성 검사에 실패했을 경우, `fail(status, data)` 함수를 사용하여 HTTP 상태 코드(일반적으로 400 또는 422)와 함께 오류 메시지, 사용자가 이전에 입력했던 값 등을 포함한 데이터를 클라이언트로 반환해야 한다.
*   클라이언트 컴포넌트에서는 `export let form;`을 통해 이 `form` prop을 받아 사용자에게 적절한 피드백을 제공해야 한다.

### 액션 URL 및 데이터 직렬화 문제

**함정:** 폼의 `action` 속성에 URL을 잘못 지정하는 경우. 예를 들어, 현재 페이지가 아닌 다른 페이지의 특정 명명된 액션을 호출하고자 할 때 URL 경로 뒤에 `?/actionName`과 같은 접두사나 명명 규칙을 누락하는 경우. 또한, `fetch` API를 사용하여 수동으로 폼 데이터를 서버 액션으로 전송하고 응답을 받을 때, 응답 본문에 포함된 `Date`나 `BigInt`와 같은 특수 타입의 데이터가 JavaScript의 `JSON.parse()`로는 올바르게 역직렬화되지 않는데, 이때 SvelteKit이 제공하는 `deserialize` 함수를 사용하지 않아 데이터가 손실되거나 타입 오류가 발생하는 경우. 한편, 하나의 라우트 경로에 `+server.js`(API 라우트)와 `+page.server.js`(페이지 액션)가 공존할 때, 클라이언트에서 `fetch` 요청 시 특별한 헤더 없이 해당 경로로 요청하면 의도치 않게 `+server.js`의 핸들러로 라우팅될 수 있다.

**주의사항:**
*   폼의 `action` URL은 명확하게 지정해야 하며, 특히 다른 라우트의 명명된 액션을 호출할 때는 해당 라우트 경로 뒤에 `?/actionName` 형식을 사용해야 한다.
*   `fetch` API를 직접 사용하여 폼 액션 응답을 처리할 경우에는, 응답 본문을 `$app/forms`에서 제공하는 `deserialize` 함수로 처리하여 모든 데이터 타입을 정확하게 복원해야 한다.
*   `+page.server.js`의 액션으로 `fetch` 요청을 보내려면 `headers: { 'x-sveltekit-action': 'true' }` 헤더를 포함시켜야 한다.

## 6. 보안 모범 사례 간과

웹 애플리케이션 개발에서 보안은 아무리 강조해도 지나치지 않으며, SvelteKit 사용 시에도 CSRF, XSS, 비밀 관리, 인증/인가 등 다양한 보안 측면을 신중하게 고려해야 한다.

### CSRF(Cross-Site Request Forgery) 보호 미흡

**함정:** SvelteKit은 기본적으로 CSRF 보호 기능을 제공하지만(`svelte.config.js`에서 `kit.csrf.checkOrigin` 기본값이 `true`), 이를 임의로 비활성화(`checkOrigin: false`)하고 커스텀 CSRF 보호 로직을 구현할 때, 요청 오리진(Origin) 헤더 검증을 제대로 수행하지 않거나, `allowedOrigins`나 `allowedPaths`와 같은 예외 처리를 부적절하게 구성하여 CSRF 공격에 취약해지는 경우. 또한, 세션 토큰이나 CSRF 토큰을 JavaScript에서 접근 가능한 쿠키(예: `HttpOnly` 플래그가 없는 쿠키)에 저장하여 토큰 탈취 위험을 높이는 경우.

**주의사항:**
*   가급적 SvelteKit의 내장 CSRF 보호 기능을 활성화하여 사용하는 것이 권장된다.
*   커스텀 구현이 불가피하다면, 모든 상태 변경 HTTP 메서드(POST, PUT, PATCH, DELETE)에 대해 오리진 검증을 철저히 수행하고, 신뢰할 수 있는 외부 오리진이나 특정 경로에 대해서만 예외를 허용해야 한다.
*   세션 토큰 및 CSRF 토큰은 반드시 `HttpOnly` 플래그가 설정된 쿠키에 저장하여 JavaScript를 통한 접근을 차단해야 한다.

### XSS(Cross-Site Scripting) 방지 실패

**함정:** 사용자로부터 입력받은 데이터를 적절히 이스케이프(escape)하거나 새니타이즈(sanitize)하지 않고 Svelte의 `{@html...}` 지시자를 사용하여 HTML 컨텍스트에 직접 렌더링함으로써 XSS 취약점을 만드는 경우. 또는, 강력한 Content Security Policy (CSP)를 설정하지 않아 신뢰할 수 없는 출처의 스크립트가 실행되거나 인라인 스크립트 주입을 통해 XSS 공격이 성공할 위험을 방치하는 경우.

**주의사항:**
*   사용자 입력을 HTML로 렌더링해야 할 경우, Svelte의 기본 텍스트 바인딩(자동 이스케이프)을 최대한 활용해야 한다.
*   `{@html...}` 사용이 불가피하다면, 반드시 `DOMPurify`와 같은 검증된 라이브러리를 사용하여 입력을 철저히 새니타이즈해야 한다.
*   `hooks.server.js`의 `handle` 훅 등을 통해 강력한 CSP 헤더를 설정하여 인라인 스크립트 실행을 금지(`script-src 'self' 'nonce-...'` 등)하고, 신뢰할 수 있는 출처의 스크립트만 허용하도록 제한해야 한다.

### 부적절한 비밀(Secrets) 관리

**함정:** API 키, 데이터베이스 접속 정보, JWT 서명 키 등과 같은 민감한 비밀 정보를 클라이언트 사이드 JavaScript 코드에 하드코딩하거나, `.env` 파일을 Git 저장소에 포함시켜 외부에 노출하는 경우. 또는 SvelteKit의 환경 변수 모듈 중 `$env/static/public`이나 `$env/dynamic/public`을 통해 서버 전용이어야 할 민감 정보를 실수로 클라이언트에 전달하는 경우.

**주의사항:**
*   모든 비밀 정보는 운영체제 환경 변수나 플랫폼에서 제공하는 비밀 관리 서비스를 통해 주입하고, 개발 환경에서는 `.env` 파일을 사용하되 이 파일은 반드시 `.gitignore`에 추가해야 한다.
*   SvelteKit 애플리케이션 코드 내에서는 `$env/static/private` 또는 `$env/dynamic/private` 모듈을 통해서만 이러한 비밀 정보에 접근해야 한다.
*   비밀을 직접 다루는 로직은 `$lib/server/` 디렉토리 내에 서버 전용 모듈로 작성하여 클라이언트 사이드 코드에서 실수로 임포트하는 것을 원천적으로 방지하는 것이 좋다.

### 취약한 인증 및 권한 부여 로직

**함정:** 사용자의 인증 상태(세션 또는 토큰의 유효성)를 서버 훅(`hooks.server.js`)이나 각 라우트의 `load` 함수, API 엔드포인트에서 매번 철저히 검증하지 않고 민감한 데이터나 기능에 대한 접근을 허용하는 경우. 또는 `event.locals` 객체에 사용자 정보를 저장하고 이를 기반으로 권한을 부여할 때, `locals`에 저장된 정보가 요청 처리 과정에서 위변조될 가능성을 간과하거나, 클라이언트로부터 전달된 값을 충분한 검증 없이 `locals`에 할당하여 사용하는 경우.

**주의사항:**
*   모든 요청에 대해, 특히 민감한 데이터나 기능을 다루는 요청에 대해서는 반드시 서버 사이드에서 사용자의 인증 상태와 해당 작업에 대한 권한을 철저히 검증해야 한다.
*   `event.locals`는 해당 요청 처리 범위 내에서 서버 내부적으로 신뢰할 수 있는 데이터를 전달하는 용도로 사용되어야 하며, 클라이언트로부터 직접 전달된 값을 기반으로 `locals`를 채우는 것은 보안상 위험할 수 있다.
*   Lucia, Auth.js 등 검증되고 커뮤니티에서 활발히 사용되는 인증 라이브러리의 도입을 적극 고려하고, OWASP Top 10과 같은 웹 애플리케이션 보안 표준 및 모범 사례를 준수해야 한다.

### 미흡한 HTTP 보안 헤더 설정

**함정:** `X-Frame-Options`, `X-Content-Type-Options`, `Referrer-Policy`, `Permissions-Policy`, `Strict-Transport-Security (HSTS)` 등과 같이 웹 애플리케이션의 보안을 강화하는 데 중요한 HTTP 응답 헤더들을 설정하지 않아 클릭재킹(Clickjacking), MIME 타입 스니핑(MIME type sniffing), 민감 정보 유출(Referer 헤더를 통한), 불필요한 브라우저 기능 접근 허용 등의 보안 위험에 애플리케이션을 노출시키는 경우.

**주의사항:**
*   `hooks.server.js` 파일의 `handle` 함수 내에서 응답 객체에 필요한 HTTP 보안 헤더들을 명시적으로 설정해야 한다.
*   `sveltekit-security-headers`와 같은 라이브러리를 사용하거나, 각 헤더의 의미와 권장 값을 숙지하여 직접 구현할 수 있다.
*   아래 표는 리드 엔지니어가 SvelteKit 애플리케이션 보안 강화 시 고려해야 할 주요 HTTP 보안 헤더와 권장 설정을 OWASP Top 10 관점에서 정리한 것이다.

| 헤더명 | 권장 값 (예시) | 주요 목적 | 관련 OWASP 항목 |
|---|---|---|---|
| `Content-Security-Policy` | `default-src 'self'; script-src 'self' 'nonce-xxxx'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; report-uri /csp-reports` | XSS 방지, 데이터 주입 방지, 클릭재킹 방지 | A01 (Broken Access Control - 간접적), A05 (Security Misconfiguration), A07 (Identification and Authentication Failures - 간접적) |
| `Strict-Transport-Security` | `max-age=31536000; includeSubDomains; preload` | HTTPS 강제, 중간자 공격 방지 | A02 (Cryptographic Failures), A05 (Security Misconfiguration) |
| `X-Frame-Options` | `DENY` 또는 `SAMEORIGIN` | 클릭재킹(Clickjacking) 방지 | A01 (Broken Access Control - UI redress), A08 (Software and Data Integrity Failures - 간접적) |
| `X-Content-Type-Options` | `nosniff` | MIME 타입 스니핑 방지 (브라우저가 Content-Type을 무시하고 내용을 추측하는 것을 방지) | A05 (Security Misconfiguration), A08 (Software and Data Integrity Failures - 간접적) |
| `Referrer-Policy` | `strict-origin-when-cross-origin` 또는 `no-referrer` | 이전 페이지 URL 정보 전송 제어 (민감 정보 유출 방지) | A01 (Broken Access Control - 정보 유출), A04 (Insecure Design - 간접적) |
| `Permissions-Policy` | `geolocation=(), microphone=(), camera=()` | 브라우저 기능 접근 권한 제어 (불필요한 기능 비활성화) | A01 (Broken Access Control), A05 (Security Misconfiguration) |
| `Cross-Origin-Opener-Policy` | `same-origin` | COOP: Cross-Origin Isolation, Spectre 등 부채널 공격 일부 완화 | A05 (Security Misconfiguration) |
| `Cross-Origin-Embedder-Policy` | `require-corp` | COEP: Cross-Origin Isolation, Spectre 등 부채널 공격 일부 완화 | A05 (Security Misconfiguration) |

## 7. 복잡하거나 잘못된 라우팅 패턴

SvelteKit의 파일 시스템 기반 라우팅은 직관적이지만, 프로젝트 규모가 커지거나 고급 기능이 사용될 때 혼란을 야기하거나 잘못된 패턴으로 이어질 수 있다.

### 파일 시스템 기반 라우팅의 혼란

**함정:** `index` 파일(예: `src/routes/about/index/+page.svelte`)을 과도하게 사용하거나, 라우트와 직접 관련 없는 유틸리티 파일이나 컴포넌트를 라우트 디렉토리 내에 위치시켜 예기치 않은 라우트가 생성되는 경우. SvelteKit 1.0 이전의 `__layout.svelte`나 `__error.svelte`와 같은 구식 명명 규칙을 혼용하거나, 현재의 `+layout.svelte`, `+error.svelte` 파일의 적용 범위(해당 디렉토리 및 하위 디렉토리)를 오해하는 경우.

**주의사항:**
*   단순한 페이지는 `src/routes/about/+page.svelte`와 같이 직접 파일을 생성하고, 관련된 서버 로직이나 레이아웃이 필요할 때 해당 디렉토리에 `+server.js`, `+layout.svelte` 등을 추가하는 방식을 일관되게 사용하는 것이 좋다.
*   라우트와 직접 관련 없는 공용 컴포넌트나 유틸리티는 `src/lib` 디렉토리나, 라우트 디렉토리 내에 두더라도 파일명 앞에 밑줄(`_`)을 붙여 SvelteKit이 라우트로 인식하지 않도록 해야 한다.

### 고급 라우팅 기능의 오용

**함정:** 레이아웃 그룹 (`group`)이나 레이아웃 탈출 기능(`@`)을 불필요하게 복잡하게 사용하거나, 해당 기능의 정확한 동작 방식을 이해하지 못해 의도치 않은 레이아웃 상속 또는 누락이 발생하는 경우. 예를 들어, 단순히 URL 구조를 정리하기 위해 과도하게 레이아웃 그룹을 중첩시키면 프로젝트 구조의 가독성을 해칠 수 있다.

**주의사항:**
*   레이아웃 그룹은 URL 경로에 영향을 주지 않으면서 서로 다른 레이아웃 계층을 적용해야 할 때 유용하다.
*   레이아웃 탈출은 특정 페이지나 하위 레이아웃이 상위 레이아웃 계층에서 벗어나야 할 명확한 필요가 있을 때 사용해야 한다. 이러한 고급 기능들은 신중하게, 꼭 필요한 경우에만 적용해야 한다.

### 동적 라우트 및 파라미터 처리 오류

**함정:** 동적 라우트의 나머지 파라미터(`[...rest]`)가 예상보다 많은 경로 세그먼트를 "탐욕스럽게(greedily)" 잡아먹거나, 파라미터가 없는 경우에도 매칭되어 오류를 유발하는 경우. 또는 동적 파라미터에 대한 유효성 검사를 수행하는 매처(matcher)를 사용하지 않아 잘못된 형식의 파라미터로 페이지가 로드되거나, 파일명에 URL이나 파일 시스템에서 특수 문자를 사용할 때 SvelteKit의 인코딩 규칙을 따르지 않아 라우트가 제대로 인식되지 않는 문제 발생.

**주의사항:**
*   나머지 파라미터 사용 시에는 `load` 함수에서 해당 파라미터 값의 유효성을 반드시 검증해야 한다.
*   숫자 ID, UUID 등 특정 형식을 기대하는 동적 파라미터에는 매처를 정의하여 사용하여 타입 안정성과 라우팅 정확성을 높여야 한다.
*   파일명에 특수 문자 사용 시에는 SvelteKit 문서에 명시된 인코딩 규칙을 준수해야 한다.

### Shallow Routing의 부적절한 사용 (SvelteKit 2+)

**함정:** SvelteKit 2에 도입된 Shallow Routing (`pushState`, `replaceState` 사용) 기능을 남용하여 사용자 경험을 해치거나, 브라우저 히스토리 관리를 불필요하게 복잡하게 만드는 경우. 또는 이 기능의 주된 목적(UI의 일부만 업데이트하면서 브라우저 히스토리 항목을 추가하거나 대체)을 오해하여, 실제로는 전체 페이지 네비게이션이 필요한 상황에 Shallow Routing을 적용하는 실수.

**주의사항:**
*   Shallow Routing은 모달 표시/숨김, 탭 콘텐츠 전환, 필터링 결과 표시와 같이 페이지의 일부만 변경되면서 URL이나 히스토리 관리가 필요한 경우에 제한적으로 사용해야 한다.
*   핵심적인 네비게이션 흐름에는 일반적인 파일 시스템 기반 라우팅 방식을 사용하는 것이 바람직하다.

## 8. 컴포넌트 설계 및 최적화

SvelteKit 애플리케이션의 성능과 유지보수성은 컴포넌트의 설계 방식에 크게 좌우된다.

### 불필요한 컴포넌트 재렌더링

**함정:** Svelte는 기본적으로 효율적인 업데이트 메커니즘을 가지고 있지만, `$state`나 `prop`의 변경이 불필요하게 많은 컴포넌트의 재렌더링을 유발하거나, `{#each}` 블록에서 `key` 속성을 사용하지 않아 리스트 렌더링 성능이 저하되는 경우.

**주의사항:**
*   컴포넌트의 `prop`은 필요한 데이터만 전달하고, 불필요한 데이터는 전달하지 않도록 한다.
*   `{#each}` 블록 사용 시에는 항상 고유한 `key` 속성을 사용하여 Svelte가 리스트 항목을 효율적으로 식별하고 업데이트할 수 있도록 해야 한다.
*   `$state`를 사용할 때는 상태 변경이 최소한의 컴포넌트에만 영향을 미치도록 상태를 세분화하여 관리한다.

### 거대한 컴포넌트(God Components)

**함정:** 하나의 컴포넌트가 너무 많은 로직(데이터 페칭, 상태 관리, UI 렌더링, 이벤트 처리 등)을 포함하여 파일 크기가 커지고, 가독성이 떨어지며, 재사용성이 낮아지는 경우.

**주의사항:**
*   컴포넌트를 작고 재사용 가능한 단위로 분리한다.
*   각 컴포넌트는 단일 책임 원칙(Single Responsibility Principle)을 따르도록 설계한다.
*   데이터 페칭 로직은 `load` 함수나 별도의 서비스 모듈로 분리하고, 상태 관리는 `$state` 룬이나 스토어 패턴을 활용한다.

### 접근성(Accessibility) 고려 부족

**함정:** UI 컴포넌트를 개발할 때 `ARIA` 속성, 키보드 네비게이션, 색상 대비 등 웹 접근성 표준을 고려하지 않아 장애가 있는 사용자에게 불편함을 초래하는 경우.

**주의사항:**
*   모든 UI 컴포넌트는 웹 접근성 표준(`WCAG`)을 준수하도록 설계하고 구현해야 한다.
*   `aria-*` 속성을 적절히 사용하고, 키보드만으로도 모든 인터랙션이 가능하도록 한다.
*   색상 대비를 충분히 확보하고, 이미지에는 의미 있는 `alt` 텍스트를 제공한다.

### 애니메이션 및 트랜지션의 과도한 사용

**함정:** 불필요하거나 과도한 애니메이션 및 트랜지션을 사용하여 사용자 경험을 저해하거나, 성능 저하를 유발하는 경우. 특히 저사양 기기에서 문제가 될 수 있다.

**주의사항:**
*   애니메이션과 트랜지션은 사용자 경험을 향상시키는 목적으로만 사용하고, 과도하게 사용하지 않도록 한다.
*   성능에 민감한 애니메이션은 `requestAnimationFrame`을 사용하거나, CSS `transform` 및 `opacity` 속성을 활용하여 GPU 가속을 유도한다.
*   `prefers-reduced-motion` 미디어 쿼리를 사용하여 애니메이션을 비활성화하는 옵션을 제공한다.

## 9. 배포 및 성능 최적화

SvelteKit 애플리케이션의 배포와 성능 최적화는 사용자 경험과 운영 비용에 직접적인 영향을 미친다.

### 어댑터(Adapter)의 부적절한 선택

**함정:** SvelteKit은 다양한 배포 환경을 위한 어댑터를 제공하지만, 프로젝트의 특성(SSR 필요 여부, 정적 사이트 생성, 서버리스 함수 등)을 고려하지 않고 기본 어댑터(`adapter-auto`)만 사용하거나, 특정 환경에 부적합한 어댑터를 선택하여 성능 저하 또는 불필요한 비용을 초래하는 경우.

**주의사항:**
*   프로젝트의 요구사항과 배포 환경에 가장 적합한 어댑터를 신중하게 선택해야 한다.
*   정적 콘텐츠만 있다면 `adapter-static`을, 서버리스 환경이라면 `adapter-vercel` 또는 `adapter-netlify`를, Node.js 서버라면 `adapter-node`를 고려한다.
*   `adapter-auto`는 유연하지만, 특정 환경에 최적화된 어댑터보다 성능이나 비용 효율성 면에서 불리할 수 있다.

### 이미지 최적화 및 미디어 파일 관리 미흡

**함정:** 웹 페이지에 최적화되지 않은 고해상도 이미지를 사용하거나, 이미지 포맷(JPEG, PNG, WebP 등)을 적절히 선택하지 않아 페이지 로딩 시간을 증가시키는 경우. 또한, 동영상이나 오디오와 같은 미디어 파일을 효율적으로 관리하지 않아 대역폭 낭비를 초래하는 경우.

**주의사항:**
*   `srcset`을 사용하여 다양한 해상도에 맞는 이미지를 제공하고, `loading="lazy"` 속성을 사용하여 지연 로딩을 구현한다.
*   WebP나 AVIF와 같은 최신 이미지 포맷을 활용하여 파일 크기를 줄인다.
*   이미지 최적화 서비스(예: Cloudinary, Imgix)나 SvelteKit의 이미지 컴포넌트(만약 사용한다면)를 고려한다.
*   미디어 파일은 스트리밍 서비스를 이용하거나, 적절한 압축 및 포맷 변환을 통해 최적화한다.

### 번들 크기(Bundle Size) 관리 소홀

**함정:** 불필요한 라이브러리를 포함하거나, 트리 쉐이킹(tree-shaking)이 제대로 적용되지 않아 클라이언트 측 JavaScript 번들 크기가 과도하게 커지는 경우. 이는 초기 로딩 시간을 증가시키고 사용자 경험을 저해한다.

**주의사항:**
*   `svelte-kit package` 명령어를 사용하여 번들 분석 도구(예: `rollup-plugin-visualizer`)를 활용하여 번들 크기를 정기적으로 확인하고 최적화한다.
*   필요한 모듈만 임포트하고, 사용하지 않는 코드는 제거한다.
*   동적 임포트(`import()`)를 사용하여 필요할 때만 코드를 로드하는 코드 스플리팅(code splitting)을 적극적으로 활용한다.

### 서버리스 함수 콜드 스타트(Cold Start) 문제 간과

**함정:** 서버리스 환경에서 `load` 함수나 API 엔드포인트가 콜드 스타트(Cold Start)로 인해 초기 응답 시간이 지연되는 문제를 간과하거나, 이를 완화하기 위한 전략을 적용하지 않는 경우.

**주의사항:**
*   콜드 스타트가 중요한 애플리케이션의 경우, 서버리스 함수를 주기적으로 "워밍업"하거나, 프로비저닝된 동시성(provisioned concurrency)과 같은 클라우드 제공자의 기능을 활용하여 콜드 스타트를 최소화한다.
*   `load` 함수나 API 엔드포인트의 로직을 최대한 가볍게 유지하고, 불필요한 초기화 작업을 줄인다.

## 10. 보안 모범 사례 간과

웹 애플리케이션 개발에서 보안은 아무리 강조해도 지나치지 않으며, SvelteKit 사용 시에도 CSRF, XSS, 비밀 관리, 인증/인가 등 다양한 보안 측면을 신중하게 고려해야 한다.

### CSRF(Cross-Site Request Forgery) 보호 미흡

**함정:** SvelteKit은 기본적으로 CSRF 보호 기능을 제공하지만(`svelte.config.js`에서 `kit.csrf.checkOrigin` 기본값이 `true`), 이를 임의로 비활성화(`checkOrigin: false`)하고 커스텀 CSRF 보호 로직을 구현할 때, 요청 오리진(Origin) 헤더 검증을 제대로 수행하지 않거나, `allowedOrigins`나 `allowedPaths`와 같은 예외 처리를 부적절하게 구성하여 CSRF 공격에 취약해지는 경우. 또한, 세션 토큰이나 CSRF 토큰을 JavaScript에서 접근 가능한 쿠키(예: `HttpOnly` 플래그가 없는 쿠키)에 저장하여 토큰 탈취 위험을 높이는 경우.

**주의사항:**
*   가급적 SvelteKit의 내장 CSRF 보호 기능을 활성화하여 사용하는 것이 권장된다.
*   커스텀 구현이 불가피하다면, 모든 상태 변경 HTTP 메서드(POST, PUT, PATCH, DELETE)에 대해 오리진 검증을 철저히 수행하고, 신뢰할 수 있는 외부 오리진이나 특정 경로에 대해서만 예외를 허용해야 한다.
*   세션 토큰 및 CSRF 토큰은 반드시 `HttpOnly` 플래그가 설정된 쿠키에 저장하여 JavaScript를 통한 접근을 차단해야 한다.

### XSS(Cross-Site Scripting) 방지 실패

**함정:** 사용자로부터 입력받은 데이터를 적절히 이스케이프(escape)하거나 새니타이즈(sanitize)하지 않고 Svelte의 `{@html...}` 지시자를 사용하여 HTML 컨텍스트에 직접 렌더링함으로써 XSS 취약점을 만드는 경우. 또는, 강력한 Content Security Policy (CSP)를 설정하지 않아 신뢰할 수 없는 출처의 스크립트가 실행되거나 인라인 스크립트 주입을 통해 XSS 공격이 성공할 위험을 방치하는 경우.

**주의사항:**
*   사용자 입력을 HTML로 렌더링해야 할 경우, Svelte의 기본 텍스트 바인딩(자동 이스케이프)을 최대한 활용해야 한다.
*   `{@html...}` 사용이 불가피하다면, 반드시 `DOMPurify`와 같은 검증된 라이브러리를 사용하여 입력을 철저히 새니타이즈해야 한다.
*   `hooks.server.js`의 `handle` 훅 등을 통해 강력한 CSP 헤더를 설정하여 인라인 스크립트 실행을 금지(`script-src 'self' 'nonce-...'` 등)하고, 신뢰할 수 있는 출처의 스크립트만 허용하도록 제한해야 한다.

### 부적절한 비밀(Secrets) 관리

**함정:** API 키, 데이터베이스 접속 정보, JWT 서명 키 등과 같은 민감한 비밀 정보를 클라이언트 사이드 JavaScript 코드에 하드코딩하거나, `.env` 파일을 Git 저장소에 포함시켜 외부에 노출하는 경우. 또는 SvelteKit의 환경 변수 모듈 중 `$env/static/public`이나 `$env/dynamic/public`을 통해 서버 전용이어야 할 민감 정보를 실수로 클라이언트에 전달하는 경우.

**주의사항:**
*   모든 비밀 정보는 운영체제 환경 변수나 플랫폼에서 제공하는 비밀 관리 서비스를 통해 주입하고, 개발 환경에서는 `.env` 파일을 사용하되 이 파일은 반드시 `.gitignore`에 추가해야 한다.
*   SvelteKit 애플리케이션 코드 내에서는 `$env/static/private` 또는 `$env/dynamic/private` 모듈을 통해서만 이러한 비밀 정보에 접근해야 한다.
*   비밀을 직접 다루는 로직은 `$lib/server/` 디렉토리 내에 서버 전용 모듈로 작성하여 클라이언트 사이드 코드에서 실수로 임포트하는 것을 원천적으로 방지하는 것이 좋다.

### 취약한 인증 및 권한 부여 로직

**함정:** 사용자의 인증 상태(세션 또는 토큰의 유효성)를 서버 훅(`hooks.server.js`)이나 각 라우트의 `load` 함수, API 엔드포인트에서 매번 철저히 검증하지 않고 민감한 데이터나 기능에 대한 접근을 허용하는 경우. 또는 `event.locals` 객체에 사용자 정보를 저장하고 이를 기반으로 권한을 부여할 때, `locals`에 저장된 정보가 요청 처리 과정에서 위변조될 가능성을 간과하거나, 클라이언트로부터 전달된 값을 충분한 검증 없이 `locals`에 할당하여 사용하는 경우.

**주의사항:**
*   모든 요청에 대해, 특히 민감한 데이터나 기능을 다루는 요청에 대해서는 반드시 서버 사이드에서 사용자의 인증 상태와 해당 작업에 대한 권한을 철저히 검증해야 한다.
*   `event.locals`는 해당 요청 처리 범위 내에서 서버 내부적으로 신뢰할 수 있는 데이터를 전달하는 용도로 사용되어야 하며, 클라이언트로부터 직접 전달된 값을 기반으로 `locals`를 채우는 것은 보안상 위험할 수 있다.
*   Lucia, Auth.js 등 검증되고 커뮤니티에서 활발히 사용되는 인증 라이브러리의 도입을 적극 고려하고, OWASP Top 10과 같은 웹 애플리케이션 보안 표준 및 모범 사례를 준수해야 한다.

### 미흡한 HTTP 보안 헤더 설정

**함정:** `X-Frame-Options`, `X-Content-Type-Options`, `Referrer-Policy`, `Permissions-Policy`, `Strict-Transport-Security (HSTS)` 등과 같이 웹 애플리케이션의 보안을 강화하는 데 중요한 HTTP 응답 헤더들을 설정하지 않아 클릭재킹(Clickjacking), MIME 타입 스니핑(MIME type sniffing), 민감 정보 유출(Referer 헤더를 통한), 불필요한 브라우저 기능 접근 허용 등의 보안 위험에 애플리케이션을 노출시키는 경우.

**주의사항:**
*   `hooks.server.js` 파일의 `handle` 함수 내에서 응답 객체에 필요한 HTTP 보안 헤더들을 명시적으로 설정해야 한다.
*   `sveltekit-security-headers`와 같은 라이브러리를 사용하거나, 각 헤더의 의미와 권장 값을 숙지하여 직접 구현할 수 있다.
*   아래 표는 리드 엔지니어가 SvelteKit 애플리케이션 보안 강화 시 고려해야 할 주요 HTTP 보안 헤더와 권장 설정을 OWASP Top 10 관점에서 정리한 것이다.

| 헤더명 | 권장 값 (예시) | 주요 목적 | 관련 OWASP 항목 |
|---|---|---|---|
| `Content-Security-Policy` | `default-src 'self'; script-src 'self' 'nonce-xxxx'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; report-uri /csp-reports` | XSS 방지, 데이터 주입 방지, 클릭재킹 방지 | A01 (Broken Access Control - 간접적), A05 (Security Misconfiguration), A07 (Identification and Authentication Failures - 간접적) |
| `Strict-Transport-Security` | `max-age=31536000; includeSubDomains; preload` | HTTPS 강제, 중간자 공격 방지 | A02 (Cryptographic Failures), A05 (Security Misconfiguration) |
| `X-Frame-Options` | `DENY` 또는 `SAMEORIGIN` | 클릭재킹(Clickjacking) 방지 | A01 (Broken Access Control - UI redress), A08 (Software and Data Integrity Failures - 간접적) |
| `X-Content-Type-Options` | `nosniff` | MIME 타입 스니핑 방지 (브라우저가 Content-Type을 무시하고 내용을 추측하는 것을 방지) | A05 (Security Misconfiguration), A08 (Software and Data Integrity Failures - 간접적) |
| `Referrer-Policy` | `strict-origin-when-cross-origin` 또는 `no-referrer` | 이전 페이지 URL 정보 전송 제어 (민감 정보 유출 방지) | A01 (Broken Access Control - 정보 유출), A04 (Insecure Design - 간접적) |
| `Permissions-Policy` | `geolocation=(), microphone=(), camera=()` | 브라우저 기능 접근 권한 제어 (불필요한 기능 비활성화) | A01 (Broken Access Control), A05 (Security Misconfiguration) |
| `Cross-Origin-Opener-Policy` | `same-origin` | COOP: Cross-Origin Isolation, Spectre 등 부채널 공격 일부 완화 | A05 (Security Misconfiguration) |
| `Cross-Origin-Embedder-Policy` | `require-corp` | COEP: Cross-Origin Isolation, Spectre 등 부채널 공격 일부 완화 | A05 (Security Misconfiguration) |

## 11. 비효율적인 폼 핸들링 및 액션

SvelteKit의 폼 액션은 서버와의 상호작용을 간결하게 만들지만, 기본 액션과 명명된 액션의 혼용, 프로그레시브 인핸스먼트의 오해, 서버 사이드 유효성 검사 미흡 등은 문제를 일으킬 수 있다.

### 기본(Default) 액션과 명명된(Named) 액션의 혼용 문제

**함정:** 하나의 라우트(`+page.server.js`) 내에 기본 POST 액션(이름 없는 `export const actions = { default: async () => {...} }`)과 여러 개의 명명된 POST 액션(예: `export const actions = { updateName: async () => {...}, deleteAccount: async () => {...} }`)을 함께 정의하려고 시도하는 경우. SvelteKit은 이를 허용하지 않는다. 또한, 명명된 액션을 사용한 후 명시적으로 리디렉션(`redirect`)을 하지 않으면, 폼 제출 시 사용된 쿼리 파라미터가 URL에 남아있게 되어 이후 동일 페이지에서 기본 POST 요청(만약 다른 방식으로 트리거된다면)이나 페이지 새로고침 시 의도치 않은 동작을 유발할 수 있다.

**주의사항:**
*   하나의 라우트 파일에는 기본 액션 하나만을 사용하거나, 여러 개의 명명된 액션들만을 사용해야 한다.
*   명명된 액션 처리 후에는 일반적으로 `redirect`를 사용하여 사용자를 다른 페이지로 안내하거나, 현재 페이지를 다시 로드하여 URL을 정리하는 것이 좋다.
*   프로그레시브 인핸스먼트를 사용할 경우, `enhance` 콜백 내에서 URL을 수동으로 정리하거나 상태를 업데이트하여 이러한 문제를 회피할 수도 있다.

### 프로그레시브 인핸스먼트(`use:enhance`)의 오해 또는 미활용

**함정:** `use:enhance` 액션을 폼에 적용했을 때의 기본 동작(폼 요소 리셋, `invalidateAll()` 호출로 인한 모든 `load` 함수 재실행 등)을 정확히 이해하지 못하고 사용하는 경우. 특히, 커스텀 콜백 함수를 `use:enhance`에 제공하면서 콜백 내에서 `update` 함수를 호출하지 않아 SvelteKit의 기본 폼 처리 로직(에러 메시지 표시, `form` prop 업데이트 등)이 누락되는 경우가 있다. 또한, `applyAction` 함수를 부적절하게 사용하여 의도치 않은 데이터 업데이트나 에러 처리가 발생할 수도 있다. 근본적으로 JavaScript 없이도 폼이 정상적으로 동작해야 한다는 프로그레시브 인핸스먼트의 기본 원칙을 간과하고 JavaScript에만 의존적인 폼을 설계하는 것도 문제이다.

**주의사항:**
*   `use:enhance`를 사용할 때는 기본 동작 방식을 숙지해야 한다.
*   커스텀 로직이 필요하여 콜백 함수를 제공할 경우, 콜백 내에서 `update` 함수나 `applyAction` 함수를 상황에 맞게 적절히 호출하여 SvelteKit의 내장 기능을 활용해야 한다.
*   가장 중요한 것은, 항상 JavaScript가 비활성화된 환경에서도 폼이 정상적으로 제출되고 서버에서 처리될 수 있도록 기본 HTML 폼 기능을 기반으로 설계해야 한다는 점이다.

### 서버 사이드 유효성 검사 및 에러 처리 미흡

**함정:** 사용자 입력값에 대한 유효성 검사를 클라이언트 사이드에서만 수행하고, 정작 중요한 서버 사이드 유효성 검사를 누락하는 경우. 또는 서버 액션 함수에서 유효성 검사 실패 시, `@sveltejs/kit`의 `fail(status, data)` 함수를 사용하여 사용자에게 유효성 검사 오류를 명확하게 전달하는 표준적인 방법을 사용하지 않고, 임의의 방식으로 에러를 처리하여 SvelteKit이 제공하는 `form` prop 업데이트와 같은 내장 기능을 제대로 활용하지 못하는 경우.

**주의사항:**
*   모든 사용자 입력은 반드시 서버 사이드에서 다시 한번 유효성을 검사해야 한다. 이는 보안의 기본 원칙이다.
*   유효성 검사에 실패했을 경우, `fail(status, data)` 함수를 사용하여 HTTP 상태 코드(일반적으로 400 또는 422)와 함께 오류 메시지, 사용자가 이전에 입력했던 값 등을 포함한 데이터를 클라이언트로 반환해야 한다.
*   클라이언트 컴포넌트에서는 `export let form;`을 통해 이 `form` prop을 받아 사용자에게 적절한 피드백을 제공해야 한다.

### 액션 URL 및 데이터 직렬화 문제

**함정:** 폼의 `action` 속성에 URL을 잘못 지정하는 경우. 예를 들어, 현재 페이지가 아닌 다른 페이지의 특정 명명된 액션을 호출하고자 할 때 URL 경로 뒤에 `?/actionName`과 같은 접두사나 명명 규칙을 누락하는 경우. 또한, `fetch` API를 사용하여 수동으로 폼 데이터를 서버 액션으로 전송하고 응답을 받을 때, 응답 본문에 포함된 `Date`나 `BigInt`와 같은 특수 타입의 데이터가 JavaScript의 `JSON.parse()`로는 올바르게 역직렬화되지 않는데, 이때 SvelteKit이 제공하는 `deserialize` 함수를 사용하지 않아 데이터가 손실되거나 타입 오류가 발생하는 경우. 한편, 하나의 라우트 경로에 `+server.js`(API 라우트)와 `+page.server.js`(페이지 액션)가 공존할 때, 클라이언트에서 `fetch` 요청 시 특별한 헤더 없이 해당 경로로 요청하면 의도치 않게 `+server.js`의 핸들러로 라우팅될 수 있다.

**주의사항:**
*   폼의 `action` URL은 명확하게 지정해야 하며, 특히 다른 라우트의 명명된 액션을 호출할 때는 해당 라우트 경로 뒤에 `?/actionName` 형식을 사용해야 한다.
*   `fetch` API를 직접 사용하여 폼 액션 응답을 처리할 경우에는, 응답 본문을 `$app/forms`에서 제공하는 `deserialize` 함수로 처리하여 모든 데이터 타입을 정확하게 복원해야 한다.
*   `+page.server.js`의 액션으로 `fetch` 요청을 보내려면 `headers: { 'x-sveltekit-action': 'true' }` 헤더를 포함시켜야 한다.

## 12. 훅(Hooks)의 최적화되지 않은 사용

SvelteKit의 훅 시스템은 요청-응답 사이클, 에러 처리 등에 강력한 제어권을 부여하지만, 잘못 사용될 경우 애플리케이션의 복잡성을 증가시키고 성능 문제를 야기할 수 있다.

### `handle` 훅의 과도한 로직 및 성능 저하

**함정:** 모든 서버 요청에 대해 실행되는 `handle` 훅(`src/hooks.server.js`) 내부에 무겁거나 동기적인 I/O 작업, 또는 복잡한 비동기 로직을 과도하게 추가하여 전체 애플리케이션의 응답 시간을 현저히 느리게 만드는 경우. 또한, `resolve` 함수의 두 번째 인자로 전달되는 `transformPageChunk` 옵션을 남용하여 HTML 스트리밍 과정에서 불필요한 변환 작업을 수행함으로써 성능에 부정적인 영향을 주는 경우.

**주의사항:**
*   `handle` 훅은 인증 상태 확인, 간단한 로깅, 필수적인 HTTP 헤더 설정, `event.locals` 객체 초기화 등과 같이 가볍고 빠르게 실행될 수 있는 공통 로직에만 사용하는 것이 바람직하다.
*   시간이 오래 걸리거나 복잡한 비동기 작업은 해당 로직이 필요한 특정 라우트의 `load` 함수나 별도의 API 엔드포인트로 분리하는 것이 좋다.
*   `transformPageChunk`는 꼭 필요한 HTML 변환에만 신중하게 사용해야 한다.

### `handleError` 훅의 부적절한 사용

**함정:** `handleError` 훅 내부에서 또 다른 에러를 발생시켜 애플리케이션을 불안정하게 만들거나(이는 절대적으로 피해야 할 상황이다), 사용자에게 민감한 에러 정보(예: 스택 트레이스, 내부 변수 값)를 그대로 노출하는 경우. 또는, `@sveltejs/kit`의 `error()` 헬퍼 함수를 통해 의도적으로 발생시킨 "예상된 에러"까지 `handleError` 훅에서 처리하려고 시도하여 로직을 복잡하게 만드는 경우.

**주의사항:**
*   `handleError` 훅은 오직 "예상치 못한 에러"에 대한 중앙 집중식 로깅(예: Sentry와 같은 외부 서비스 연동) 및 사용자 친화적인 일반화된 에러 메시지 반환에만 집중해야 한다.
*   반환되는 에러 객체에서는 민감한 정보를 반드시 필터링해야 하며, 이 훅 자체가 새로운 에러를 발생시키지 않도록 방어적으로 코딩하는 것이 매우 중요하다.

### `handleFetch` 훅의 오용

**함정:** `event.fetch`의 동작을 수정할 수 있는 `handleFetch` 훅을 사용하여 애플리케이션 내에서 발생하는 모든 외부 API 요청을 가로채거나 광범위하게 수정하려고 시도함으로써 코드의 복잡성을 불필요하게 증가시키는 경우. 또는 서버 사이드 렌더링(SSR) 시 내부 API 호출 최적화와 같은 이 훅의 본래 목적을 벗어나 과도하게 사용하는 경우.

**주의사항:**
*   `handleFetch` 훅은 SSR 과정에서 내부 API를 직접 호출하여 네트워크 레이턴시를 줄이거나, 특정 요청에 대해 커스텀 헤더를 추가하는 등 명확하고 구체적인 목적에 맞게 제한적으로 사용해야 한다.
*   모든 `fetch` 요청에 대한 광범위한 인터셉터나 변환 레이어로 사용하기보다는, 필요한 유스케이스에만 선별적으로 적용하는 것이 좋다.

### `reroute` 훅의 과도한 사용 또는 비효율적 구현

**함정:** 국제화(i18n)된 URL 처리와 같이 명확한 사용 사례 외에 `reroute` 훅을 남용하여 라우팅 로직을 불필요하게 복잡하게 만들거나, `reroute` 함수 내부에서 시간이 오래 걸리는 비동기 작업을 수행하여 전체적인 네비게이션 지연을 초래하는 경우. 또한, `reroute` 훅의 결과가 클라이언트 사이드에서 캐시된다는 점을 간과하고, 동적으로 자주 변경되어야 하는 로직을 `reroute` 내부에 구현하여 의도치 않은 동작을 유발할 수도 있다.

**주의사항:**
*   `reroute` 훅은 주로 국제화된 URL 구조를 내부 표준 라우트 구조로 매핑하는 등, 표시되는 URL과 실제 파일 시스템 기반 라우트 구조가 달라야 하는 명확한 경우에만 사용하는 것이 좋다.
*   `reroute` 함수는 가능한 순수 함수(pure function)로 작성하고, 비동기 로직은 최소화해야 하며, 반환 값은 입력 URL에 대해 결정적(deterministic)이어야 한다.

### 훅 실행 순서 및 공유 훅 컨텍스트 미이해

**함정:** 서버 훅(`handle`, `handleFetch`, `init`), 클라이언트 훅, 그리고 유니버설 훅(`reroute`, `transport`) 및 공유 훅(`handleError`, `init`) 각각의 정확한 실행 시점과 전체적인 실행 순서를 명확히 이해하지 못해 의도치 않은 동작을 유발하거나 디버깅에 어려움을 겪는 경우. 특히, `handleError`나 `init`과 같이 서버와 클라이언트 양쪽 모두에서 실행될 수 있는 공유 훅을 작성할 때, 각 환경에서의 `event` 객체 타입 차이(예: 서버에서는 `RequestEvent`, 클라이언트에서는 `NavigationEvent`) 등을 고려하지 않아 런타임 에러가 발생하는 경우.

**주의사항:**
*   각 훅이 실행되는 환경(서버 전용, 클라이언트 전용, 또는 양쪽 모두)과 주요 훅들의 실행 순서(예: `init` -> `reroute` -> `handle` -> `handleFetch` (필요시) -> `handleError` (에러 발생 시))를 명확히 숙지하고 있어야 한다.
*   공유 훅을 작성할 때는 `import.meta.env.SSR`과 같은 환경 변수를 사용하여 현재 실행 환경을 확인하고, 필요한 경우 환경별로 분기 처리를 하거나, 각 환경에 맞는 정확한 타입(예: `HandleServerError` vs `HandleClientError`)을 사용하여 타입 안정성을 확보해야 한다.

## 결론

SvelteKit 애플리케이션의 성공적인 개발과 운영을 위해서는 Svelte 5의 룬 시스템, `load` 함수, 폼 액션, 보안 모범 사례, 라우팅 패턴, 컴포넌트 설계, 배포 및 성능 최적화, 그리고 훅의 최적화된 사용에 대한 깊은 이해와 올바른 적용이 필수적이다. 리드 엔지니어는 팀원들이 이러한 핵심 영역에서 발생할 수 있는 함정을 피하고, 최적의 패턴을 따르도록 지속적으로 교육하고 가이드해야 한다. 이는 애플리케이션의 성능, 보안, 유지보수성, 확장성, 그리고 궁극적으로 사용자 경험을 극대화하는 데 기여할 것이다.
