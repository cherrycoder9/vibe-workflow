# Rust 코딩 가이드라인: 소유권, 빌림, 생명주기

Rust는 메모리 안전성을 보장하는 강력한 언어지만, 소유권(Ownership), 빌림(Borrowing), 생명주기(Lifetimes)라는 독특한 개념 때문에 초보자들이 어려움을 겪는 경우가 많다. LLM이 Rust 코드를 생성하거나 수정할 때 다음 사항들을 특히 주의해야 한다.

## 1. 소유권, 빌림, 생명주기 핵심 이해

-   **개념 오해 금지**: Rust의 참조(reference)는 다른 언어의 참조와 달리 소유권을 의미하지 않고, 데이터에 대한 일시적인 접근 권한을 나타낸다. 값이 이동(move)된 후 사용하려 하거나, 빌림 규칙을 위반하면 컴파일 오류가 발생한다.
-   **패러다임 전환**: 이 시스템은 단순한 메모리 관리를 넘어, 프로그램의 데이터 흐름과 상태 변화를 명확히 정의하도록 강제하는 패러다임으로 이해해야 한다. 동시성 프로그래밍에서 데이터 경쟁을 컴파일 시점에 방지하는 데 핵심적인 역할을 한다.

## 2. `clone()` 남용 주의

-   **성능 저하**: 소유권 모델 때문에 `clone()`을 과도하게 사용하면 대규모 데이터 구조에서 심각한 성능 저하와 불필요한 메모리 사용을 초래할 수 있다.
-   **빌림 우선**: 대부분의 경우 데이터를 복제하는 대신 참조(`&` 또는 `&mut`)를 빌려주는 것만으로 충분하다.
-   **`Copy` 트레이트**: `Copy` 트레이트를 구현하는 타입은 암시적 복사가 일어나므로, 대형 구조체에 무분별하게 `Copy`를 적용하지 않도록 주의해야 한다.

## 3. 복잡한 생명주기 명시와 어려움

-   **`'static` 생명주기 오용**: 프로그램 전체 실행 시간 동안 유효한 참조를 의미하는 `'static`은 전역 변수나 스레드 간 데이터 공유 시 필요할 수 있지만, 불필요하게 사용하면 유연성을 해치고 메모리 낭비를 초래할 수 있다. 특히 비동기 코드에서 Future가 `'static`을 요구할 때, 데이터를 복제하거나 `Arc`와 같은 스마트 포인터를 고려해야 한다.
-   **자기 참조 구조체**: Rust에서는 자기 참조 구조체를 안전하게 구현하기 매우 어렵다. `Pin`과 `unsafe` 코드를 사용해야 하지만, 이는 고급 기법이므로 신중해야 한다. 대안으로 ID 기반 참조, 인덱스, 아레나 할당 등을 고려한다.
-   **NLL(Non-Lexical Lifetimes) 이해**: NLL은 빌림 검사기가 참조의 실제 사용 범위를 기반으로 생명주기를 추론하도록 개선된 기능이다. 컴파일러 오류 메시지를 더 유용하게 만들었지만, 근본적인 빌림 규칙을 우회하는 것은 아니다.

## 4. 생명주기를 가진 구조체 사용

-   **적절한 사용**: `struct Foo<'a> { x: &'a i32 }`와 같이 구조체에 생명주기를 명시하는 것은 기존 데이터에 대한 뷰(view)를 제공하거나, 데이터를 소유하지 않고 빌려서 사용하는 반복자(iterator) 등을 구현할 때 필요하다.
-   **초보자의 함정**: 구조체가 데이터를 "소유"해야 하는 상황에서는 불필요하게 참조와 생명주기를 사용하려 하지 말고, `String`, `Vec<T>`와 같은 소유 타입을 사용해야 한다. 이 경우 생명주기 명시가 필요 없다.
-   **복잡성 관리**: 생명주기를 가진 구조체는 강력하지만 복잡성을 수반하므로, 데이터 구조를 재설계하거나 소유 타입을 활용하여 불필요한 복잡성을 피하는 방법을 우선적으로 고려한다.

# Rust 코딩 가이드라인: 비동기 프로그래밍 (Asynchronous Programming)

Rust의 비동기 프로그래밍은 `async/await` 문법을 통해 지원되며, 고성능 네트워크 서비스나 I/O 중심 애플리케이션 개발에 널리 사용된다. 그러나 그 유연성과 저수준 제어 능력 때문에 몇 가지 함정이 존재한다.

## 1. 비동기 런타임 내에서의 블로킹 연산

-   **치명적인 실수**: `async` 함수나 `Future` 내에서 블로킹 I/O 연산이나 CPU 집약적인 작업을 직접 수행하는 것은 피해야 한다. 이는 전체 시스템의 응답성을 심각하게 저해하거나 교착 상태(deadlock)를 유발할 수 있다.
-   **해결책**: 비동기 I/O 라이브러리(예: `tokio::fs`, `tokio::net`)를 사용하거나, 블로킹 작업이 불가피할 경우 `tokio::task::spawn_blocking`과 같은 함수를 사용하여 해당 작업을 별도의 블로킹 스레드 풀로 이전해야 한다.

## 2. 블로킹을 유발할 수 있는 `Drop` 구현

-   **예기치 않은 성능 저하**: 타입의 `Drop` 트레이트 구현 내에서 블로킹 연산을 수행하는 것을 주의해야 한다. 이는 예기치 않은 성능 저하나 교착 상태를 초래할 수 있다.
-   **권장 사항**: 비동기 컨텍스트에서 리소스 정리가 필요하다면, 명시적인 비동기 정리 메서드를 제공하고 `Drop`에서는 최소한의 작업만 수행하거나, 비동기 `Drop` 패턴을 고려해야 한다.

## 3. 스택 공간을 초과하는 거대한 `Future`

-   **스택 오버플로우**: 매우 복잡하거나 긴 `async` 함수, 또는 재귀적인 `async` 호출은 상태 기계의 크기를 지나치게 크게 만들어 스택 오버플로우를 유발할 수 있다.
-   **해결책**: `Box::pin`을 사용하여 `Future`를 힙에 할당할 수 있다 (`Box<dyn Future<...> + Send + 'static>`). `clippy::large_futures` 린트도 활용한다.

## 4. `Send + 'static` 경계의 어려움과 비동기 코드의 "전염성"

-   **데이터 전달 제약**: `tokio::spawn`과 같이 새로운 태스크를 생성하는 경우, 해당 태스크에 전달되는 `Future`는 종종 `Send + 'static` 트레이트 경계를 만족해야 한다. 이는 비-'static 데이터를 비동기 태스크에서 직접 참조하기 어렵게 만든다.
-   **해결책**: 데이터의 소유권을 태스크로 옮기거나, `Arc`를 사용하여 공유 소유권을 설정해야 한다.
-   **`async`의 전염성**: 한 함수가 `async`가 되면 이를 호출하는 함수도 `async`가 되거나 `Future`를 직접 처리해야 하는 경향이 있어, 프로젝트 전체에 `async` 사용이 확산될 수 있다.

## 5. `tokio::select!` 매크로의 오용

-   **미묘한 버그**: `tokio::select!` 매크로는 여러 비동기 연산을 동시에 기다리는 데 유용하지만, 잘못 사용하면 미묘한 버그를 유발할 수 있다.
-   **취소 동작 이해**: `Future`가 드롭되면 해당 작업은 취소된다. `select!` 내부에서 상태를 가지는 `Future`를 다룰 때는 해당 상태가 취소 시에도 일관성을 유지하도록 주의해야 한다. 필요시 `Future`를 `Box::pin`하거나, `select!` 외부에서 상태를 관리한다.

## 6. `.await`의 누락

-   **작업 미실행**: 비동기 함수를 호출하면 `Future`가 반환되는데, 이 `Future`는 `.await`를 사용하여 실행될 때까지 아무 작업도 수행하지 않는다. `.await`를 누락하면 비동기 작업이 전혀 실행되지 않아 예상치 못한 동작으로 이어질 수 있다.
-   **컴파일러 경고**: 컴파일러가 `.await` 누락에 대해 경고를 발생시키지만, 모든 경우를 잡아내지는 못할 수 있으므로 주의가 필요하다.

# Rust 코딩 가이드라인: 동시성 및 병렬성 (Concurrency and Parallelism)

Rust는 "두려움 없는 동시성(fearless concurrency)"을 주요 특징 중 하나로 내세운다. 이는 컴파일 시점에 데이터 경쟁(data race)을 방지하는 강력한 소유권 및 타입 시스템 덕분이다. 그러나 데이터 경쟁 외의 동시성 문제, 예를 들어 교착 상태(deadlock)나 논리적 경쟁 조건(logical race condition)은 여전히 개발자의 책임 영역이다.

## 1. `std::sync::Mutex` 대 `tokio::sync::Mutex`

-   **목적 차이**: `std::sync::Mutex`는 스레드를 블로킹하는 동기식 뮤텍스이며, `tokio::sync::Mutex`는 비동기 태스크를 위해 설계된 뮤텍스이다.
-   **주의 사항**: 비동기 코드 내에서 `std::sync::Mutex`의 락을 `.await` 지점 너머로 유지하면 스레드 블로킹을 유발할 수 있으므로 극히 주의해야 한다. `tokio::sync::Mutex`는 패닉 시 뮤텍스를 오염시키지 않고 락을 해제하므로 데이터 일관성 측면에서 주의가 필요하다.
-   **선택 기준**: 동기 코드와 비동기 코드의 경계를 명확히 인지하고 각 컨텍스트에 적합한 뮤텍스를 선택해야 한다.

## 2. `Arc<Mutex<HashMap>>` 안티패턴과 대안

-   **성능 병목**: `Arc<Mutex<HashMap<K, V>>>` 패턴은 여러 스레드에서 해시맵을 공유하고 수정하기 위한 간단한 방법이지만, **굵은 입자 잠금(coarse-grained locking)**으로 인해 성능 병목을 유발할 수 있다.
-   **대안**:
    -   `std::sync::RwLock`: 읽기 작업이 많은 경우 성능 향상.
    -   세분화된 락(Fine-grained locking): 각 항목에 개별 락 사용 (구현 복잡).
    -   동시성 해시맵(`dashmap` 등): 내부적으로 세분화된 락을 사용하여 높은 동시성 제공.
    -   액터 모델(Actor Model) 또는 메시지 전달: 공유 상태 자체를 피하고 메시지를 통해 통신.

## 3. 미묘한 교착 상태(Deadlock) 시나리오

-   **`RwLock`의 공정성**: `parking_lot::RwLock` (및 `std::sync::RwLock`)은 라이터 기아 방지를 위해 라이터 대기 중 새로운 리더 락 획득을 막을 수 있어, 중첩된 락 시도 시 교착 상태를 유발할 수 있다.
-   **`if let` 또는 임시 값의 생명주기**: `MutexGuard`와 같은 락 가드 객체의 생명주기가 예상보다 오래 유지되어 교착 상태를 유발할 수 있으므로, 명시적으로 가드를 변수에 바인딩하고 스코프를 명확히 하는 것이 좋다.

## 4. `unsafe` 코드 또는 FFI에서의 데이터 경쟁

-   **안전성 책임**: Rust의 안전성 보장은 `safe Rust` 코드에만 적용된다. `unsafe` 블록 내에서는 프로그래머가 메모리 안전성을 직접 책임져야 한다.
-   **위험**: 원시 포인터 오용이나 외부 C 라이브러리와의 FFI(Foreign Function Interface) 호출 시 스레드 안전하지 않은 함수를 동기화 없이 호출하면 데이터 경쟁이 발생하여 정의되지 않은 행동(Undefined Behavior)으로 이어질 수 있다.

## 5. 원자적 연산(`Atomics`) 및 메모리 순서(`Memory Ordering`)의 오용

-   **사용 난이도**: 원자적 연산은 락 없는(lock-free) 프로그래밍을 위한 저수준 동기화 프리미티브이지만, 올바르게 사용하는 것은 매우 어렵다.
-   **위험**: 잘못된 메모리 순서(`Ordering`) 지정은 컴파일러나 CPU의 예기치 않은 명령어 재배치로 미묘한 데이터 경쟁이나 일관성 문제를 유발할 수 있다.
-   **권장 사항**: 대부분의 경우 뮤텍스나 채널과 같은 고수준 동기화 도구를 사용하는 것이 더 안전하고 생산적이다. 락 없는 프로그래밍은 매우 높은 수준의 검증과 테스트가 필요하다.

# Rust 코딩 가이드라인: 트레이트, 제네릭, API 설계 고려사항 (Traits, Generics, and API Design Considerations)

Rust의 트레이트와 제네릭은 코드 재사용성과 추상화를 위한 강력한 도구이다. 그러나 이를 잘못 사용하면 오히려 코드의 복잡성을 높이고 성능에 부정적인 영향을 미칠 수 있다. "제로 코스트 추상화"라는 Rust의 원칙 이면에는 컴파일 타임 비용과 설계 복잡성이라는 숨겨진 비용이 존재할 수 있음을 인지해야 한다.

## 1. 지나치게 복잡하거나 비표준적인 제네릭 경계 및 트레이트 계층

-   **문제점**: 제네릭 타입 파라미터에 지나치게 많은 트레이트 경계(trait bounds)를 설정하거나, 복잡한 트레이트 상속 구조를 만드는 것은 API 사용성을 저해하고 컴파일 시간을 늘리며, 컴파일 오류 메시지를 이해하기 어렵게 만든다.
-   **권장 사항**: 때로는 더 간단한 제네릭 인터페이스나 구체적인 타입을 사용하는 것이 더 나은 해결책일 수 있다. API 설계 시에는 사용자 관점에서 명확성과 사용 편의성을 우선적으로 고려해야 한다.

## 2. 성능 트레이드오프: 단형성화(Monomorphization) 부풀림 대 동적 디스패치 오버헤드

Rust에서 다형성을 구현하는 주된 방법에는 제네릭을 통한 정적 디스패치와 트레이트 객체를 통한 동적 디스패치가 있다. 각각은 성능과 코드 크기 측면에서 다른 트레이드오프를 가진다.

-   **제네릭 (정적 디스패치)**:
    -   **성능**: 컴파일 시점에 코드가 복제(단형성화)되어 실행 시점 오버헤드가 거의 없다.
    -   **바이너리 크기**: 동일한 제네릭 코드가 여러 타입에 사용될 경우, 복제된 코드로 인해 최종 바이너리 크기가 커질 수 (코드 부풀림).
-   **트레이트 객체 (`dyn Trait`, 동적 디스패치)**:
    -   **성능**: 런타임에 가상 메서드 테이블(vtable)을 통해 실제 구현을 찾아 호출하므로 약간의 실행 시점 오버헤드가 발생한다.
    -   **바이너리 크기**: 코드 중복이 줄어들어 바이너리 크기를 줄일 수 있다.
    -   **유연성**: 런타임에 다양한 타입을 동일한 인터페이스로 다룰 수 있는 유연성을 제공한다.
    -   **고려 사항**: 일반적으로 힙 할당(`Box<dyn Trait>`)이 필요하며, `Sized` 제약으로 인해 객체 안전성(object safety) 규칙을 따라야 한다.
-   **`impl Trait`**:
    -   **특징**: 함수 인자나 반환 타입 위치에서 사용되어, 구체적인 타입을 명시하지 않고 특정 트레이트를 구현하는 타입임을 나타낸다. 주로 정적 디스패치를 사용하며 API를 단순화하는 데 도움이 된다.
    -   **주의 사항**: 반환 위치에서의 `impl Trait`은 때때로 컴파일러가 생성하는 익명 타입과 관련된 숨겨진 타입 소거 및 드롭 글루(drop glue)로 인해 미묘한 오버헤드를 유발할 수 있다. 반복적으로 호출되거나 생명주기가 중요한 객체를 반환하는 경우 프로파일링을 통해 검증해야 한다.
-   **선택 기준**: 성능이 중요한 경로에서는 프로파일링을 통해 정적 디스패치와 동적 디스패치 중 적절한 것을 선택해야 한다. 바이너리 크기가 문제라면 동적 디스패치를 고려할 수 있다.

## 3. 객체 안전성 규칙 탐색 및 실제 영향

트레이트를 트레이트 객체(`dyn Trait`)로 사용하려면 해당 트레이트가 **객체 안전(object safe)**해야 한다. 객체 안전성은 컴파일러가 트레이트 객체를 통해 메서드를 호출할 수 있도록 보장하는 규칙들의 집합이다.

-   **주요 규칙**:
    -   메서드가 `Self` 타입을 직접 반환하지 않아야 한다 (예: `fn clone(&self) -> Self`는 객체 안전하지 않음).
    -   메서드에 `Self: Sized` 제약이 없어야 한다 (트레이트 객체는 `Sized`가 아니기 때문).
    -   메서드가 `Self` 타입 외의 제네릭 타입 파라미터를 갖지 않아야 한다.
    -   모든 메서드는 수신자(receiver)로 `self`, `&self`, `&mut self`, `Box<Self>` 등을 가져야 한다.
-   **위반 시**: 이러한 규칙을 위반하는 트레이트는 `dyn Trait`으로 사용할 수 없어 동적 디스패치가 불가능하다.
-   **설계 고려**: 트레이트 설계 시 동적 디스패치가 필요할 가능성을 염두에 두고 객체 안전성 규칙을 준수하도록 노력해야 한다. 객체 안전하지 않은 메서드가 반드시 필요하다면, 해당 메서드에 `where Self: Sized` 제약을 추가하여 트레이트 객체로 사용될 때는 호출할 수 없도록 분리하는 방법을 고려할 수 있다.

# Rust 코딩 가이드라인: `unsafe` 코드: 고급 고려사항 및 책임 (unsafe Code: Advanced Considerations and Responsibilities)

Rust의 핵심적인 안전성 보장은 `safe` 코드에 국한된다. `unsafe` 키워드는 컴파일러의 특정 안전 장치들을 해제하여 저수준 프로그래밍, FFI, 또는 성능 최적화를 가능하게 하지만, 동시에 프로그래머에게 메모리 안전성을 직접 책임지도록 요구한다. `unsafe` 코드 내에서의 실수는 정의되지 않은 행동(Undefined Behavior, UB)을 유발하여 프로그램 전체를 예측 불가능한 상태로 만들 수 있다.

## 1. `unsafe` 블록 내 불변 조건에 대한 잘못된 가정

-   **의미**: `unsafe`는 컴파일러의 정적 분석에 의한 제약을 푸는 것이지, Rust의 메모리 안전 규칙 자체가 사라지는 것을 의미하지 않는다. 프로그래머는 `unsafe` 블록 내의 코드가 Rust의 메모리 모델과 안전성 불변 조건(safety invariants)을 위반하지 않음을 스스로 보증해야 한다.
-   **위험**: 이를 위반하면 UB가 발생하며, 이는 단순한 크래시를 넘어 데이터 손상, 보안 취약점 등 다양한 형태로 나타날 수 있고, FFI 경계를 넘어 다른 언어로 작성된 코드에까지 영향을 미칠 수 있다.
-   **권장 사항**: `unsafe` 블록은 가능한 한 최소한으로 유지하고, 해당 블록이 안전한 이유(즉, 어떤 불변 조건들을 만족시키는지)를 명확히 문서화하는 것이 필수적이다.

## 2. 일반적인 정의되지 않은 행동(UB) 함정

널 포인터 역참조 외에도 `unsafe` 코드에서 발생할 수 있는 다양한 UB 함정들이 존재한다.

-   **잘못된 포인터 연산 및 역참조**: 유효하지 않은 메모리 주소(댕글링 포인터)에 접근하거나, 데이터 타입에 맞지 않게 정렬되지 않은(misaligned) 포인터를 역참조하는 행위는 UB이다.
-   **데이터 경쟁(Data Races)**: `unsafe` 코드 내에서 적절한 동기화 없이 여러 스레드가 공유된 가변 상태에 동시에 접근하는 경우 데이터 경쟁이 발생하며, 이는 UB이다.
-   **잘못된 타입 변환 (`core::mem::transmute`)**: 서로 다른 레이아웃을 가진 타입 간의 무분별한 변환, 유효하지 않은 `enum` 판별자(discriminant)나 `boolean` 값을 생성하는 변환, 포인터와 정수 간의 안전하지 않은 변환 등은 UB를 유발할 수 있다.
-   **FFI(Foreign Function Interface) 계약 위반**: 외부 C 함수 등을 호출할 때 잘못된 호출 규약(ABI)을 사용하거나, 함수가 기대하는 데이터 레이아웃과 다른 데이터를 전달하거나, Rust와 다른 예외 처리 방식을 혼용하는 경우 UB가 발생할 수 있다.
-   **포인터 앨리어싱(Aliasing) 규칙 위반**: Rust는 `&mut T` 참조가 해당 데이터에 대한 유일한 가변 접근 경로임을 강력하게 가정한다. `unsafe` 코드를 통해 이 규칙을 위반하여 여러 개의 가변 참조가 동시에 존재하거나, 가변 참조와 불변 참조가 부적절하게 공존하면 UB가 발생할 수 있다. `Box<T>`, `&mut T`, `&T`는 LLVM의 `noalias` 모델을 따른다 (단, `&T` 내에 `UnsafeCell<U>`가 있는 경우는 예외). C/C++의 포인터 사용 관행을 Rust의 `unsafe` 코드에 그대로 적용하려다가는 Rust 고유의 앨리어싱 규칙을 위반하여 UB를 일으키기 쉽다.
-   **컴파일러 내장 함수(Intrinsics)의 오용**: 컴파일러 내장 함수는 특정 저수준 작업을 위해 제공되지만, 그 사용 계약을 위반하면 UB를 유발할 수 있다.
-   **유효하지 않은 값 생성**: 특정 타입은 유효한 값의 범위가 정해져 있다 (예: `NonNull<T>`는 `null`이 아니어야 하고, `bool`은 `0` 또는 `1`이어야 함). `unsafe` 코드를 통해 이러한 타입에 유효 범위를 벗어나는 값을 생성하면 UB이다.
-   **참고**: `Rustonomicon` 및 UB 관련 공식 문서를 숙지하고, UB 가능성이 있는 모든 코드를 극도로 신중하게 작성하고 검토해야 한다.

## 3. `unsafe` 코드 최소화 및 안전한 추상화로 래핑

-   **범위 최소화**: `unsafe` 코드의 범위는 가능한 한 작게 유지하는 것이 중요하다.
-   **안전한 API로 래핑**: `unsafe` 로직이 필요하다면, 이를 잘 정의된 인터페이스를 가진 안전한 API로 감싸서 외부에서는 `safe Rust` 코드처럼 사용할 수 있도록 추상화하는 것이 최선의 방법이다. 이렇게 하면 `unsafe` 코드의 위험성을 특정 모듈이나 함수로 국한시키고, 나머지 코드베이스의 안전성을 유지할 수 있다.
-   **`unsafe` 트레이트**: `unsafe` 트레이트를 구현할 때도 해당 트레이트가 요구하는 안전성 계약(safety contract)을 철저히 지켜야 한다. `unsafe`는 최후의 수단으로 사용되어야 하며, 사용 시에는 그 필요성과 안전성을 명확히 입증할 수 있어야 한다.

## 4. Miri 및 새니타이저 활용을 통한 검증

`unsafe` 코드의 정확성을 검증하기 위해 다음과 같은 도구들을 활용할 수 있다.

-   **Miri**: Rust 프로그램의 UB를 탐지하는 인터프리터이다. `cargo miri test`와 같이 사용하여 테스트 스위트 실행 중 발생하는 UB를 찾아낼 수 있다. `Miri`는 특히 앨리어싱 위반, 정렬되지 않은 접근, 유효하지 않은 값 사용 등 다양한 종류의 UB를 탐지하는 데 효과적이다.
-   **새니타이저(Sanitizers)**: C/C++ 개발에 사용되는 `AddressSanitizer(ASan)`, `ThreadSanitizer(TSan)`, `MemorySanitizer(MSan)`, `Valgrind` 등도 FFI를 통해 C/C++ 코드와 상호작용하는 Rust 프로그램에서 UB를 찾는 데 도움이 될 수 있다.
-   **한계**: 이러한 도구들은 특정 실행 경로에서 UB를 탐지할 뿐, 코드 전체의 완전한 안전성을 보장하지는 않는다. 따라서 `unsafe` 코드를 포함하는 모듈에 대해서는 철저하고 포괄적인 테스트 케이스 작성이 동반되어야 한다.
