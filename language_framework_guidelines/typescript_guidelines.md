# TypeScript 사용 시 주의사항 및 가이드라인

이 문서는 TypeScript 프로젝트에서 `any` 타입 사용을 지양하고, 타입 안전성을 확보하기 위한 가이드라인을 제공합니다.

## 1. `any` 타입: 지속적인 위험과 `unknown` 대안

`any` 타입은 TypeScript의 타입 검사를 비활성화하는 "탈출구"입니다. 이는 런타임 오류의 주요 원인이 되며, 특히 복잡한 시스템이나 공유 라이브러리에서 사용될 경우 코드베이스 전체로 "감염"되어 타입 안전성을 저해할 수 있습니다.

### `any` 타입 사용 지양

* `any`는 타입 검사를 무력화하여 예상치 못한 런타임 오류를 유발할 수 있습니다.
* 공유 함수나 타입 정의에 `any`가 포함되면, 해당 코드를 사용하는 다른 부분의 타입 안전성까지 잃게 됩니다.
* **예시**:

  ```typescript
  function add(a: any, b: any): any {
    return a + b;
  }
  const result = add(5, "10"); // TypeScript 오류 없이 컴파일되지만, result는 "510"이 됩니다.
  ```

### `unknown` 타입 활용

예측 불가능한 데이터(예: 외부 API 응답, 사용자 생성 콘텐츠, `JSON.parse()` 결과)를 다룰 때는 `any` 대신 `unknown`을 사용해야 합니다. `unknown`은 값에 대한 어떠한 작업도 수행하기 전에 개발자가 명시적인 타입 검사(타입 가드)를 수행하도록 강제하여 타입 안전성을 유지합니다.

* **타입 가드 사용**: `typeof`, `instanceof`, 사용자 정의 타입 가드 또는 Zod와 같은 스키마 유효성 검사 라이브러리를 사용하여 `unknown` 값을 안전하게 처리합니다.
* **예시**:

  ```typescript
  async function fetchData(): Promise<unknown> {
    // ... 외부 API 호출 또는 예측 불가능한 데이터 반환
    return { status: 'success', data: { message: 'Hello' } };
  }

  async function processData() {
    const data = await fetchData();
    if (typeof data === 'object' && data !== null && 'status' in data && typeof (data as { status: unknown }).status === 'string') {
      // data는 이제 더 구체적인 타입으로 축소됩니다.
      console.log((data as { status: string }).status);
    } else {
      console.error("Unexpected data format");
    }
  }
  ```

---

## 2. TypeScript 컴파일러 설정 및 엄격성 미세 조정

`tsconfig.json`의 `strict: true` 옵션은 TypeScript의 강력한 타입 검사를 활성화하는 핵심입니다. 이 외에도 개별적인 엄격성 플래그들을 이해하고 미세 조정하는 것은 코드 품질과 안전성을 극대화하는 데 중요합니다.

### `strict` 모드 활성화 강력 권장

* `tsconfig.json`에서 전체 `strict` 모드를 활성화하는 것을 강력히 권장합니다. `strict` 모드는 `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`, `strictPropertyInitialization`, `noImplicitReturns`, `useUnknownInCatchVariables` 등 여러 엄격한 타입 검사 플래그를 포함하여 강력한 함수 계약을 시행하는 데 매우 시너지 효과가 있습니다.
* **`strict` 모드 플래그의 시너지**:
  * `noImplicitAny`: 함수 매개변수와 변수가 정의된 타입을 갖도록 보장하여 `any`가 스며드는 것을 방지합니다.
  * `strictNullChecks`: `null` 및 `undefined`에 대한 명시적인 처리를 강제하여 타입 안전성을 크게 향상시킵니다.
  * `strictFunctionTypes`: 함수 매개변수 검사를 엄격하게 수행하여 런타임 오류를 방지합니다.
  * `strictPropertyInitialization`: 클래스 속성이 생성자에서 초기화되거나 초기화자를 가져야 함을 강제합니다.
  * `noImplicitReturns`: 함수가 `void` 또는 `any` 이외의 반환 타입을 선언하는 경우, 모든 코드 경로가 `return` 문으로 끝나도록 강제합니다.
  * `useUnknownInCatchVariables`: `catch` 블록에서 포착된 오류를 `unknown`으로 타이핑하도록 강제하여 더 안전한 오류 처리를 유도합니다.
* 이 중 하나라도 비활성화되면 안전망이 약화되어 런타임 오류로 이어질 수 있습니다. 개별 플래그를 관리해야 하는 경우, 각 플래그의 상호 작용을 잘 이해해야 합니다.

### 개별 엄격성 플래그 문제점 및 해결 지침

1. **`strictFunctionTypes`**:
    * **문제점**: 비활성화 시 함수 매개변수 검사가 이변성(bivariant)으로 수행되어 런타임 오류를 유발할 수 있습니다.
    * **해결 지침**: `strict: true`를 통해 활성화하여 함수 타입의 안전성을 보장합니다.
2. **`strictPropertyInitialization`**:
    * **문제점**: 클래스 속성 초기화 규칙을 잘못 관리하면 확정 할당 단언(`!`)의 과용으로 이어질 수 있습니다.
    * **해결 지침**: `property!: Type`과 같은 확정 할당 단언은 외부 수단(예: 프레임워크의 생명주기 메서드, 의존성 주입)에 의해 초기화가 실제로 보장되는 경우에만 드물게 사용해야 합니다. 과용은 억제된 문제를 나타내며, 안전한 이유를 문서화해야 합니다.
3. **`noUncheckedIndexedAccess`**:
    * **문제점**: 이 플래그 없이 인덱스를 통해 배열 요소나 객체 속성에 접근하면 `undefined`가 발생할 수 있습니다.
    * **해결 지침**: 활성화 시 키가 존재한다고 알려져 있고 배열이 희소하지 않은 경우를 제외하고는 인덱싱된 접근 후 항상 `undefined`를 확인해야 합니다.
4. **`exactOptionalPropertyTypes`**:
    * **문제점**: 비활성화 시 선택적 속성(`prop?: string`)이 명시적 타입의 일부가 아니더라도 `undefined`를 할당받을 수 있게 허용하여 문제를 가릴 수 있습니다.
    * **해결 지침**: 활성화하여 선택적 속성에 `undefined`를 할당하려면 명시적으로 `string | undefined`와 같이 유니온 타입으로 선언하도록 합니다.

### `tsconfig.json` 관리

* `tsconfig.json` 파일, 특히 엄격성 설정은 팀 내 코드 품질 및 안전에 대한 계약 역할을 합니다. 일관성 없거나 지나치게 느슨한 설정은 다양한 코드 품질과 예방 가능한 런타임 오류 증가로 이어질 수 있습니다.
* 이러한 설정 변경은 코드베이스에 광범위한 영향을 미칠 수 있으므로, 팀 토론과 신중한 선택의 대상으로 삼아야 합니다. 레거시 프로젝트에서 더 엄격한 설정을 점진적으로 채택하는 것은 실현 가능합니다.

---

## 3. 타입 단언: `as`가 부채가 될 때

타입 단언(예: `value as Type`)은 컴파일러에게 "내가 당신보다 타입을 더 잘 알고 있으니 나를 믿어라"라고 말하는 방법입니다. 이는 실제 타입 불일치로 인한 컴파일러 오류를 억제하여 런타임 오류로 이어질 수 있습니다. 이중 단언(`value as unknown as DesiredType`)은 타입을 강제하는 더 강력한 방법이며, 이는 심각한 코드 스멜로 간주됩니다.

### 타입 단언의 위험성

* 컴파일러의 타입 안전성 검사를 무력화하여 런타임에 `TypeError`와 같은 오류를 발생시킬 수 있습니다.
* **예시**:

  ```typescript
  const apple = {} as string;
  apple.replaceAll('seed', 'diamond'); // 컴파일은 되지만 런타임에 TypeError 발생
  ```

* 이중 단언(`as unknown as`)은 원래 타입과 대상 타입 간의 호환성 검사를 완전히 무시하게 만듭니다. 이는 "TypeScript가 변환할 수 없다고 생각하는 타입 간 변환을 위한 해킹"이며, 일반적으로 무언가 잘못되었다는 신호입니다.
* 리팩토링 시 실제 데이터 구조나 타입이 변경되어도 단언은 컴파일러 검사를 침묵시키므로, 런타임 오류가 발생할 수 있습니다.

### 타입 단언 사용 지침

1. **타입 축소 우선**:
    * 타입이 너무 광범위할 때는 단언보다 타입 축소(Type Narrowing)를 우선해야 합니다.
    * 타입 가드(`typeof`, `instanceof`, `in` 연산자), 판별된 유니온(Discriminated Unions), 또는 사용자 정의 타입 가드(`value is Type`)를 사용하여 특정 코드 블록 내에서 안전하게 타입을 축소합니다.
2. **정당화된 불가피한 시나리오에만 단언 사용**:
    * 타입 단언은 개발자가 컴파일러가 추론할 수 없는 타입에 대한 명확한 지식을 가지고 있을 때(예: 타입이 지정되지 않은 JavaScript 레거시 코드, `document.getElementById`의 반환 타입, 외부 API 응답 구조에 대한 특정 지식) 마지막 수단으로 사용해야 합니다.
    * 모든 단언에는 해당 단언이 안전하고 필요한 이유를 설명하는 주석이 반드시 동반되어야 합니다.
3. **이중 단언(`as unknown as`)은 심각한 위험 신호**:
    * `as unknown as DesiredType`의 모든 인스턴스는 코드 검토 중에 집중적인 조사를 받아야 합니다.
    * 이중 단언에 의존하기 전에 기존 타입을 리팩토링하거나 더 강력한 타입 가드를 사용하는 등 모든 대안적인 타이핑 솔루션을 먼저 고려해야 합니다. 이는 종종 타입 설계의 더 깊은 문제를 나타냅니다.

### 타입 부채 및 리팩토링

타입 단언이 많은 코드베이스는 리팩토링 작업 중에 취약하고 오류가 발생하기 쉽습니다. 단언은 컴파일러의 검사를 우회하므로, 기본 데이터 구조가 변경되어도 단언이 유효하지 않게 될 수 있으며, 이는 런타임 오류로 이어집니다. 따라서 코드베이스의 단언 수를 최소화하기 위해 노력해야 합니다. 높은 단언 밀도는 부실한 타입 설계 또는 "타입 부채"의 강력한 지표가 될 수 있습니다.

---

## 4. 엄격한 null 검사 및 선택적 속성

`strictNullChecks` 컴파일러 옵션이 비활성화되어 있으면, TypeScript는 `null` 또는 `undefined` 값이 변수에 할당되거나 함수 매개변수로 전달될 때 오류를 발생시키지 않습니다. 이는 런타임에 `TypeError`와 같은 예기치 않은 오류를 유발할 수 있습니다.

### 문제점 예시

* `strictNullChecks`가 비활성화된 경우:

  ```typescript
  let name: string = "Alice";
  name = null; // 오류 없음, 런타임에 문제 발생 가능
  ```

* 객체의 선택적 속성에 대한 안전하지 않은 접근:

  ```typescript
  interface User {
    name: string;
    email?: string; // 선택적 속성
  }
  const user: User = { name: "Bob" };
  console.log(user.email.toUpperCase()); // email이 undefined일 수 있으므로 런타임 오류 발생 가능
  ```

### 조건부 타입 안전성 확보 지침

1. **`tsconfig.json`에서 `strictNullChecks` 활성화**:
    * 이 옵션을 `true`로 설정하면 `null` 및 `undefined`에 대한 명시적인 처리를 강제하여 타입 안전성을 크게 향상시킵니다.
    * **권장 설정**:

      ```json
      {
        "compilerOptions": {
          "strictNullChecks": true
        }
      }
      ```

2. **선택적 속성 및 `undefined` 이해**:
    * 객체 속성이 선택적(`?`)으로 선언되면 해당 속성은 `undefined`를 포함할 수 있음을 이해하고, 접근하기 전에 반드시 `undefined` 여부를 확인해야 합니다.
3. **`!` (Non-null Assertion Operator) 사용 지양**:
    * `!` 연산자는 컴파일러에게 해당 값이 `null` 또는 `undefined`가 아님을 확신시킨다고 "단언"하는 것입니다. 이는 타입 단언과 유사하게 컴파일러 검사를 우회하므로, 실제 런타임에 `null` 또는 `undefined`가 될 경우 예기치 않은 오류를 유발할 수 있습니다.
    * 가능한 한 `!` 대신 타입 가드나 선택적 체이닝을 사용해야 합니다.
4. **선택적 체이닝 (`?.`) 및 Nullish Coalescing (`??`) 활용**:
    * **선택적 체이닝 (`?.`)**: 객체의 속성에 안전하게 접근할 때 사용합니다. 속성이 `null` 또는 `undefined`이면 즉시 `undefined`를 반환하여 런타임 오류를 방지합니다.

      ```typescript
      const user = { profile: { email: "test@example.com" } };
      const email = user?.profile?.email; // profile이 없어도 오류 발생 안 함
      ```

    * **Nullish Coalescing (`??`)**: `null` 또는 `undefined` 값에 대한 기본값을 할당할 때 사용합니다. `||` 연산자와 달리 `0`이나 `''` (빈 문자열)과 같은 falsy 값은 기본값으로 간주하지 않습니다.

      ```typescript
      const userName = null;
      const displayName = userName ?? "Guest"; // displayName은 "Guest"
      ```

---

## 5. 타입 별칭 및 인터페이스

TypeScript에서 타입 별칭(`type`)과 인터페이스(`interface`)는 모두 타입 정의에 사용되지만, 미묘한 차이와 권장 사용 사례가 있습니다.

### 타입 별칭 (`type`)

타입 별칭은 기존 타입에 새 이름을 부여하는 데 사용됩니다. 유니온 타입, 튜플 타입, 함수 타입 등 복잡한 타입을 간결하게 표현할 때 유용합니다.

* **주요 특징**:
  * 원시 타입, 유니온, 튜플, 함수, 객체 등 모든 타입에 새 이름을 부여할 수 있습니다.
  * 선언 병합(Declaration Merging)이 불가능합니다. 즉, 동일한 이름으로 여러 번 선언할 수 없습니다.
  * 확장(`extends`) 및 구현(`implements`)이 불가능합니다.
  * 재귀적 타입 정의에 유용합니다.
* **예시**:

  ```typescript
  type ID = string | number;
  type Point = [number, number];
  type GreetFunction = (name: string) => string;

  type User = {
    id: ID;
    name: string;
  };
  ```

### 인터페이스 (`interface`)

인터페이스는 주로 객체의 구조를 정의하는 데 사용됩니다. 클래스가 특정 계약을 준수하도록 강제하거나, 객체의 형태를 명확히 할 때 유용합니다.

* **주요 특징**:
  * 객체 타입의 구조를 정의하는 데 특화되어 있습니다.
  * 선언 병합(Declaration Merging)이 가능합니다. 동일한 이름으로 여러 번 선언하면 TypeScript가 자동으로 병합합니다. 이는 라이브러리나 모듈 확장 시 유용합니다.
  * 확장(`extends`) 및 구현(`implements`)이 가능합니다. 클래스가 인터페이스를 구현하거나, 인터페이스가 다른 인터페이스를 확장할 수 있습니다.
* **예시**:

  ```typescript
  interface Person {
    name: string;
    age: number;
  }

  interface Employee extends Person {
    employeeId: string;
  }

  class Developer implements Employee {
    name: string;
    age: number;
    employeeId: string;

    constructor(name: string, age: number, employeeId: string) {
      this.name = name;
      this.age = age;
      this.employeeId = employeeId;
    }
  }
  ```

### `type`과 `interface` 선택 가이드라인

* **객체 타입을 정의할 때는 `interface`를 우선적으로 사용합니다.**
  * 선언 병합 기능 덕분에 라이브러리나 모듈을 확장하거나, 여러 파일에 걸쳐 동일한 객체 타입을 정의할 때 유연성이 높습니다.
  * 클래스와의 관계(`implements`, `extends`)가 명확하여 객체 지향적인 설계에 더 적합합니다.
* **객체 타입 외의 다른 타입(유니온, 튜플, 원시 타입 별칭, 복잡한 함수 시그니처 등)을 정의할 때는 `type`을 사용합니다.**
* **일관성 유지**: 프로젝트 내에서 한 가지 방식을 선택했다면, 특별한 이유가 없는 한 해당 방식을 일관되게 유지하는 것이 중요합니다.

---

## 6. 제네릭: 단순한 플레이스홀더를 넘어서

제네릭 타입 매개변수(예: `<T>`)는 코드의 재사용성과 타입 안전성을 높이는 강력한 도구이지만, 부적절하게 사용될 경우 불필요한 복잡성을 초래하거나 런타임 오류의 원인이 될 수 있습니다.

### 문제점

* **부적절한 제약 조건**: 적절한 제약 조건(예: `<T extends SomeBaseType>`) 없이 제네릭을 사용하면, 함수나 타입이 지나치게 광범위한 입력을 허용하여 `T`가 특정 속성을 가진 것처럼 작동하려고 할 때 런타임 오류를 유발할 수 있습니다.
  * **예시**: `function merge<T, U>(obj1: T, obj2: U)`는 `obj1`과 `obj2`가 객체임을 보장하지 않아 안전하지 않을 수 있습니다.
* **복잡한 시나리오에서의 타입 추론 실패**: 고차 함수, 조건부 타입 내에서의 사용, 깊이 중첩된 제네릭 등 복잡한 시나리오에서는 TypeScript의 제네릭 타입 추론이 실패하여 `{}`, `any`, 또는 `unknown`으로 기본 설정될 수 있습니다.
* **불필요한 추상화**: 단순한 특정 타입이나 유니온 타입으로 충분한 경우에 제네릭을 도입하면 코드가 불필요하게 추상적이고 이해하기 어려워질 수 있습니다.
* **과도한 엔지니어링**: 제네릭을 학습한 후 실제 다형성에 대한 필요성이 제한적이거나 없음에도 불구하고 광범위하게 적용하는 경향이 있습니다. 이는 `function process<T>(data: T): T { ...}`와 같이 실제 이점 없이 인지적 부담만 가중시키는 코드로 이어질 수 있습니다.
* **컴파일 성능 저하**: 매우 복잡하거나 깊이 추론되거나 재귀적인 제네릭 타입이 고밀도로 포함된 코드베이스는 TypeScript 컴파일 성능을 눈에 띄게 저하시킬 수 있습니다.

### 조건부 타입 해결 지침

1. **명확하고 최소한이며 의미 있는 제약 조건 정의**:
    * `extends` 키워드를 사용하여 제네릭 타입 매개변수를 함수나 타입에 필요한 가장 좁은 기능 집합으로 제한해야 합니다. 제약 조건은 제네릭 타입에 대해 수행되는 실제 작업을 반영해야 합니다.
    * **예시**: `function merge<T extends object, U extends object>(obj1: T, obj2: U)`
2. **명시적인 타입 인수 제공**:
    * TypeScript의 추론이 복잡한 시나리오(특히 고차 함수 또는 중첩된 조건부 제네릭)에서 어려움을 겪을 때는 정확성을 보장하기 위해 명시적인 타입 인수를 제공하는 것을 주저하지 마십시오. 잘못 추론되거나 지나치게 광범위한 타입에 의존하는 것을 피해야 합니다.
3. **재사용을 위한 제네릭 타입(유틸리티 타입)의 포괄적인 테스트**:
    * 예상대로 작동하고 타입 안전성을 유지하는지 확인하기 위해 에지 케이스를 포함한 다양한 입력 타입으로 포괄적으로 테스트해야 합니다.
4. **가독성과 정당화될 수 있는 추상화 우선**:
    * 다양한 입력 타입에 대한 코드 재사용성 및 타입 안전성 측면에서 실질적인 이점을 제공하는 경우에만 제네릭을 사용해야 합니다. 제한된 변형에 대해 제네릭 솔루션이 비제네릭 대안보다 읽고 추론하기가 훨씬 더 복잡해진다면, 더 간단한 접근 방식이 종종 더 낫습니다.
5. **제네릭의 신중한 사용 문화 장려**:
    * 항상 "이 제네릭이 실제로 다양한 타입을 안전하고 재사용 가능한 방식으로 처리하는 문제를 해결하는가, 아니면 명확한 이득 없이 복잡성만 추가하는가?"라는 질문을 던져야 합니다.

---

## 7. 조건부 타입: 논리의 미로

조건부 타입(`A extends B ? C : D`)은 TypeScript의 강력한 기능이지만, 복잡하게 사용될 경우 가독성, 디버깅, 유지보수성을 저해하고 컴파일러 성능에 영향을 미칠 수 있습니다.

### 주요 문제점

* **복잡성 및 중첩**: 깊이 중첩되거나 복잡한 재귀 논리를 포함하는 조건부 타입은 읽고 이해하기 매우 어렵습니다. 이는 TypeScript 컴파일러 성능에도 심각한 영향을 줄 수 있습니다.
* **분배성(Distributivity)**: 기본적으로 조건부 타입은 유니온 타입이 주어졌을 때 일반(naked) 타입 매개변수에 대해 분배됩니다. 이를 인지하지 못하면 예상치 못한 타입 확인으로 이어질 수 있습니다.
  * **예시**: `type ToArray<Type> = Type extends any ? Type[] : never; type StrArrOrNumArr = ToArray<string | number>;`는 `(string | number)[]`가 아닌 `string[] | number[]`로 확인됩니다.
  * 분배성을 방지하려면 타입을 튜플로 래핑해야 합니다: `type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;`
* **`infer` 키워드 오용**: `infer` 키워드는 강력하지만, 올바른 배치와 사용에 정밀도가 필요하며, 오용 시 `never`, `any` 또는 잘못된 타입 추론과 함께 암호 같은 오류 메시지를 유발할 수 있습니다.
* **순환 종속성**: 의도치 않게 자신을 다시 참조하는 조건부 타입을 정의하여 해결할 수 없는 순환 종속성을 만들 수 있으며, 이는 진단하기 어려운 오류로 이어집니다.
* **조건부 반환 타입 확인 어려움**: TypeScript 컴파일러는 함수의 구현이 제네릭 매개변수에 따라 달라지는 조건부 반환 타입을 올바르게 충족하는지 확인하는 데 어려움을 겪는 경우가 많습니다. 이로 인해 함수 본문 내에서 타입 단언(예: `as ReturnType`)이 필요할 수 있습니다.

### 해결 지침

1. **단순성 추구 및 분해**:
    * 지나치게 복잡한 조건부 타입은 더 작고 잘 명명된 헬퍼 타입으로 분해하여 단순성을 추구하고 복잡성을 해소해야 합니다. 각 헬퍼 타입은 논리의 개별 부분을 처리해야 하며, 가능한 한 깊은 중첩을 피해야 합니다.
2. **분배성 인지 및 관리**:
    * 기본 분배 동작을 인지하고, 유니온에 대한 비분배 동작이 필요한 경우 `[U]` 튜플 래핑 기술을 사용하여 명시적이고 의도적으로 분배성을 관리해야 합니다.
3. **`infer` 키워드 사용 시 엄격한 테스트**:
    * `infer` 키워드를 사용할 때는 에지 케이스와 유니온을 포함한 다양한 입력 타입으로 조건부 타입을 엄격하게 테스트하여 의도한 타입을 올바르게 추출하는지 확인해야 합니다.
4. **조건부 반환 타입에 대한 타입 단언**:
    * 컴파일러가 함수의 조건부 반환 타입을 확인할 수 없는 경우 함수 본문 내에서 타입 단언(예: `returnValue as ExpectedConditionalType<T>`)이 필요할 수 있습니다. 그러나 내부 로직이 이 단언을 엄격하게 보장하는지 확인하고 단언이 필요한 이유를 문서화해야 합니다.

### 추상화 및 문서화

조건부 타입, 특히 `infer` 및 재귀와 결합될 때의 강력함은 매우 추상적인 타입 조작으로 이어질 수 있습니다. 이는 정교한 타입 수준 프로그래밍을 달성할 수 있지만, 이러한 고급 TypeScript 기능에 깊이 정통하지 않은 개발자에게는 종종 불투명하고 "마법처럼" 보이는 코드를 생성합니다.

* **명확한 문서 제공**: 고급 조건부 타입 사용 시 타입의 목적, 논리 및 예제를 설명하는 매우 명확한 문서(예: TSDoc 주석)를 함께 제공하도록 해야 합니다.
* **명확성 우선**: "이 타입은 어떻게 작동하는가?"라는 질문을 장려하는 팀 문화를 조성하고, 과도한 타입 수준의 기교보다는 명확성을 우선시해야 합니다.

### 디버깅 어려움 및 LLM 지침

정교한 조건부 타입은 디버깅이 매우 어려울 수 있습니다. TypeScript의 타입 확인은 내부 컴파일러 프로세스이며, 런타임 JavaScript와 달리 중간 타입 확인을 쉽게 "단계별로 실행"하거나 "콘솔 로그"할 수 없습니다.

* **점진적 접근 방식**: 복잡한 조건부 타입을 구축할 때는 점진적인 접근 방식을 권장합니다. 중간 헬퍼 타입을 별도로 테스트하십시오.
* **TypeScript Playground 활용**: 조건부 타입 논리를 분리하고 실험하기 위해 TypeScript Playground를 광범위하게 활용하십시오.
* **LLM에 대한 지침**: LLM 상호 작용의 경우 지나치게 복잡한 조건부 타입을 생성하는 것은 지양해야 합니다. 대신 문제를 더 작고 타입화 가능한 부분으로 나누어 더 간단하고 검증 가능한 타입 논리를 요청하십시오.
