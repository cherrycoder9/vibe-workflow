# Hono 개발 시 주의사항

Hono는 경량성과 빠른 속도를 자랑하지만, 복잡한 API 구축 시 미들웨어 처리, 컨텍스트 관리, 보안 등에서 주의가 필요합니다.

## 1. 미들웨어 복잡성 탐색

- **실행 순서 마스터하기**: Hono 미들웨어는 "양파 모델"을 따르며, `app.use()` 순서대로 요청 단계에서 위에서 아래로, 응답 단계에서 아래에서 위로 실행됩니다. 오류 핸들러, 유효성 검사, 로깅 등 미들웨어 간 상호 의존성을 고려한 정교한 순서 배치가 중요합니다. `await next()`를 사용하여 비동기 미들웨어의 실행 흐름을 올바르게 제어합니다.
- **타입 안전성 및 `BlankEnv` 회피**: `createMiddleware` 체이닝 시 사용자 정의 컨텍스트 타입이 손실되고 `BlankEnv`로 되돌아가는 문제가 발생할 수 있습니다. `new Hono<UserContext>()`와 같은 Hono 인스턴스 타입 지정이나 `ContextVariableMap` 확장을 고려하되, 런타임 `undefined` 접근 오류를 방지하기 위해 방어적인 코딩 습관을 유지합니다.
- **사용자 정의 유효성 검사 미들웨어**: `@hono/zod-validator`의 `zValidator`는 기본적으로 전체 `ZodError` 객체를 반환하므로, 프로덕션에서는 `hook` 콜백을 사용하여 일관된 오류 응답 형식(예: RFC 7807 Problem Details)을 제공하는 커스텀 유효성 검사 미들웨어를 구축합니다.
- **프로덕션 환경 오류 처리 및 로깅**: `app.onError`를 통해 루트 레벨 오류를 처리하고, 사용자 정의 오류 클래스, 구조화된 오류 응답, 상세 로깅, Sentry 등 외부 모니터링 도구 통합을 통해 프로덕션 등급의 오류 관리 시스템 구축을 고려합니다.

## 2. Hono 컨텍스트 (`c`) 관리 시 주의사항

- **안전한 비동기 수정**: `c.set()`, `c.get()`을 통한 컨텍스트 데이터 공유 시 비동기 미들웨어 간 타이밍 문제에 주의합니다. `AsyncLocalStorage`를 사용하는 `contextStorage()` 미들웨어를 고려할 수 있으나, 이는 논리적 경쟁 조건 자체를 해결하지 않으므로 비동기 작업 완료 순서와 컨텍스트 값 의존 관계를 명확히 이해해야 합니다.
- **`c.set()`, `c.get()`, `c.var` 사용 모범 사례**: `c.var`와 제네릭을 통한 타입 지정(`new Hono<{ Variables: { message: string } }>()`)은 문자열 기반 `c.get()`보다 강력한 타입 안전성을 제공합니다. `ContextVariableMap` 확장은 타입 오류를 숨길 수 있으므로 신중하게 사용하고, 명시적인 타입 관리를 표준으로 삼습니다.

## 3. Hono API 보안 고려 사항

- **기본 인증 이상**: Hono 미들웨어는 인증 로직 구현에 유용하지만, 이를 유일한 보안 계층으로 간주해서는 안 됩니다. "심층 방어" 원칙을 적용하여 라우트 미들웨어 외에 서비스 계층이나 데이터 접근 계층에서 세분화된 권한 부여 로직을 구현합니다. 미들웨어의 우회 가능성, 세분화된 제어의 어려움, 단일 실패 지점 위험을 인지합니다.

## 4. SvelteKit 및 Hono 통합 과제 탐색

- **RPC를 통한 엔드투엔드 타입 안전성**: `hono/client (hc)`를 SvelteKit과 함께 사용하여 타입 안전한 API 호출을 구현합니다. SvelteKit의 `load` 함수나 서버 액션 내에서 `hc` 사용 시 SvelteKit이 제공하는 커스텀 `fetch` 함수를 `hc`에 전달하여 SSR 최적화 및 쿠키/자격 증명 처리를 보장합니다. 모노레포에서 `tsserver` 성능 저하 시, Hono 라우터 타입 직접 추론 대신 OpenAPI 명세 기반 클라이언트 생성이나 타입 미리 컴파일을 고려합니다.
- **아키텍처 결정**: SvelteKit과 Hono를 긴밀하게 결합하는 방식은 초기 개발에 유리하지만, 복잡한 애플리케이션에서는 다중 테넌시, 백그라운드 작업, 다양한 클라이언트 지원 등에서 한계가 있습니다. 별도의 Hono 백엔드를 사용하는 방식은 관심사 분리와 독립적 확장에 유리하지만, 인증 복잡성, 운영 오버헤드, 타입 안전성 손실 가능성이 있습니다. Hono를 마이크로서비스로 활용하는 것은 확장성과 탄력성을 높이지만, 운영 복잡성 증가, 초기 개발 비용 증가, 분산 시스템 문제, 생태계 제약, 과잉 적용 위험이 있습니다. 프로젝트의 현재 및 미래 요구사항을 고려하여 합리적인 아키텍처를 선택합니다.
- **고급 데이터 처리 및 동기화**:
  - **API 응답 스트리밍**: Hono의 `stream()` 헬퍼와 SvelteKit 서버 `load` 함수의 프로미스 반환 기능을 결합하여 대용량 데이터나 실시간 업데이트를 효율적으로 스트리밍하고 인지 성능을 향상시킵니다.
  - **효과적인 캐싱 전략**: Hono 캐싱 미들웨어와 SvelteKit의 내장 캐싱 메커니즘을 포함한 풀스택 캐싱 계층(클라이언트, 애플리케이션, 데이터베이스)을 통합적으로 관리합니다. 캐싱 정책 간의 충돌을 피하고, 데이터 최신성과 성능 목표를 동시에 달성하도록 설계합니다.
  - **프론트엔드 상태 동기화**: 변경 작업 후 `invalidateAll()` 대신 `invalidate(url)`을 사용하여 관련 `load` 함수만 선택적으로 재실행하거나, 낙관적 UI 업데이트, 수동 상태 업데이트를 고려합니다. Hono 백엔드로부터 최신 데이터를 가져와 프론트엔드 상태를 효과적으로 재동기화하는 것이 중요합니다.
- **보안 파일 업로드 및 실시간 통신**:
  - **안전하고 효율적인 파일 업로드**: Hono의 파일 업로드 처리 기능을 활용하되, 클라이언트/서버 양쪽에서 파일 타입/크기 검증, 안전한 파일 저장(웹 루트 외부, 무작위 파일명)을 수행합니다. 대용량 파일은 청크 업로드, 클라이언트 사이드 압축, 웹 워커 활용, 그리고 SvelteKit 액션에서 `request.body`를 Hono 엔드포인트로 직접 스트리밍하는 엔드투엔드 스트리밍을 고려합니다.
  - **WebSocket 통합**: Hono와 SvelteKit 간 WebSocket 통신 구현 시 인증(핸드셰이크 시 쿠키, 연결 수립 후 토큰 전송), 권한 부여, 그리고 특히 서버리스/엣지 환경에서의 상태 관리(Redis, Cloudflare Durable Objects 등 외부 상태 저장소 활용)에 대한 명확한 전략을 수립합니다.
