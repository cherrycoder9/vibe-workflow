# Markdown 작성 가이드라인

Markdown 문서는 가독성과 파서 호환성을 위해 다음 가이드라인을 준수해야 한다. `markdownlint` 도구를 활용하여 일관성을 유지하는 것을 권장한다.

## 공백 및 들여쓰기

- **빈 줄의 오용 및 누락**: 문단, 제목, 목록, 코드 블록 등 블록 요소 주변에는 반드시 하나의 빈 줄을 사용한다. 불필요한 여러 빈 줄은 피한다.
  - 관련 `markdownlint` 규칙: MD012 (연속 빈 줄 제한), MD022 (제목 주변 빈 줄), MD031 (코드 블록 주변 빈 줄), MD032 (목록 주변 빈 줄).
- **후행 공백 및 불필요한 선행 공백**: 줄 끝에 불필요한 공백(후행 공백)을 남기지 않으며, 문단 시작 부분에 의도치 않은 공백이나 탭을 삽입하지 않는다.
  - 관련 `markdownlint` 규칙: MD009 (후행 공백 금지).
- **탭(Hard tabs) 대 공백(Soft tabs)**: 들여쓰기나 정렬 시 탭 문자 대신 공백 문자를 사용한다. 탭 문자는 환경에 따라 다르게 렌더링될 수 있다.
  - 관련 `markdownlint` 규칙: MD010 (하드 탭 금지).
- **목록 들여쓰기 일관성**: 중첩된 목록의 들여쓰기는 일관되게 유지한다. CommonMark는 4칸 공백을 권장하지만, 2칸 공백도 널리 사용되므로 팀 표준을 따른다.
  - 관련 `markdownlint` 규칙: MD005 (목록 들여쓰기 일관성), MD007 (순서 없는 목록 들여쓰기 칸 수).

## 구조적 요소

- **제목: 레벨, 구두점, 마크업**: 제목 수준은 순차적으로 증가해야 하며(예: H1 다음 H2), 제목 끝에 구두점을 사용하거나 내부에 다른 마크업(굵게 등)을 사용하는 것은 피한다. 문서의 첫 줄은 최상위 제목(H1)으로 시작하는 것이 좋다.
  - 관련 `markdownlint` 규칙: MD001 (제목 수준 증가), MD003 (제목 스타일), MD026 (제목 끝 구두점 금지), MD041 (첫 줄 H1).
- **목록: 순서 있는 목록 번호 매기기, 일관된 마커 사용**: 순서 있는 목록은 모든 항목을 `1.`로 시작해도 자동으로 번호가 매겨지므로 이를 권장한다. 순서 없는 목록은 일관된 마커(예: `-` 또는 `*`)를 사용한다.
  - 관련 `markdownlint` 규칙: MD004 (순서 없는 목록 스타일), MD029 (순서 있는 목록 접두사).
- **코드 블록: 주변 빈 줄, 언어 지정자, 백틱 이스케이프**: 구분된 코드 블록(fenced code block)은 위아래로 빈 줄을 추가하고, 구문 강조를 위해 언어 지정자를 명시하는 것이 좋다. 코드 블록 내부에 백틱을 표시하려면 더 많은 수의 백틱으로 감싸야 한다.
  - 관련 `markdownlint` 규칙: MD031 (코드 블록 주변 빈 줄), MD040 (코드 블록 언어 지정자), MD046 (코드 블록 스타일), MD048 (코드 구분자 스타일).

## 콘텐츠 및 링크

- **일반 URL(Bare URL) 대 적절한 링크**: 단순히 URL을 텍스트로 붙여넣기보다는, 의미 있는 텍스트에 하이퍼링크를 거는 것이 좋다.
  - 관련 `markdownlint` 규칙: MD034 (일반 URL 금지).
- **이미지 대체 텍스트(alt text) 및 설명적인 링크**: 모든 이미지에는 이미지를 설명하는 대체 텍스트(alt text)를 제공해야 한다. 링크 텍스트 또한 링크가 가리키는 대상을 명확히 설명해야 한다.
  - 관련 `markdownlint` 규칙: MD045 (이미지 대체 텍스트), MD059 (설명적인 링크 텍스트).
- **마크다운으로 대체 가능한 인라인 HTML 회피**: 간단한 서식을 위해 HTML 태그를 사용하는 것보다 가능한 마크다운 고유 문법을 사용하는 것이 좋다.
  - 관련 `markdownlint` 규칙: MD033 (인라인 HTML 금지).

## 테이블

- **일반적인 구문 오류 (파이프, 하이픈, 빈 줄)**: 테이블은 파이프(`|`)와 하이픈(`-`)을 사용하여 구조를 만들며, 헤더와 구분선 사이에 빈 줄을 넣지 않도록 주의한다. 테이블 위아래로 빈 줄을 추가하여 다른 요소와 구분한다.
  - 관련 `markdownlint` 규칙: MD055 (테이블 파이프 스타일), MD056 (테이블 열 개수), MD058 (테이블 주변 빈 줄).

## 숨겨진 통찰 및 연관 관계

- **파서 호환성 및 렌더링 문제**: 사소한 구문 오류도 다양한 Markdown 파서에서 호환성 문제를 일으킬 수 있다. `markdownlint` 규칙을 준수하면 어떤 환경에서도 일관된 결과물을 보장하고, AI가 문서를 학습하고 처리할 때 혼란을 줄일 수 있다.
- **잠재적인 버그 및 비효율 방지**: `markdownlint` 규칙은 단순한 스타일 제안을 넘어 문서의 유지보수성, 가독성, 협업 효율성을 높이는 안전장치다. 예를 들어, 순서 있는 목록을 `1.`로 시작하거나(MD029), 코드 블록에 언어 지정자를 명시하고(MD040), 설명적인 링크 텍스트를 사용하는 것(MD034, MD059)은 문서의 장기적인 건강성과 생산성 향상에 기여한다.

## VSCode markdownlint 효과적으로 활용하기

VSCode 환경에서 `markdownlint` 익스텐션을 올바르게 이해하고 설정하는 것은 Markdown 문서의 품질을 일관되게 유지하고 팀 전체의 생산성을 향상시키는 데 매우 중요하다.

### 주요 markdownlint 규칙 이해: 단순한 규칙 너머의 의미

엔지니어들이 자주 위반하거나 그 의미를 오해하기 쉬운 `markdownlint` 규칙들을 선별하여, 각 규칙의 목적, 위반 사례, 올바른 사용법, 그리고 관련 파라미터를 예시와 함께 상세히 설명한다.

| 규칙 ID (별칭) | 설명 | 주요 파라미터 (기본값) | 일반적인 위반 사례 | 권장 설정/수정 예시 | 관련 GitHub 이슈 (논의점) |
|---|---|---|---|---|---|
| MD007 (ul-indent) | 순서 없는 목록 항목의 들여쓰기 칸 수를 지정한다. | indent (integer, 2), start_indented (boolean, false), start_indent (integer, 2) | 중첩 시 들여쓰기 칸 수 불일치, 2칸/4칸 혼용. | indent: 4 (CommonMark 호환성 및 코드 블록과 일관성) <br> * 항목1<br>  * 항목1-1 | (MD027과의 충돌) |
| MD013 (line-length) | 한 줄의 최대 길이를 제한한다. | line_length (integer, 80), heading_line_length (integer, 80), code_block_line_length (integer, 80), code_blocks (boolean, true), tables (boolean, true), headings (boolean, true), strict (boolean, false), stern (boolean, false) | 긴 문장, URL, 코드 라인 등이 80자를 초과. | { "MD013": { "line_length": 100, "code_blocks": false, "tables": false } } | (유니코드 문자 길이 계산 문제 - #1458) |
| MD029 (ol-prefix) | 순서 있는 목록의 접두사 스타일을 지정한다. | style (string, "one_or_ordered") | 수동으로 번호 매기기 (1., 2., 3.), 재정렬 시 번거로움. | { "MD029": { "style": "one" } } <br> 1. 첫째<br>1. 둘째 | (0으로 시작하는 목록 지원) |
| MD033 (no-inline-html) | 마크다운 내 인라인 HTML 사용을 제어한다. | allowed_elements (array, 기본적으로 매우 제한적, !-- 등 주석 관련 태그만 허용될 수 있음) | <br>, <img> (크기 조절), <details> 등 사용 시 위반. | { "MD033": { "allowed_elements": ["br", "details", "summary", "img"] } } | (특정 속성을 가진 HTML만 허용하는 기능 요구 - #1163, #494) |
| MD044 (proper-names) | 미리 정의된 목록에 있는 단어들의 대소문자 및 백틱 사용을 확인한다. | names (array), code_blocks (boolean, true) | Git 대신 git, NGINX 대신 nginx, 명령어/파일명에 백틱 미사용. | .markdownlint.json에 names: 추가. <br> 명령어는 `git clone`처럼 백틱 사용. | (허용 목록 관리 및 백틱 사용 규칙) |

- **MD007 (ul-indent - 순서 없는 목록 들여쓰기)**: 이 규칙은 순서 없는 목록 항목의 들여쓰기 스타일을 일관되게 유지하는 데 목적이 있다. `indent` 파라미터는 중첩 시 각 레벨당 들여쓰기할 공백 수를 지정하며, 기본값은 2이다. `start_indented` 파라미터를 `true`로 설정하면 문서의 첫 번째 레벨 목록도 `start_indent` (기본값 2)만큼 들여쓰기된다. 일반적으로 2칸 들여쓰기는 부모 목록의 내용 시작점과 정렬되어 가독성이 좋고, 4칸 들여쓰기는 코드 블록 들여쓰기와 일관성을 가지며 일부 Markdown 파서(특히 MultiMarkdown)와의 호환성을 높인다. 팀의 표준이나 사용하는 파서의 특성에 맞춰 `indent` 값을 2 또는 4로 설정하는 것이 좋다. 주의할 점은 MD007이 순서 있는 목록 내에 중첩된 순서 없는 목록에는 적용되지만, 그 반대의 경우(순서 없는 목록 내 순서 있는 목록)에는 직접 적용되지 않을 수 있다는 점이다. 또한, `start_indented: true` 설정과 `indent` 값을 0보다 크게 설정했을 때, 블록쿼트 내에서 MD027 (no-multiple-space-blockquote) 규칙과 충돌할 가능성이 보고된 바 있다.

- **MD013 (line-length - 줄 길이)**: 이 규칙은 한 줄의 최대 길이를 제한하여 가독성을 높이고, 특히 버전 관리 시스템에서 변경 사항을 추적하기 용이하게 한다. 기본 줄 길이는 80자이지만, `line_length` 파라미터로 조절할 수 있다. 제목(`heading_line_length`), 코드 블록(`code_block_line_length`)에 대해 별도의 길이를 설정할 수도 있으며, `code_blocks: false`, `tables: false`, `headings: false` 등을 통해 특정 요소들을 이 규칙에서 제외하는 것도 가능하다. VSCode의 `markdownlint` 익스텐션은 기본적으로 MD013을 비활성화하는데, 이는 많은 파일이 관습적인 80자 제한을 초과하기 때문이다. 그러나 팀 표준에 따라 적절한 길이(예: 100자 또는 120자)를 설정하고, 코드 블록이나 테이블처럼 줄 바꿈이 어려운 요소는 예외 처리하는 것이 현실적인 접근 방식이다. `strict: true`로 설정하면 공백 없이 길게 이어지는 URL 등도 위반으로 처리하며, `stern: true`는 수정 가능한(즉, 공백이 포함된) 긴 줄에 대해서만 경고한다. 긴 URL이나 이미지 참조 정의는 기본적으로 이 규칙에서 예외 처리된다. 한 가지 유의할 점은 DavidAnson/markdownlint#1458 이슈에서 제기된 것처럼, 한글이나 이모지와 같은 다중 바이트 유니코드 문자가 포함된 줄의 길이를 계산할 때 부정확할 수 있다는 점이다.

- **MD029 (ol-prefix - 순서 있는 목록 접두사)**: 이 규칙은 순서 있는 목록의 숫자 접두사 스타일을 일관되게 유지하도록 한다. `style` 파라미터를 통해 여러 스타일을 지정할 수 있다: `one` (모든 목록 항목을 1.로 시작), `ordered` (숫자가 순차적으로 증가), `one_or_ordered` (기본값, 위 두 가지 스타일 모두 허용), `zero` (목록이 0.으로 시작하고 순차적으로 증가). 많은 가이드에서 `style: "one"`을 권장하는데, 이는 목록 항목을 추가, 삭제, 재정렬할 때 번호를 일일이 수정할 필요가 없어 유지보수성이 크게 향상되기 때문이다. 목록 내에 코드 블록이나 다른 블록 요소가 잘못 들여쓰기되어 목록의 연속성이 깨지면, MD029 위반으로 이어질 수 있으므로 주의해야 한다.

- **MD033 (no-inline-html - 인라인 HTML)**: Markdown 문서의 순수성과 이식성을 위해 인라인 HTML 사용을 제한하는 규칙이다. 기본적으로 대부분의 HTML 태그 사용이 금지되지만, `allowed_elements` 파라미터에 허용할 태그 이름들을 문자열 배열 형태로 명시하여 예외를 둘 수 있다. 예를 들어, 줄 바꿈을 위해 `<br>` 태그를 사용하거나, GitHub 등에서 접고 펴는 섹션(collapsible sections)을 만들기 위해 `<details>`와 `<summary>` 태그를 사용하는 경우, 이들을 `allowed_elements`에 추가해야 한다. 이미지 크기 조절이나 복잡한 테이블 셀 서식 등 Markdown만으로는 표현이 어려운 경우에도 HTML이 필요할 수 있다. 현재 `allowed_elements`는 태그 이름 수준에서만 허용 여부를 제어하며, 특정 속성을 가진 경우에만 허용하는 등의 세밀한 제어는 기본적으로 지원하지 않는다. 이에 대한 기능 개선 요구가 GitHub 이슈(DavidAnson/markdownlint#1163, #494)를 통해 제기된 바 있다.

- **MD044 (proper-names - 적절한 이름 대소문자)**: 이 규칙은 기술 문서에서 제품명, 기술 용어, 회사명 등의 고유명사가 일관되고 정확한 대소문자로 사용되도록 강제한다. 검사 대상이 되는 단어 목록은 설정 파일(`names` 파라미터)을 통해 관리하며, 백틱(`` ` ``)으로 감싸인 단어는 이 규칙의 검사에서 제외된다. 흔한 실수는 JavaScript를 Javascript로 쓰거나, NGINX를 Nginx로 쓰는 등 공식적인 대소문자 표기를 따르지 않는 것이다. 또한, 명령어(`git clone`), 파일명(`.gitlab-ci.yml`), 설정값 등은 백틱으로 감싸야 하는데, 이를 누락하면 MD044 위반으로 이어질 수 있다 (예: `.gitlab-ci.yml`을 백틱 없이 사용하면 `gitlab` 부분이 대문자가 아니라는 이유로 위반될 수 있음). 이 규칙은 정확한 기술 용어 사용을 장려하여 문서의 전문성을 높이는 데 기여한다.

### 설정 전략: markdownlint 길들이기

`markdownlint`의 효과는 올바른 설정에서 비롯된다. 다양한 설정 방법과 그 우선순위, 그리고 일반적인 설정 관련 실수를 이해하는 것이 중요하다.

| 설정 방법 | 우선순위 | 설명 및 주요 고려사항 |
|---|---|---|
| `.markdownlint-cli2.{jsonc,yaml,cjs}` | 1 (가장 높음) | 프로젝트 루트 또는 상위 디렉터리에 위치. `markdownlint-cli2`의 주 설정 파일. 팀 전체 표준 강제에 가장 적합. |
| `.markdownlint.{jsonc,json,yaml,yml,cjs}` | 2 | 프로젝트 루트 또는 상위 디렉터리에 위치. `markdownlint-cli2` 파일이 없을 경우 사용. 널리 사용되는 설정 파일 형식. |
| VSCode `settings.json` - `markdownlint.configFile` | 3 | VSCode 작업 공간 설정에서 특정 설정 파일 경로를 지정. `.markdownlint.json` 등이 프로젝트 루트에 없는 경우 유용. |
| VSCode `settings.json` - `markdownlint.config` | 4 | VSCode 사용자 또는 작업 공간 설정에 직접 규칙을 정의. 개인 선호도 설정에 사용될 수 있으나, 팀 공유에는 부적합. |
| 인라인 주석 비활성화/설정 | (개별 적용) | `<!-- markdownlint-disable MD001,MD005 -->` 등. 특정 줄, 섹션, 파일에 대해 규칙을 예외 처리. 남용 시 린터 효과 감소. |
| `markdownlint` 기본값 | 5 (가장 낮음) | 별도 설정이 없을 경우 적용되는 기본 규칙셋 (예: MD013 기본 비활성화). |

`.markdownlint.json` / `.markdownlint.yaml` 대 VSCode `settings.json`:
`markdownlint` 설정은 주로 프로젝트의 루트 디렉터리에 위치하는 `.markdownlint.json` (또는 `.yaml`, `.jsonc`, `.js` 등) 파일을 통해 이루어진다. 이 방식은 설정 내용을 버전 관리 시스템에 포함하여 팀 전체가 동일한 규칙을 공유하고 일관성을 유지하는 데 매우 효과적이다. VSCode의 사용자 `settings.json`이나 작업 공간(workspace) `settings.json` 내의 `markdownlint.config` 객체를 통해서도 규칙을 설정할 수 있지만, 이는 개인적인 선호도를 반영하거나 프로젝트별 설정 파일이 없을 때의 대안으로 활용하는 것이 좋다. `markdownlint.configFile` 설정을 사용하면 VSCode가 특정 경로의 설정 파일을 사용하도록 지정할 수도 있다.

**설정 우선순위 및 일반적인 설정 오류**:
설정은 명확한 우선순위를 따른다. 일반적으로 프로젝트 내에 위치한 설정 파일이 VSCode의 전역적 또는 작업 공간별 설정보다 우선 적용된다. 가장 높은 우선순위를 갖는 것은 `.markdownlint-cli2.{jsonc,yaml,cjs}` 파일이며, 그 다음이 `.markdownlint.{jsonc,json,yaml,yml,cjs}` 파일이다. VSCode 설정 내에서는 `markdownlint.configFile`로 지정된 파일이 `markdownlint.config` 객체보다 우선한다.
흔히 발생하는 설정 오류로는 다음과 같은 것들이 있다:

- **잘못된 파일명 또는 위치**: `.markdownlint.json` 파일명이 정확하지 않거나 프로젝트 루트 디렉터리가 아닌 곳에 위치시킨 경우 설정이 로드되지 않는다.
- **JSON/YAML 구문 오류**: 설정 파일 내부에 쉼표 누락, 잘못된 중첩 등 구문 오류가 있으면 파싱에 실패하여 적용되지 않는다. VSCode에서 `.jsonc` (JSON with Comments) 형식을 사용하면 주석을 추가할 수 있어 설정 이해에 도움이 된다.
- **우선순위 오해**: VSCode `settings.json`에 규칙을 설정했음에도 불구하고 프로젝트 내의 `.markdownlint.json` 파일 때문에 해당 설정이 적용되지 않는 경우가 대표적이다.
- **도구 버전 간 설정 비호환성**: Node.js 기반의 `markdownlint-cli` 또는 `markdownlint-cli2`와 Ruby 기반의 `mdl`은 서로 다른 도구이며, 설정 파일 형식이 호환되지 않을 수 있다. `mdl`은 `markdownlint-cli2`용으로 작성된 YAML 설정 파일을 제대로 해석하지 못할 수 있다.
- **`.editorconfig`와의 혼동**: `markdownlint`는 `.editorconfig` 파일을 직접 읽어 설정을 가져오지 않는다. 그러나 VSCode에 `EditorConfig` 익스텐션이 설치되어 있고 `.editorconfig` 파일에 `trim_trailing_whitespace = true`와 같은 설정이 있다면, `markdownlint`의 MD009 (후행 공백) 규칙 설정과 무관하게 후행 공백이 자동으로 제거될 수 있어 마치 `markdownlint` 설정이 무시되는 것처럼 보일 수 있다.

**규칙 재정의 및 `allowed_elements` (예: MD033용)**:
대부분의 `markdownlint` 규칙은 기본적으로 활성화되어 있거나 특정 기본값을 가진다 (예: MD013은 기본적으로 비활성화). 설정 파일에서 각 규칙의 ID(예: MD013)나 별칭(예: `line-length`)을 키로 사용하여 값을 지정함으로써 규칙을 재정의할 수 있다. 값으로는 `false` (비활성화), `true` (기본값으로 활성화), 또는 규칙별 파라미터를 담은 객체를 사용할 수 있다.
예를 들어, MD033 (인라인 HTML 금지) 규칙에 대해 특정 HTML 태그를 허용하려면 다음과 같이 설정한다:

```json
//.markdownlint.json
{
  "default": true, // 다른 모든 규칙은 기본값으로 활성화
  "MD033": {
    "allowed_elements": [ "details", "summary", "br", "img", "sup", "sub" ]
  }
}
```

위 설정은 MD033 규칙을 적용하되, `details`, `summary`, `br`, `img`, `sup`, `sub` 태그는 예외적으로 허용한다.

**인라인 비활성화: 시기적절하고 현명한 사용법**:
때로는 특정 상황에서 규칙을 일시적으로 비활성화해야 할 필요가 있다. `markdownlint`는 HTML 주석 형식을 사용하여 특정 줄, 다음 줄, 특정 섹션, 또는 파일 전체에 대해 규칙을 비활성화하거나 재활성화하는 기능을 제공한다.

구문 예시:
`<!-- markdownlint-disable MD001,MD005 -->`: 현재 줄에 대해 MD001과 MD005 규칙을 비활성화한다.
`<!-- markdownlint-disable-next-line MD013 -->`: 다음 줄에 대해 MD013 규칙을 비활성화한다.
`<!-- markdownlint-disable -->`<br>`...`<br>`<!-- markdownlint-enable -->`: 이 주석들 사이의 모든 내용에 대해 모든 규칙을 비활성화했다가 다시 활성화한다.
`<!-- markdownlint-disable-file MD041 -->`: 해당 파일 전체에 대해 MD041 규칙을 비활성화한다.
`<!-- markdownlint-set-file-metadata line_length=100 -->`: 파일 전체에 대해 MD013 규칙의 `line_length` 파라미터를 100으로 설정한다. 이러한 인라인 비활성화는 매우 유용하지만, 남용될 경우 린터 사용의 의미가 퇴색될 수 있다. GitLab 문서에서는 "가능한 한 문제 되는 줄만 제외하라"고 권고하며, 이는 좋은 지침이다. 에서는 특정 포함(include) 파일이나 탭(tabbed) 콘텐츠와 같이 구조적으로 규칙 준수가 어려운 경우에 한해 규칙을 비활성화하는 사례를 보여준다.

## 견고한 마크다운 작성을 위한 고급 지침

### 플랫폼 간 호환성 및 GFM 고려 사항

Markdown은 다양한 "맛(flavor)"이 존재하며, 특히 CommonMark와 GFM(GitHub Flavored Markdown)이 웹과 개발 환경에서 널리 사용된다. 이 둘은 많은 부분을 공유하지만, GFM은 CommonMark에 여러 유용한 확장을 추가했다. 이 차이점을 이해하고 일관된 렌더링을 보장하는 것이 중요하다.

| 기능 | GFM 구문 예시 | GFM 일반 HTML 렌더링 (예상) | CommonMark (엄격) 동작 및 렌더링 (또는 호환성 참고) |
|---|---|---|---|
| 테이블 | `| H1 | H2 |`<br>`|---|---|`<br>`| C1 | C2 |` | `<table><thead><tr><th>H1</th><th>H2</th></tr></thead><tbody><tr><td>C1</td><td>C2</td></tr></tbody></table>` | CommonMark 핵심 명세에는 테이블 구문이 없다. 파이프(`|`)와 하이픈(`-`)은 일반 텍스트로 처리된다. |
| 작업 목록 | `- [x] 완료`<br>`- [ ] 미완료` | `<ul><li class="task-list-item"><input type="checkbox" checked disabled> 완료</li><li class="task-list-item"><input type="checkbox" disabled> 미완료</li></ul>` | CommonMark 핵심 명세에는 작업 목록 구문이 없다. `[x]` 등은 일반 텍스트로 처리된다. |
| 자동 링크 (URL) | `www.example.com` | `<a href="http://www.example.com">www.example.com</a>` | CommonMark는 `<www.example.com>`처럼 꺾쇠괄호로 감싸야 자동 링크로 인식한다. 꺾쇠괄호 없는 URL은 일반 텍스트로 처리된다. |
| 자동 링크 (이메일) | `user@example.com` | `<a href="mailto:user@example.com">user@example.com</a>` | CommonMark는 `<user@example.com>`처럼 꺾쇠괄호로 감싸야 자동 링크로 인식한다. 꺾쇠괄호 없는 이메일 주소는 일반 텍스트로 처리된다. |
| 취소선 | `~~취소된 텍스트~~` | `<del>취소된 텍스트</del>` | CommonMark 핵심 명세에는 취소선 구문이 없다. `~~`는 일반 텍스트로 처리된다. |

GFM은 CommonMark의 슈퍼셋(superset)으로, 테이블, 작업 목록(task lists), 확장된 자동 링크(autolinks), 취소선(strikethrough) 등 유용한 기능을 다수 추가했다. 그러나 이러한 GFM 고유 기능들은 엄격한 CommonMark 파서에서는 지원되지 않거나 다르게 해석될 수 있다.

**일관되게 렌더링되는 마크다운 작성 팁**:

- **CommonMark 우선 사용**: 가장 폭넓은 호환성을 위해서는 CommonMark 표준을 따르는 것이 안전하다.
- **GFM 기능 사용 시 인지**: GFM 특정 기능을 사용할 경우, 해당 문서가 GFM을 지원하는 환경(예: GitHub)을 대상으로 한다는 점을 명확히 하거나, 다른 환경에서는 다르게 보일 수 있음을 인지해야 한다.
- **HTML 사용 최소화**: 플랫폼 간 렌더링 차이를 줄이는 가장 확실한 방법 중 하나는 마크다운 고유 문법을 최대한 활용하고, 불가피한 경우를 제외하고는 HTML 사용을 피하는 것이다.
- **파서/플랫폼 문서 확인**: 문서를 게시하거나 사용하는 특정 플랫폼(예: GitLab, Bitbucket, Confluence 등)의 마크다운 지원 범위를 확인하는 것이 중요하다. 모든 마크다운 애플리케이션이 확장 구문 요소를 지원하는 것은 아니다.
- **렌더링 불일치의 다른 원인**: 때로는 순수한 마크다운 파싱 문제가 아니라 브라우저 캐시나 CSS 스타일링 차이로 인해 로컬 환경과 실제 배포 환경 간에 렌더링 결과가 다를 수 있다. 이는 마크다운 자체의 문제라기보다는 웹 환경 구성의 문제일 수 있으므로, 원인 분석 시 고려해야 한다.

### AI 친화적인 마크다운 작성: LLM과의 효과적인 소통

LLM(Large Language Model)과 같은 AI 도구가 마크다운 문서를 효과적으로 이해하고 활용하도록 하기 위해서는 몇 가지 지침을 따르는 것이 좋다. 흥미롭게도, 이러한 지침들은 대부분 인간 독자의 가독성과 이해도를 높이는 기존의 좋은 문서화 관행과 일치한다.

- **명확성을 위한 콘텐츠 구조화 (의미론적 제목, 목록)**: AI는 문서의 구조를 통해 콘텐츠의 계층과 관계를 파악한다. 따라서 의미론적으로 명확한 제목 체계를 사용하는 것이 매우 중요하다. 예를 들어, 문서 전체의 제목은 H1으로, 주요 섹션은 H2로, 그 하위 섹션은 H3로 작성하는 등 제목 레벨을 논리적으로 사용해야 한다. `markdownlint`의 MD001 (heading-increment)과 MD041 (first-line-h1) 규칙을 철저히 준수하는 것이 도움이 된다. 너무 깊은 제목 중첩(예: H5, H6 이상)은 피하는 것이 좋다. 또한, 관련된 정보 항목들은 순서 있거나 없는 목록으로 묶어 표현하면 AI가 항목 간의 관계를 더 쉽게 인식하고 정보를 구조적으로 이해하는 데 도움이 된다.
- **링크 및 이미지에 설명적인 텍스트 사용**: AI는 링크의 앵커 텍스트와 이미지의 대체 텍스트(alt text)를 통해 해당 리소스의 맥락과 내용을 추론한다. "여기를 클릭하세요"와 같이 모호한 링크 텍스트나, "이미지"처럼 의미 없는 대체 텍스트는 AI의 문서 이해를 방해한다. 따라서 링크가 가리키는 대상의 내용을 요약하거나 핵심 키워드를 포함하는 설명적인 앵커 텍스트를 사용해야 한다. 이미지에는 시각적 내용을 정확히 설명하는 대체 텍스트를 제공하여 (MD045 규칙 준수) AI가 이미지의 의미를 파악하도록 도와야 한다.
- **스타일 및 서식의 일관성 유지**: 문서 전체에 걸쳐 일관된 마크다운 스타일(예: 목록 마커, 강조 방식, 코드 블록 형식 등)을 사용하면 AI가 패턴을 더 쉽게 학습하고 예측할 수 있다. `markdownlint` 규칙(예: MD003 - 제목 스타일, MD004 - 순서 없는 목록 스타일, MD049 - 강조 스타일, MD050 - 강한 강조 스타일)을 적극적으로 활용하여 문서 전체의 스타일 일관성을 강제하는 것이 좋다. 가능하다면 팀 내 마크다운 스타일 가이드를 정의하고 공유하여 모든 구성원이 일관된 방식으로 문서를 작성하도록 유도해야 한다.

결국 "AI 친화적인 마크다운"은 특별하고 새로운 작성법을 요구하는 것이 아니다. 오히려, 인간 독자가 이해하기 쉽고 잘 구조화된 문서를 만드는 기존의 모범 사례를 더욱 철저히 따르는 것이 핵심이다. AI는 정교한 패턴 인식기이며, 입력 데이터의 명확성과 일관성은 패턴 인식의 정확도와 효율성을 높인다. 따라서, AI와의 협업을 위해 마크다운을 최적화하는 것은 문서 품질을 전반적으로 향상시키는 노력의 자연스러운 확장으로 볼 수 있다.

### 팀 협업을 위한 모범 사례: 지속 가능한 문서 관리

여러 엔지니어가 함께 문서를 작성하고 관리할 때는 일관성을 유지하고 품질을 보장하기 위한 명확한 전략이 필요하다.

- **팀 전체 마크다운 표준 수립**: 가장 먼저 팀 전체가 동의하고 따를 수 있는 마크다운 작성 표준을 수립해야 한다. 여기에는 `markdownlint` 설정 파일(.markdownlint.json 또는 .yaml)을 프로젝트에 포함시켜 모든 팀원이 동일한 린팅 규칙을 적용받도록 하는 것이 포함된다. 팀에서 사용할 `markdownlint` 규칙셋을 함께 논의하여 결정하고, 필요한 경우 특정 규칙을 비활성화하거나 파라미터를 프로젝트의 특성에 맞게 조정한다. 이렇게 합의된 설정 파일은 버전 관리 시스템(예: Git)에 포함하여 모든 팀원이 쉽게 접근하고 동일한 기준으로 작업할 수 있도록 해야 한다.
- **CI/CD 파이프라인에서 린터 사용**: 코드 변경 사항을 주 브랜치에 통합하기 전에, CI(Continuous Integration) / CD(Continuous Deployment) 파이프라인에서 `markdownlint`를 실행하여 마크다운 문서의 품질을 자동으로 검증하는 것이 매우 효과적이다. GitHub Actions, GitLab CI, Jenkins 등 다양한 CI/CD 도구에서 `markdownlint-cli` 또는 `markdownlint-cli2`와 같은 커맨드 라인 인터페이스를 사용하여 Pull Request(PR) 또는 Merge Request(MR) 생성 시 변경된 마크다운 파일들을 검사하도록 설정할 수 있다. 이를 통해 스타일 가이드 위반이나 잠재적 오류가 있는 문서가 병합되는 것을 사전에 방지할 수 있다.
- **문서 정기 검토 및 업데이트**: 문서는 코드와 마찬가지로 "살아있는" 존재이며, 시간이 지남에 따라 내용이 부정확해지거나 최신 상황을 반영하지 못하게 될 수 있다. 따라서 정기적인 검토와 업데이트를 통해 문서의 정확성과 유용성을 유지해야 한다. 문서 변경 사항도 코드 검토 프로세스와 동일하게 취급하여 동료 검토를 거치도록 하는 것이 좋다. 오래되거나 더 이상 유효하지 않은 문서 섹션을 식별하기 위해 "문서 부채(documentation debt)" 개념을 도입하여 추적하는 것도 한 방법. 또한, 각 문서 페이지에 "마지막 업데이트" 날짜를 명시하여 독자들이 정보의 최신성을 판단하는 데 도움을 줄 수 있다.
