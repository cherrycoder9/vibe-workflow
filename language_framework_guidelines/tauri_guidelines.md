# Tauri 개발 시 주의사항

Tauri 애플리케이션은 Rust 백엔드와 웹뷰(프론트엔드) 간의 IPC(Inter-Process Communication)를 통해 통신하며, Commands와 Events를 주로 사용합니다. 이 메커니즘은 강력하지만, 잘못 사용될 경우 성능 문제나 예측 불가능한 동작을 야기할 수 있습니다.

## 1. IPC 호출 및 페이로드 크기로 인한 성능 저하

- **과도한 IPC 호출**: 상태의 작은 변경마다 `invoke`를 호출하거나, 실시간 데이터 동기화를 위해 빈번하게 이벤트를 발생시키면 IPC 채널이 포화되어 UI 지연을 유발할 수 있습니다. 각 호출은 직렬화, 역직렬화, 컨텍스트 스위칭 비용을 수반합니다.
- **대용량 페이로드 전송**: Tauri 1.x에서는 JSON 직렬화로 인해 이미지나 대용량 바이너리 데이터 전송 시 심각한 성능 저하를 초래합니다. Tauri 2.0에서는 Channels API가 도입되어 바이트 직접 전송으로 오버헤드를 줄였습니다.
- **해결책**: IPC 호출 횟수를 최소화하고, 여러 작업을 단일 명령으로 묶거나 상태 변경을 일괄 처리합니다. 대용량 데이터는 Tauri 1.x에서 청크로 나누거나 파일 경로만 전달하고, Tauri 2.0에서는 Channels API를 적극 활용합니다. 필요한 최소한의 정보만 전송하도록 페이로드를 최적화하고, 전체 상태보다는 변경된 부분(delta)만 전송합니다.

## 2. Rust와 JavaScript 간 비동기 흐름 제어의 복잡성

- **Promise 처리 미숙**: JavaScript 측에서 `invoke`로 반환된 Promise를 적절히 `await`하거나 `.then().catch()`로 처리하지 않으면 Rust 코드의 실행 완료 여부나 결과를 알 수 없거나 오류를 놓칠 수 있습니다.
- **동시 다발적 요청 처리**: 여러 비동기 Command가 동시에 호출될 때 완료 순서가 보장되지 않아 UI 상태를 예측 불가능하게 만들 수 있습니다.
- **이벤트 기반 통신의 함정**: 이벤트는 "fire-and-forget" 방식이므로 중요한 작업 완료 보장에 의존해서는 안 됩니다. 이벤트 리스너 등록 전 이벤트 유실, 리스너 해제 누락 시 메모리 누수 위험이 있습니다.
- **해결책**: 모든 `invoke` 호출에 명시적인 `async/await` 또는 Promise 체이닝을 사용하고 오류 처리를 포함합니다. 여러 비동기 작업의 순서가 중요하다면 `Promise.all`이나 순차적 `await`로 흐름을 제어합니다. 이벤트 리스너는 컴포넌트 마운트 시 등록하고 언마운트 시 반드시 해제합니다. 중요한 작업 완료 확인은 Command 응답을 통해 이루어져야 합니다.

## 3. Rust Result 및 Error 타입의 직렬화 및 JavaScript 예외 처리 미흡

- **`serde::Serialize` 미구현 에러**: Rust의 표준 에러 타입은 `serde::Serialize`를 구현하지 않아 IPC를 통해 직접 전달될 수 없으며, 에러 정보가 유실될 수 있습니다.
- **단순 문자열 변환의 한계**: 에러를 문자열로 변환하면 구조적인 정보(에러 코드, 컨텍스트)가 유실되어 프론트엔드에서 정교한 에러 분기 처리가 어렵습니다.
- **`Option<()>` 반환 시 예기치 않은 `null`**: Rust에서 `Option<()>` (특히 `Some(())`)을 반환할 때 JavaScript에서 `null`로 변환될 수 있어 프론트엔드에서 `void`를 기대하는 로직과 충돌할 수 있습니다.
- **해결책**: Rust Command에서는 `thiserror`와 `serde::Serialize`를 사용하여 구조화된 커스텀 에러 타입을 정의하고, 에러 코드, 메시지, 추가 컨텍스트 정보를 포함합니다. 프론트엔드에서는 모든 `invoke` 호출에 대해 `try...catch` 또는 `.catch()`를 사용하여 에러를 명시적으로 처리하고, 수신된 에러 객체의 구조를 기반으로 피드백을 제공합니다. 에러 타입을 Rust와 TypeScript에서 공유하여 타입 안정성을 높이는 것을 고려합니다.

## 4. Tauri 2.0 채널(Channel) API의 잘못된 이해 및 사용

- **용도 혼동**: Channels는 저지연, 고처리량 스트리밍에 적합하며, 단순한 상태 변경 알림에는 기존 이벤트 시스템이 더 적절합니다.
- **데이터 직렬화 및 타입**: Channels API는 바이너리 데이터(`Vec<u8>`)나 `Serializable` 타입을 직접 전송할 수 있지만, 프론트엔드에서 바이너리 데이터 처리 로직이 필요하며 타입 정의를 정확히 맞춰야 합니다.
- **메모리 관리 및 백프레셔**: 대용량 파일 스트리밍 시 Rust 측에서 적절한 청킹 및 백프레셔 처리가 없으면 메모리 사용량이 급증할 수 있습니다.
- **에러 처리 및 복구**: 스트리밍 중 발생할 수 있는 I/O 에러, 네트워크 에러, 직렬화/역직렬화 에러에 대한 견고한 처리 및 복구 메커니즘이 필요합니다.
- **해결책**: Channels API는 대용량 데이터 스트리밍, 실시간 로그 전송, 바이너리 데이터 전송 등 고성능/저지연이 필수적인 시나리오에 사용합니다. Rust와 JavaScript 간의 타입을 명확히 정의하고, 바이너리 데이터의 경우 적절한 인코딩/디코딩 방식을 사용합니다. 대용량 데이터 스트리밍 시 Rust 코드에서 적절한 청크 크기를 사용하고 백프레셔를 고려합니다. 모든 에러 케이스를 정의하고 양측에서 처리 로직을 구현합니다.

## 5. Rust와 프론트엔드 간 상태 관리

- **일관되지 않은 상태 동기화 및 경쟁 조건**: Rust 백엔드 상태와 프론트엔드 UI 상태 간의 동기화는 타이밍 문제나 동시성 문제로 인해 상태 불일치나 경쟁 조건이 발생하기 쉽습니다. 이벤트 기반 동기화는 순서 보장이 어렵고, 프론트엔드 상태와 Rust `State`가 불일치할 수 있습니다.
- **Rust `State`의 동시성 관리**: `tauri::State`는 스레드 안전성을 위해 `Mutex` 등으로 보호되지만, 잠금을 너무 오래 유지하면 응답성에 영향을 줄 수 있습니다. `Arc` 사용은 일반적으로 불필요하며, `app.state::<T>()` 호출 시 타입 불일치로 런타임 패닉이 발생할 수 있습니다.
- **다중 창 상태 일관성 간과**: 다중 창 환경에서 각 창의 독립적인 WebView 프로세스와 프론트엔드 상태로 인해 상태 일관성 유지가 복잡합니다. 전역 이벤트(`app.emit_all`)는 한계가 있으며, 창 간 직접 통신이 기본적으로 부재합니다.
- **영구 상태 메커니즘의 비효율적 사용**: `localStorage`는 용량 및 동기적 동작에 한계가 있고, `IndexedDB`는 복잡하며 Rust에서 직접 접근 불가합니다. `tauri-plugin-store`는 키-값 저장소로 적합하지만 복잡한 관계형 데이터에는 부적합합니다. `SQLite`는 강력하지만 스키마 관리, 마이그레이션, 빌드 문제 등 복잡성을 야기합니다.
- **해결책**: 애플리케이션 핵심 상태는 Rust 백엔드를 단일 진실 공급원으로 지정합니다. 상태 변경은 Command를 통해 수행하고 응답으로 반영합니다. 이벤트는 상태 변경 '알림' 용도로 사용하되 멱등성을 갖추도록 설계합니다. Rust `State` 접근 시 잠금 범위를 최소화하고 비동기 `Mutex`를 사용합니다. 다중 창 상태 관리는 공유 상태와 로컬 상태를 구분하고, Rust 백엔드를 중심으로 상태를 동기화합니다. 영구 저장 전략은 데이터 특성을 고려하여 선택하고, 구조화된 데이터에는 SQLite를 우선 고려하며 마이그레이션 전략을 수립합니다. 비동기적 상태 업데이트의 "최종 일관성" 모델을 이해하고, 낙관적 업데이트 후 롤백/정정 메커니즘을 갖추도록 설계합니다.
