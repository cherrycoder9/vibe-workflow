# Tauri 사용 시 주의할 점 및 주요 특징

Tauri는 Rust 기반 코어 프로세스와 네이티브 웹뷰를 활용하여 Electron보다 작은 크기와 효율적인 리소스 사용을 제공합니다.

## 1. Tauri 1.x 대비 2.x의 주요 아키텍처 변화

- **모바일 지원:** iOS 및 Android 플랫폼 지원 추가.
- **다중 웹뷰 지원 (불안정):** 단일 창 내 여러 웹뷰 실험적 도입.
- **IPC 메커니즘 개선:** 커스텀 프로토콜 기반 IPC 및 대용량 데이터 전송을 위한 채널(Channel) API 추가.
- **보안 모델 강화:** Capabilities, Permissions, Scopes 기반의 세분화된 접근 제어 모델로 변경.
- **플러그인 시스템 개편:** 많은 Tauri API가 플러그인 시스템으로 이동, Swift/Kotlin 바인딩 지원.
- **Window 및 Webview API 분리:** `tauri::Window` 및 `tauri::WindowBuilder` 동작이 `tauri::WebviewWindow` 및 `tauri::WebviewWindowBuilder`로 이전, `tauri::Webview` 및 `tauri::WebviewBuilder` 구조체 추가.

## 2. Rust 백엔드와 웹뷰 프론트엔드 간의 상호작용 모델

Tauri의 핵심은 Rust 백엔드와 웹뷰 프론트엔드 간의 비동기 메시지 패싱입니다.

- **명령 (Commands):** 프론트엔드 JavaScript가 Rust 함수를 호출하고 결과를 받는 기본 메커니즘. 모든 인자와 반환 값은 JSON으로 직렬화 가능해야 합니다.
- **이벤트 (Events):** 단방향 메시지로, Rust에서 프론트엔드로 또는 그 반대로 상태 변경이나 생명주기 이벤트를 알리는 데 사용. 대량 데이터 전송에는 부적합.
- **채널 (Channels) (Tauri 2.x 신규):** 스트리밍 작업(예: 다운로드 진행률)을 위한 빠르고 순서가 보장되는 데이터 전송 방식. 대용량 데이터 전송에 효율적.
- **JavaScript 직접 실행:** Rust에서 `WebviewWindow#eval` 함수를 사용하여 웹뷰 컨텍스트 내에서 직접 JavaScript 코드를 실행 가능.

### 2.1. Commands, Events, Channels: 사용 사례 및 선택 기준

각 IPC 메커니즘은 서로 다른 사용 사례에 적합하며, 적절한 선택은 애플리케이션 성능과 안정성에 큰 영향을 미친다.

- **명령 (Commands):**
    - **설명:** 프론트엔드에서 Rust 함수를 호출하고 결과를 받는 양방향 요청-응답 패턴. 모든 데이터는 JSON으로 직렬화된다.
    - **사용 사례:** 파일 읽기, 데이터베이스 쿼리, 상태 조회, 설정 변경 등 명확한 요청과 응답이 필요한 경우.
    - **주의사항:** 대용량 바이너리 데이터 전송 시 JSON 직렬화/역직렬화 오버헤드가 발생할 수 있다. Tauri 2.x에서는 `tauri::ipc::Request`와 `tauri::ipc::Response`를 사용하여 원시 바이트 배열(raw payload)을 주고받아 오버헤드를 줄일 수 있다.

- **이벤트 (Events):**
    - **설명:** 단방향 "발행-구독(fire-and-forget)" 메시지. Rust에서 프론트엔드로 또는 그 반대로 상태 변경, 진행 상황 알림 등을 전달하는 데 사용. 페이로드는 항상 JSON 문자열.
    - **사용 사례:** 비동기 작업 진행 상황 알림, 백그라운드 서비스 상태 변경 알림, 여러 웹뷰 간 정보 동기화 등 실시간 업데이트.
    - **주의사항:** 강력한 타입 지원이 없고, 페이로드가 JSON 문자열이므로 대용량 메시지 전송에는 부적합. Capabilities 시스템을 통한 세밀한 제어가 불가능.

- **채널 (Channels) (Tauri 2.x 신규):**
    - **설명:** 빠르고 순서가 보장되는 데이터 스트리밍을 위해 설계. 내부적으로 다운로드 진행률, 자식 프로세스 출력, WebSocket 메시지 등에 사용.
    - **사용 사례:** 대용량 파일 전송, 실시간 데이터 스트리밍, 지속적인 데이터 업데이트 등 저지연 및 고처리량이 요구되는 상황.
    - **주의사항:** 이벤트 시스템보다 성능이 우수하지만, 특정 스트리밍 시나리오에 더 특화. 프론트엔드에서 채널을 사용하는 명령을 호출할 때는 Channel 인스턴스를 생성하여 인자로 전달해야 한다.

**IPC 메커니즘 선택 시 고려 사항:**
- **데이터 크기:** 작은 JSON 데이터는 명령/이벤트, 대용량 바이너리/스트리밍 데이터는 채널 또는 명령의 원시 페이로드 기능 사용.
- **통신 패턴:** 단일 요청-응답은 명령, 비동기적 알림은 이벤트, 지속적인 데이터 흐름은 채널.
- **응답 필요 여부:** Rust 함수의 결과를 기다려야 한다면 명령, 단순 알림이라면 이벤트.
- **타입 안전성 및 보안:** 명령은 Rust 함수의 시그니처를 통해 타입 안전성 제공 및 Capabilities 시스템을 통한 접근 제어 가능.

### 2.2. Serde를 활용한 IPC 데이터 직렬화: 모범 사례 및 함정

Tauri는 IPC 데이터 교환에 Serde 라이브러리를 사용한다.

**모범 사례:**
- **명확한 데이터 구조 정의:** Rust와 TypeScript(또는 JavaScript) 양쪽에서 주고받을 데이터 구조를 명확히 정의하고, Serde의 `Serialize` 및 `Deserialize` 트레잇을 Rust 구조체에 파생시킨다.
- `rename_all` 활용: 필드 이름을 JavaScript에서 일반적으로 사용되는 `camelCase`나 `snake_case`로 자동 변환하기 위해 `#[serde(rename_all = "camelCase")]` 같은 어트리뷰트를 사용한다.
- **오류 타입 직렬화:** 명령에서 `Result<T, E>`를 반환할 때, 오류 타입 `E`도 `Serialize`를 구현해야 한다. `thiserror` 크레이트와 함께 사용자 정의 오류 타입을 만들고 이를 직렬화하여 프론트엔드에 전달하는 것이 좋다.

**함정 및 성능 고려 사항:**
- **과도한 직렬화:** Tauri 2.x에서는 IPC 메커니즘 개선으로 중복 직렬화가 줄었지만, 매우 크거나 복잡한 데이터를 자주 주고받는 것은 여전히 성능에 영향을 줄 수 있다.
- **대용량 데이터:** 매우 큰 데이터(수십 MB 이상)를 JSON으로 직렬화하는 것은 비효율적일 수 있다. 이 경우 `tauri::ipc::Response::new(raw_data)`를 사용하여 원시 바이트를 직접 전송하거나 채널을 사용하는 것이 좋다.
- **잘못된 타입 역직렬화:** 프론트엔드에서 Rust 명령으로 데이터를 전달할 때, Rust 측에서 기대하는 타입과 JavaScript 데이터 구조가 일치하지 않으면 역직렬화 오류가 발생한다. TypeScript를 사용하여 프론트엔드 타입을 명확히 정의하고 Rust 구조체 정의와 일치시키면 문제 감소.
- `Option<T>` 및 `null` 처리: Rust의 `Option<T>`은 JSON의 `null` 또는 해당 필드가 없는 경우로 매핑된다. 역직렬화 시 `Option` 필드가 `null`이 아닌 필수 값으로 잘못 처리되지 않도록 주의.

### 2.3. 원시 페이로드(Raw Payload) 활용을 통한 IPC 최적화

Tauri 2.x부터는 `tauri::ipc::Request`와 `tauri::ipc::Response`를 사용하여 명령(Command)에서 원시 바이트 배열(raw binary array)을 직접 주고받을 수 있다.

**사용 방법:**
- Rust 명령의 인자로 `tauri::ipc::Request<'_>`를 받고, 반환 타입으로 `Result<tauri::ipc::Response, ErrorType>`을 사용.
- `request.body()`를 통해 `tauri::ipc::InvokeBody::Raw(data)` 형태로 원시 데이터를 추출.
- 응답 시에는 `tauri::ipc::Response::new(raw_byte_vector)`를 사용.
- 프론트엔드에서는 `invoke` 함수 호출 시 `Uint8Array`와 같은 바이너리 타입을 인자로 전달하고, 응답도 바이너리 형태로 받는다. `invoke` 함수의 `options` 객체에 `responseType: 'bytes'`를 명시할 수 있다.

**성능 향상:** 이 방식을 사용하면 대용량 파일 전송 시간이 크게 단축될 수 있다.

**주의사항:** 원시 페이로드를 사용할 때는 데이터 형식에 대한 약속이 Rust와 JavaScript 코드 간에 명확해야 한다. `request.headers()`를 사용하여 메타데이터(예: 파일명, MIME 타입)를 함께 전송하는 것을 고려할 수 있다.

## 3. 비동기 명령(Async Commands) 및 장기 실행 작업 처리

Tauri 애플리케이션에서 Rust 백엔드의 비동기 처리 능력은 UI 반응성을 유지하고 복잡한 작업을 효율적으로 수행하는 데 핵심적이다. `async fn`으로 정의된 Tauri 명령은 백그라운드 스레드에서 실행되어 UI 스레드를 차단하지 않는다.

### 3.1. `async fn` 명령의 올바른 사용법 및 UI 차단 방지

`async fn`으로 선언된 Tauri 명령은 Tauri의 비동기 런타임에 의해 별도의 작업(task)으로 생성되어 실행된다. 이는 I/O 바운드 작업이나 시간이 오래 걸릴 수 있는 계산을 UI 스레드와 분리하여 UI가 계속 반응하도록 하는 데 중요하다.

- `#[tauri::command(async)]` vs `async fn`:
    - `#[tauri::command(async)]`는 동기적으로 작성된 Rust 함수를 Tauri의 비동기 런타임에서 실행하도록 강제한다.
    - `async fn`으로 정의된 명령은 Rust의 네이티브 `async/await` 문법을 사용하여 비동기 작업을 자연스럽게 통합한다.
    - 진정한 비동기 I/O 작업을 수행하려면 명령 자체를 `async fn`으로 작성하고 내부에서 비동기 I/O 연산(예: `tokio::fs` 사용)을 사용해야 한다.

- **UI 차단 방지를 위한 지침:**
    - I/O 작업이나 잠재적으로 오래 실행될 수 있는 연산을 포함하는 명령은 반드시 `async fn`으로 선언해야 한다.
    - 동기 명령 내에서 또는 `async fn` 명령의 `.await` 호출 이전에 장시간 실행되는 동기 작업(예: `std::thread::sleep`, 동기 파일 I/O)을 직접 호출하는 것을 피해야 한다. 이러한 동기 코드를 비동기 컨텍스트에서 실행해야 할 경우, `tauri::async_runtime::spawn_blocking`을 사용하여 별도의 스레드 풀에서 실행하는 것을 고려해야 한다.

- **`async fn` 명령에서 빌려온 인자(Borrowed Arguments) 처리:**
    - `&str`이나 `State<'_, Data>`와 같은 빌려온 타입의 인자를 직접 사용하면 라이프타임 문제가 발생할 수 있다.
    - `Result<T, ()>`를 반환하거나 소유권을 가진 타입(예: `&str` 대신 `String`)을 인자로 받는 것을 권장한다.
    - `State`를 비동기 작업 내의 스폰된 태스크에서 접근해야 할 경우, `AppHandle`을 복제하여 이를 통해 상태를 검색하거나, `State`를 직접 전달할 경우 라이프타임을 신중하게 관리해야 한다. 소유된 타입을 선호하는 것이 복잡성을 줄이는 데 도움이 된다.

### 3.2. 장기 실행 작업의 진행 상황 업데이트 및 작업 취소

오래 실행되는 작업을 명령으로 시작했을 때, UI에 진행 상황을 알리고 사용자가 원할 경우 작업을 취소할 수 있도록 하는 것은 좋은 사용자 경험을 위해 필수적이다.

- **진행 상황 업데이트:**
    - Rust 작업 내에서 `app_handle.emit_all("PROGRESS_EVENT", progress_payload)`를 사용하거나 채널(Channel)을 통해 프론트엔드로 주기적인 업데이트를 보낼 수 있다.

- **작업 취소:**
    - `tokio::sync::oneshot` 채널이나 `Arc<Mutex<AtomicBool>>`과 같은 공유 플래그를 사용하여 프론트엔드에서 보낸 취소 신호를 장기 실행 작업에 전달하는 것이 일반적인 패턴이다.
    - `tokio::select!` 매크로는 비동기 작업과 취소 신호 수신을 동시에 기다리는 데 유용하다.
    - 작업이 "취소 가능하도록(cancellation aware)" 설계되어야 한다.

### 3.3. 스폰된 비동기 작업으로부터의 오류 전파

`async fn` 명령이 내부적으로 `tauri::async_runtime::spawn` 등을 사용하여 다른 비동기 작업을 스폰하는 경우, 이 스폰된 작업 내에서 발생한 오류는 명시적으로 처리하지 않으면 원래 명령의 `Result`로 자동 전파되지 않는다.

- **함정:** 스폰된 작업에서 오류가 발생했지만, 주 명령 함수는 `Ok(())`를 성공적으로 반환하여 프론트엔드에서는 오류를 인지하지 못하는 상황이 발생할 수 있다.
- **지침:**
    - 명령이 스폰된 작업의 완료 및 결과를 반영해야 한다면, `join_handle`을 사용하여 작업 완료를 기다리고 그 결과를 처리해야 한다.
    - 스폰된 작업이 문제를 발견하면 `AppHandle::emit_all`을 사용하여 오류 이벤트를 프론트엔드로 직접 보낼 수 있다.
    - 스폰된 작업 내에서 패닉을 피하고, `Result`를 사용하여 오류를 적절히 전파하거나 기록해야 한다.
    - 완전히 분리된 백그라운드 작업을 시작했다면, 해당 작업의 오류는 호출한 명령의 오류 처리 메커니즘으로 자연스럽게 전달되지 않으므로, 자체적으로 상태/오류를 보고하는 메커니즘을 가져야 한다.

## 4. Tauri 2.x 보안: Capabilities, Permissions, CSP

Tauri 2.x는 보안 모델을 대폭 강화하여, 기존 1.x의 `allowlist` 시스템에서 `Capabilities`, `Permissions`, `Scopes`라는 더 세분화되고 강력한 접근 제어 메커니즘으로 전환했다. 콘텐츠 보안 정책(CSP)의 올바른 설정은 웹뷰 보안의 핵심 요소이다.

### 4.1. 보안 모델 이해: Capabilities, Permissions, Scopes

새로운 보안 모델은 다음과 같은 계층 구조를 가진다:

- **Permissions (권한):** 특정 작업(예: `fs:read-text-file`, `dialog:open`)을 수행할 수 있는지를 정의한다.
- **Scopes (범위):** 권한이 적용될 수 있는 대상이나 조건을 제한한다 (예: `$APPDATA` 디렉토리 내 파일만 읽기 허용). `deny` 범위는 항상 `allow` 범위보다 우선한다.
- **Capabilities (기능):** 하나 이상의 권한과 범위를 그룹화하고, 이를 특정 창(window)이나 웹뷰에 할당한다. 창이나 웹뷰가 어떠한 Capability에도 해당하지 않으면 IPC 접근이 전혀 허용되지 않는다.

이러한 구조는 최소 권한 원칙을 적용하여 애플리케이션의 공격 표면을 줄이는 데 목적이 있다.

- **함정 4.1.1: 지나치게 광범위한 범위 또는 기본 권한 사용**
    - 와일드카드 범위(예: `"$HOME/**"`)를 사용하거나 플러그인의 기본 권한(예: `fs:default`)에만 의존하면 의도치 않게 과도한 접근 권한을 부여할 수 있다.
    - 가능한 가장 좁은 범위와 필요한 최소한의 권한만 정의해야 한다. 플러그인 기본 권한을 감사하고, 특정 애플리케이션 요구에 맞는 맞춤형 권한 세트를 생성해야 한다.

- **함정 4.1.2: Capability 병합 및 창 연결 오해**
    - 하나의 창이 여러 Capability에 연결될 경우, 해당 창의 권한은 모든 일치하는 Capability의 권한이 병합된 결과가 된다. 동적으로 생성되는 창의 레이블 관리가 부주의하거나 Capability 패턴이 너무 광범위하면 의도치 않은 권한 상승이 발생할 수 있다.
    - 창 레이블링 전략과 Capability 매칭을 신중하게 설계해야 한다. 신뢰 수준이 낮거나 신뢰할 수 없는 콘텐츠를 처리하는 창에 대해서는 특히 주의하여 각 창에 적용되는 Capability를 감사해야 한다.

- **지침:**
    - 최소 권한 원칙을 적용한다: 필요한 권한과 가장 좁은 범위만 부여한다.
    - 창/웹뷰별로 특정 요구에 따라 Capability를 정의하고, 가능한 한 전역 와일드카드 Capability를 피한다.
    - `tauri.conf.json` 및 Capability 파일(`src-tauri/capabilities/*.json` 또는 `*.toml`)을 정기적으로 감사하여 과도한 권한이 부여되지 않았는지 확인한다.
    - `deny` 범위는 `allow` 범위보다 우선 적용되므로 이를 활용하여 특정 경로 접근을 명시적으로 차단할 수 있다.
    - `shell` 플러그인과 같이 강력한 기능을 제공하는 플러그인을 사용할 때는 `cmd` 및 `args`가 범위 내에서 엄격하게 검증되도록 각별히 주의해야 한다.

### 4.2. 콘텐츠 보안 정책(CSP) 모범 사례

Tauri는 웹뷰에서 로드할 수 있는 리소스를 제한하여 XSS(Cross-Site Scripting)와 같은 웹 기반 취약점을 완화하기 위해 CSP를 활용한다. CSP는 `tauri.conf.json` 파일 내 `app.security.csp` 필드 또는 `app.security.headers` 필드를 통해 설정할 수 있다.

- **함정 4.2.1: `'unsafe-inline'` 또는 `'unsafe-eval'`의 과도한 사용**
    - 편의를 위해 이 지시어를 사용하면 CSP 보호를 크게 약화시킨다. 두 지시어 모두 일반적인 XSS 공격 경로이다.
    - 가능한 한 `'unsafe-inline'`과 `'unsafe-eval'` 사용을 피해야 한다. Tauri가 처리하는 인라인 스크립트 외에 필요한 경우, `nonce`나 해시를 지원하는 라이브러리를 탐색하거나 정적 CSS를 생성하는 방식을 고려해야 한다.

- **함정 4.2.2: IPC를 위한 `connect-src` 설정 오류**
    - `connect-src` 지시어에 `ipc: http://ipc.localhost` (또는 커스텀 프로토콜 사용 시 해당 엔드포인트)를 포함하는 것을 잊으면 Tauri의 IPC 메커니즘이 중단된다.
    - 항상 `connect-src`에 Tauri IPC 및 애플리케이션이 통신해야 하는 다른 백엔드 서비스에 필요한 출처를 포함해야 한다.

- **지침:**
    - 엄격한 CSP로 시작한다: `default-src 'self' tauri: asset:`.
    - `script-src`, `style-src`, `img-src`, `font-src`, `connect-src` 등에 대한 출처를 명시적으로 정의한다.
    - IPC 기능이 작동하도록 `connect-src`에 `ipc: http://ipc.localhost`를 포함해야 한다.
    - WebAssembly의 경우, 필요하다면 `script-src`에 `'wasm-unsafe-eval'`을 추가하되, Wasm이 신뢰할 수 있는 출처에서 제공되는지 확인해야 한다.
    - 가능한 한 `'unsafe-inline'` 및 `'unsafe-eval'`을 피한다.
    - `dangerousDisableAssetCspModification` 옵션은 보안을 약화시킬 수 있으므로, 절대적으로 필요하고 그 영향을 완전히 이해한 경우가 아니면 사용하지 마십시오.

### 4.3. 안전한 명령 처리 및 입력 값 검증

프론트엔드로부터 명령(Commands)을 통해 수신되는 모든 데이터는 신뢰할 수 없는 것으로 간주해야 한다. Rust 명령은 보안에 민감한 작업에 사용하기 전에 입력 값을 엄격하게 검증하고 살균(sanitize)해야 한다.

- **함정:** 프론트엔드로부터 받은 데이터를 암묵적으로 신뢰하여 경로 조작(path traversal), 명령 주입(command injection), 또는 SQL 주입과 같은 취약점으로 이어질 수 있다.
- **지침:**
    - Rust 명령 내에서 수신되는 인자들에 대해 항상 타입, 형식, 범위, 내용을 검증한다.
    - 명령 인자로부터 역직렬화된 구조체에 대해 선언적 검증을 위해 `validator` 또는 `valid`와 같은 크레이트를 사용한다.
    - 복잡한 인자에 대해서는 내재된 검증 로직을 가진 사용자 정의 타입을 정의한다.
    - `shell`과 같은 플러그인을 사용할 때, JS에서 전달된 명령 인자들이 Capability에 설정된 범위에 따라 엄격하게 검증되는지 확인해야 한다.
    - 경로, 셸 명령 또는 데이터베이스 쿼리에 사용되는 모든 데이터를 살균 처리한다.
    - Tauri의 Capability 및 Scope 메커니즘이 일차적인 방어선 역할을 하지만, 이것이 입력 값 자체의 심층적인 내용 검증을 대체하지는 않는다는 점을 이해해야 한다.

## 5. 효과적인 상태 관리 전략

Tauri 애플리케이션에서 Rust 백엔드와 JavaScript 프론트엔드 간의 상태를 공유하거나 동기화하는 것은 일반적인 요구 사항이다. 이를 위한 몇 가지 전략이 있으며, 각 전략은 장단점과 적합한 사용 사례를 가진다.

### 5.1. 상태 동기화 전략 선택

다양한 상태 관리 전략을 고려할 수 있다:

- **Rust 관리 상태 (Tauri Managed State):**
    - **설명:** Tauri의 `Builder::manage` API를 사용하여 Rust 내에 상태를 저장하고, `tauri::State<'_, Mutex<T>>` 또는 비동기 뮤텍스를 통해 명령(Commands)에서 접근한다.
    - **장점:** 상태 로직과 데이터의 소유권이 Rust에 있어 타입 안전성과 성능 이점을 활용할 수 있다.
    - **단점/고려사항:** 프론트엔드가 상태를 자주 읽어야 할 경우, 각 읽기 요청마다 IPC 오버헤드가 발생할 수 있다.

- **이벤트 기반 업데이트:**
    - **설명:** Rust에서 상태가 변경될 때 이벤트를 발생시키고, 프론트엔드는 이 이벤트를 수신하여 로컬 상태를 업데이트한다.
    - **장점:** 반응형 UI에 적합하며, Rust에서 프론트엔드로 상태 변경을 효율적으로 푸시(push)할 수 있다.
    - **단점/고려사항:** 이벤트 페이로드는 JSON 문자열로 제한되므로 대용량 상태 객체 전송에는 적합하지 않을 수 있다.

- **`tauri-plugin-store` 활용:**
    - **설명:** 영구적인 키-값 저장소를 제공하며, Rust와 JS 양쪽에서 비동기적으로 접근 가능하다. 사용자 설정이나 간단한 애플리케이션 데이터 저장에 유용하다.
    - **장점:** 간단한 설정 저장 및 로드가 용이하며, 앱 재시작 간에도 상태가 유지된다.
    - **단점/고려사항:** 복잡한 관계형 데이터나 대용량 데이터셋 관리에는 적합하지 않다.

- **프론트엔드 중심 상태 관리:**
    - **설명:** React의 Redux/Zustand, Vue의 Vuex/Pinia 등 표준 프론트엔드 상태 관리 라이브러리를 사용하고, Rust와의 상호작용은 필요한 백엔드 작업이나 데이터 영속화를 위해 명령/이벤트를 통해 수행한다.
    - **장점:** 프론트엔드 개발자에게 익숙한 패턴을 사용할 수 있으며, UI 관련 상태 관리에 최적화되어 있다.
    - **단점/고려사항:** Rust와 프론트엔드 간 상태 동기화 로직을 직접 구현해야 하며, 상태의 "진실 공급원(source of truth)"이 어디인지 명확히 정의해야 한다.

- **함정 5.1.1: 빈번한 상태 읽기를 위한 명령 과다 사용**
    - 프론트엔드가 Rust 관리 상태의 작은 부분을 자주 읽어야 할 때, 반복적인 명령 호출은 IPC 오버헤드를 유발할 수 있다.
    - 프론트엔드에 상태를 캐시하고 이벤트를 통해 업데이트하는 것이 좋다.

- **지침:**
    - 간단하고 중요하지 않은 UI 상태는 프론트엔드 라이브러리로 충분하다.
    - 영구적인 사용자 설정/환경설정에는 `tauri-plugin-store`가 좋은 선택이다.
    - Rust 측 로직/검증이 필요한 중요 애플리케이션 상태나 데이터는 Rust 관리 상태(`State<'_, Mutex<T>>`)를 사용한다. 프론트엔드와는 명령(작업/읽기용) 및 이벤트(푸시 업데이트용)를 통해 동기화한다.
    - 복잡한 상태 동기화 요구사항에는 `tauri-plugin-zubridge`와 같은 패턴을 고려할 수 있다.
    - 내구성이 필요하거나 여러 창/Rust에서 접근해야 하는 크고 자주 변경되는 상태는 웹뷰의 JavaScript에 직접 저장하기보다는 Rust 관리 상태를 진실 공급원으로 사용하는 것이 좋다.

### 5.2. Rust 관리 상태에서의 동시성 및 가변성 처리

여러 명령(잠재적으로 다른 스레드에서 실행)이나 이벤트 핸들러에서 접근할 수 있는 Rust 상태를 관리할 때는 스레드 안전성이 매우 중요하다.

- **함정 5.2.1: 비동기 명령에서 `std::sync::Mutex` 사용 시 교착 상태(Deadlock)**
    - 비동기 명령 내에서 `.await` 지점을 넘어 `std::sync::MutexGuard`를 유지하면 교착 상태가 발생할 수 있다.
    - `async fn` 명령에서 뮤텍스 잠금을 `.await` 지점 너머로 유지해야 한다면, `tokio::sync::Mutex`와 같은 비동기 인식 뮤텍스를 사용해야 한다.

- **함정 5.2.2: 상태 타입 불일치**
    - `app.state::<MyType>()` 또는 `state: State<'_, MyType>`으로 상태를 요청할 때, `manage()`된 타입과 정확히 일치하지 않는 타입(예: `Mutex<MyType>` 대신 `MyType`을 요청)을 사용하면 런타임 패닉이 발생한다.
    - `app.manage()`에 사용된 타입과 `app.state()` 또는 `State<'_,...>`를 통해 요청하는 타입을 정확히 일치시키도록 매우 주의해야 한다.

- **지침:**
    - 공유 가변 상태는 `std::sync::Mutex` (또는 `.await` 간 유지가 필요하면 비동기 뮤텍스)로 랩핑한다.
    - 명령에서 관리 상태는 `tauri::State<'_, Mutex<YourState>>`를 통해 접근한다.
    - 뮤텍스를 짧게 잠그고, 작업을 수행한 후, 가드가 드롭되어 잠금이 해제되도록 한다.
    - 런타임 패닉을 피하기 위해 `app.manage()` 호출 시와 `State` 접근 시 타입 일치에 매우 주의한다.
    - 경합 및 잠재적 교착 상태를 방지하기 위해 장시간 잠금을 유지하는 것을 피한다.

## 6. Tauri 플러그인 활용: 일반적인 함정 및 모범 사례

Tauri 플러그인은 네이티브 기능을 애플리케이션에 쉽게 통합할 수 있도록 지원한다. 그러나 각 플러그인의 올바른 설정, 권한 부여, API 사용법을 숙지하지 않으면 예상치 못한 문제에 직면할 수 있다.

### 6.1. 일반적인 플러그인 함정

모든 플러그인은 `lib.rs` (또는 `main.rs`)에서의 적절한 초기화(예: `tauri_plugin_fs::init()`)와 `tauri.conf.json` 또는 capability 파일 내 특정 권한/기능 설정이 필요하다. 이 두 단계 중 하나라도 누락되면 플러그인이 정상적으로 작동하지 않는 주요 원인이 된다. 또한, 플러그인 버전은 사용 중인 Tauri 코어 버전과 호환되어야 한다.

- **지침:** 항상 특정 플러그인의 공식 문서에 명시된 Rust 초기화 및 capability 설정 지침을 따르십시오. `tauri add <plugin-name>` CLI 명령은 종종 기본적인 설정을 처리해 주므로 이를 활용하는 것이 좋다. 권장되는 대로 플러그인 버전을 Tauri 코어 버전과 동기화하여 유지하십시오.

### 6.2. 파일 시스템 (`tauri-plugin-fs`)

이 플러그인은 사용자 파일 시스템에 대한 접근을 제공한다. 무단 접근을 방지하기 위해 신중한 범위(scope) 설정이 필수적이다.

- **함정:**
    - 지나치게 허용적인 범위 설정 (예: 강력한 정당화 없이 `$HOME/**` 접근 허용).
    - 파일 작업 오류(예: 파일 없음, 권한 거부) 미처리.
    - `open` API 사용 후 `file.close()` 호출 누락.
    - 적절한 살균/검증 없이 사용자 입력을 사용하여 경로를 구성할 경우, 허용된 범위 내에서도 경로 조작(path traversal) 취약점 발생 가능성.
- **지침:**
    - Capability 설정에서 가능한 가장 좁은 파일 시스템 범위를 정의하십시오.
    - 경로 구성 시 항상 `BaseDirectory` 또는 `@tauri-apps/api/path` 모듈을 사용하십시오.
    - 모든 실패 가능한 파일 시스템 작업에 대해 강력한 오류 처리(Rust의 `Result`, JS의 `try/catch`)를 구현하십시오.
    - 사용자 제공 경로 구성 요소를 살균 처리하십시오.
    - `fs.open()` 사용 후에는 반드시 `file.close()`를 호출하십시오.

### 6.3. 다이얼로그 (`tauri-plugin-dialog`)

네이티브 파일 열기/저장 다이얼로그 및 메시지 다이얼로그(질문, 확인, 메시지)를 제공한다.

- **함정:**
    - UI 응답성이 중요한 상황에서 Rust의 메인 스레드에서 차단(blocking) 다이얼로그(`blocking_show`, `blocking_pick_file`)를 사용하여 UI가 멈추는 현상 발생.
    - 다이얼로그 반환 값(예: 사용자 취소 시 `null` 또는 `None` 반환)을 확인하지 않는 경우.
- **지침:**
    - 가능한 경우, 특히 UI에 민감한 컨텍스트에서 트리거될 때 Rust에서 비동기 다이얼로그 메서드(`show()`, `pick_file()`)를 선호하십시오.
    - 사용자 취소를 나타내는 잠재적인 `null`/`None` 반환 값을 항상 처리하십시오.
    - Capability에 `dialog:default` 또는 특정 다이얼로그 권한(`dialog:allow-ask` 등)이 활성화되어 있는지 확인하십시오.

### 6.4. 알림 (`tauri-plugin-notification`)

네이티브 시스템 알림을 보낸다. 사용자 권한이 필요하다.

- **함정:**
    - 권한을 먼저 확인/요청하지 않고 알림을 보내려고 시도하는 경우.
    - 플랫폼별 제한 사항이나 동작 차이(예: 작업(action)은 모바일 전용, 개발 중 Windows 알림은 PowerShell 아이콘 표시)를 인지하지 못하는 경우.
    - Android에서 알림 채널을 잘못 구성하는 경우.
- **지침:**
    - 알림을 보내기 전에 항상 `isPermissionGranted()`를 확인하고 필요한 경우 `requestPermission()`을 호출하십시오.
    - 알림 기능(작업, 첨부 파일, 아이콘 표시)의 플랫폼 간 차이점을 인지하십시오.
    - 모든 대상 플랫폼에서 알림 동작을 철저히 테스트하십시오.
    - Capability에 `notification:default` 또는 특정 알림 권한이 활성화되어 있는지 확인하십시오.

### 6.5. 셸 (`tauri-plugin-shell`)

자식 프로세스를 스폰하고 기본 애플리케이션으로 URL/파일을 열 수 있도록 허용한다. URL 열기의 경우 `shell.open` 대신 새로운 `tauri-plugin-opener` 사용이 권장된다.

- **함정:**
    - **명령 주입(Command Injection):** 가장 치명적인 함정이다. 셸 범위 구성에서 `cmd` 또는 `args`가 엄격하게 검증되지 않거나 사용자 입력을 직접 전달하도록 허용하면 임의의 명령 실행으로 이어질 수 있다.
    - 살균되지 않은 사용자 제공 URL과 함께 `shell.open`을 사용하면, 적절히 제한되지 않을 경우 악의적인 `file://` 또는 기타 위험한 프로토콜이 열릴 수 있다.
- **지침:**
    - `shell:allow-execute` 및 `shell:allow-spawn` 사용 시 극도의 주의를 기울이십시오. 정확한 명령과 인수에 대한 매우 엄격한 정규식 유효성 검사기를 사용하여 범위를 정의하십시오. 살균되지 않은 사용자 입력을 명령 인수로 직접 전달하지 마십시오.
    - 외부 URL을 열 때는 `shell.open` 대신 `tauri-plugin-opener`를 사용하는 것을 선호하십시오. `shell.open`을 사용해야 하는 경우, 해당 범위가 허용된 프로토콜(예: `http`, `https`, `mailto`만)을 엄격하게 제한하는지 확인하십시오.
    - 셸 플러그인 Capability를 정기적으로 검토하여 지나치게 허용적인 규칙이 없는지 확인하십시오.
    - 셸 플러그인 사용을 최소화하십시오. 특정 Tauri API나 Rust 크레이트를 통해 작업을 수행할 수 있다면 해당 방법을 선호하십시오.

## 7. 성능 최적화 및 리소스 관리

Tauri 애플리케이션의 성능은 사용자 경험에 직접적인 영향을 미친다. Rust 코드, 웹뷰 렌더링, 번들 크기, 메모리 관리 등 다양한 측면에서 최적화가 필요하다.

### 7.1. Rust 코드 최적화

Rust는 일반적으로 우수한 성능을 제공하지만, 자주 호출되는 명령이나 반복문 내의 비효율적인 코드는 병목 현상을 유발할 수 있다.

- **함정:** 성능 테스트 시 기본 디버그 빌드 설정을 사용하거나, 릴리스 프로파일 최적화를 활용하지 않는 경우. 빈번한 복제(clone)나 할당이 발생하는 경로.
- **지침:**
    - 항상 릴리스 빌드(`cargo build --release`)를 기준으로 벤치마킹하고 프로파일링한다.
    - `Cargo.toml`의 릴리스 프로파일을 설정한다: `lto = true`, `codegen-units = 1`, `opt-level = "s"` 또는 `"z"` (크기 최적화) 또는 `3` (속도 최적화), `panic = "abort"`.
    - `perf`, `flamegraph`와 같은 도구를 사용하여 Rust 코드의 병목 지점을 식별한다.
    - 성능에 민감한 코드 경로에서 할당 및 복제를 최소화한다. 빌림(borrowing)과 라이프타임을 효과적으로 사용한다.
    - `async fn`에 적합하지 않은 CPU 집약적 작업의 경우, 비동기 런타임 차단을 피하기 위해 `tauri::async_runtime::spawn_blocking` 사용을 고려한다.

### 7.2. 웹뷰 성능 최적화

웹뷰 성능은 UI 반응성에 매우 중요하다. 효율적인 JavaScript 작성, 최적화된 CSS 사용, DOM 조작 최소화 등 표준 웹 성능 모범 사례가 그대로 적용된다.

- **함정:** 복잡한 DOM 구조, 비효율적인 JavaScript, 웹뷰에서의 과도한 리페인트/리플로우. 웹뷰를 블랙박스로 취급하고 웹 성능 원칙을 적용하지 않는 경우.
- **지침:**
    - 브라우저 개발자 도구를 사용하여 프론트엔드 JavaScript를 프로파일링한다.
    - DOM 조작을 최적화한다. 가상 DOM 라이브러리를 사용하거나 업데이트를 일괄 처리한다.
    - 화면 밖에 있는 콘텐츠와 이미지는 지연 로딩(lazy loading)한다.
    - CSS 선택자를 최적화하고 레이아웃 스래싱(layout thrashing)을 피한다.
    - 프론트엔드 렌더링이 병목이라면, UI 일부에 대해 서버 사이드 렌더링(Rust에서 HTML을 생성하여 주입) 또는 정적 사이트 생성을 고려한다.

### 7.3. 번들 크기 감소

Tauri 앱은 시스템 웹뷰를 사용하기 때문에 Electron에 비해 번들 크기가 작기로 유명하다. 그러나 최적화되지 않은 프론트엔드 에셋과 Rust 의존성은 여전히 큰 번들을 초래할 수 있다.

- **함정:** 프론트엔드 에셋에 크고 최적화되지 않은 이미지/비디오/폰트 포함. Rust 바이너리에서 디버그 심볼을 제거하지 않음. 불필요한 Rust 의존성이나 기능을 포함.
- **지침:**
    - **Rust:** `Cargo.toml` 릴리스 프로파일에 `strip = true` 및 `opt-level = "s"` 또는 `"z"`를 사용한다. 의존성의 사용하지 않는 기본 기능을 비활성화한다.
    - **프론트엔드:** JS/CSS를 최소화(minify)하고, 사용하지 않는 코드를 트리쉐이킹(tree-shake)하며, 이미지를 최적화(WebP/AVIF 사용)하고, 에셋을 압축한다.
    - `tauri.conf.json`의 번들러 설정을 적절히 구성한다.
    - Tauri 2.4 이상 버전에는 `removeUnusedCommands` 빌드 옵션이 있다.

### 7.4. 메모리 관리

Rust는 메모리 안전성을 제공하지만, Rust와 JavaScript 양쪽에서 메모리 누수나 과도한 사용이 발생할 수 있다.

- **함정:**
    - Rust에서 제한 없는 컬렉션 사용이나 리소스 누수.
    - 프론트엔드에서 DOM 누수 또는 큰 JS 객체 유지.
    - Rust 또는 JS에서 리소스(예: 파일 핸들, 네트워크 연결)를 해제하지 않음.
    - 불필요하게 많은 창이나 웹뷰를 계속 유지함.
- **지침:**
    - **Rust:** 메모리 사용량을 프로파일링한다 (예: `valgrind`, 플랫폼별 도구). `Arc` 순환 참조를 주의하고, 적절한 경우 약한 포인터(weak pointer)를 사용한다. 더 이상 필요 없는 큰 데이터 구조는 명시적으로 드롭(drop)한다.
    - **JavaScript:** 브라우저 개발자 도구의 메모리 프로파일러를 사용한다. 이벤트 리스너를 정리하지 않고 DOM 요소를 분리(detach)하는 것을 피한다.
    - 창 생명주기를 효과적으로 관리한다. 필요 없는 창은 닫아서 리소스를 확보한다.
    - IPC의 경우, 프로세스 간에 불필요하게 큰 데이터를 전송하는 것을 피한다.

## 8. 빌드, 서명 및 자동 업데이트: 일반적인 장애물 회피

Tauri 애플리케이션의 배포 과정에는 빌드, 코드 서명, 자동 업데이트 설정 등 여러 단계가 포함된다. 각 단계에서 발생할 수 있는 일반적인 문제와 모범 사례를 숙지하는 것이 중요하다.

### 8.1. 일반적인 빌드 오류 해결

빌드 오류는 잘못 구성된 `tauri.conf.json`, 누락된 시스템 의존성, 툴체인 문제, 또는 호환되지 않는 의존성 버전으로 인해 발생할 수 있다.

- **함정:** 플랫폼별 필수 구성 요소 누락(예: Windows의 WebView2, Linux의 GTK/WebKitGDK 개발 라이브러리, C++ 빌드 도구). `tauri.conf.json` 경로 또는 설정 오류. `beforeDevCommand` 또는 `beforeBuildCommand` 설정 오류.
- **지침:**
    - Tauri 공식 문서에 나열된 모든 플랫폼별 필수 구성 요소가 설치되었는지 확인한다.
    - 상세한 Rust 오류 로그를 보려면 `RUST_BACKTRACE=1 cargo tauri dev`를 사용한다.
    - `beforeDevCommand`가 사용되는 경우 프론트엔드 빌드 오류는 웹뷰 콘솔을 확인한다.
    - Tauri CLI, `@tauri-apps/api`, Rust tauri 크레이트 버전을 일치시킨다.
    - Windows에서 WiX (MSI) 빌드 오류 시, WiX Toolset v3가 설치되어 있고 PATH에 등록되어 있는지 확인한다.

### 8.2. 애플리케이션 서명: 모범 사례 및 일반적인 문제

코드 서명은 배포, 특히 macOS 및 Windows에서 경고를 피하고 사용자 신뢰를 확보하는 데 필수적이다.

- **함정:**
    - `tauri.conf.json` 또는 환경 변수의 잘못된 인증서/ID 구성.
    - CI 환경에서 개인 키 또는 키체인 접근 관련 암호 문제.
    - macOS에서 서명 후 공증(notarization) 누락.
    - 업데이터용 개인 키 분실 시 향후 업데이트 불가.
- **지침:**
    - 플랫폼별 서명 가이드를 꼼꼼히 따른다.
    - 특히 CI 환경에서 개인 키와 암호를 안전하게 관리한다(시크릿 사용).
    - macOS의 경우 서명과 공증을 모두 수행해야 한다.
    - 서명된 빌드를 대상 플랫폼에서 철저히 테스트한다.

### 8.3. 자동 업데이트: 구성 및 문제 해결

Tauri의 업데이터 플러그인을 사용하면 애플리케이션이 자체적으로 업데이트할 수 있다. 올바르게 구성된 업데이트 서버/JSON 엔드포인트와 서명된 업데이트 아티팩트가 필요하다.

- **함정:**
    - `tauri.conf.json`의 잘못된 `endpoints` URL.
    - 앱에 포함된 공개 키와 업데이트 서명에 사용된 개인 키 불일치.
    - 서버가 올바른 JSON 형식이나 서명을 반환하지 않음.
    - 방화벽/네트워크 문제로 업데이트 서버 접근 불가.
    - `createUpdaterArtifacts`가 `true` 또는 `"v1Compatible"`로 올바르게 설정되지 않음.
- **지침:**
    - `tauri.conf.json`에서 `createUpdaterArtifacts`가 올바르게 설정되었는지 확인한다.
    - `tauri.conf.json`의 `pubkey`가 서명에 사용된 키 쌍의 공개 키와 일치하는지 확인한다.
    - 업데이트 서버 엔드포인트를 독립적으로 테스트하여 올바른 JSON 구조와 유효한 URL 및 서명을 제공하는지 확인한다.
    - 개인 서명 키(`TAURI_SIGNING_PRIVATE_KEY` 및 `TAURI_SIGNING_PRIVATE_KEY_PASSWORD` 환경 변수)를 안전하게 저장하고 사용한다.
    - 프론트엔드 업데이트 확인 로직에 강력한 오류 처리 기능을 구현한다.
    - 업데이터 및 다이얼로그 플러그인에 필요한 Capability가 활성화되어 있는지 확인한다.
    - 업데이터 서명 키의 보안과 사용자에게 명확한 업데이트 프로세스 제공은 매우 중요하다.
</file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.

<environment_details>
# VSCode Visible Files
../../../AppData/Local/Programs/Microsoft VS Code/tasks
language_framework_guidelines/tauri_guidelines.md

# VSCode Open Tabs
language_framework_guidelines/tauri_guidelines.md

# Current Time
2025. 6. 1. 오후 9:00:59 (Asia/Seoul, UTC+9:00)

# Context Window Usage
280,617 / 1,048.576K tokens used (27%)

# Current Mode
ACT MODE
</environment_details>
