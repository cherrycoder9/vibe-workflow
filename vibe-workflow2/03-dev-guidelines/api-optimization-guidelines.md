# API 호출 최적화 및 비용 절감 가이드라인 ⚡️💰

**목표:** API 호출을 효율적으로 다듬어 사용자 경험을 높이고, 서버 부하와 비용을 줄입니다.

---

## 1. 최적화가 필요한 이유

* **빠른 반응:** 지연 시간을 줄여 클릭 즉시 화면이 반응하도록 합니다.
* **서버 효율:** 불필요한 요청을 줄여 서버 자원을 아낍니다.
* **비용 절감:** 클라우드·유료 API 사용량을 줄여 비용을 낮춥니다.

특히 검색 자동 완성이나 실시간 유효성 검사처럼 사용자 입력에 반응하는 기능에서는 호출 최소화가 핵심입니다.

---

## 2. 필수 적용 패턴

### 2.1 디바운싱 (Debounce)

* **원칙:** 마지막 입력 후 300\~500ms가 지나면 한 번만 호출.
* **효과:** 타이핑 중 발생하는 중복 호출을 차단.
* **적용 대상:** 검색 창, 입력 폼 실시간 검증 등.

> **TIP:** 지연 시간을 변수로 관리해 조정하세요.

### 2.2 클라이언트 캐싱

* **원칙:** 동일 요청에 대해 로컬 스토리지·세션·메모리에 응답 저장.
* **효과:** 재호출 없이 즉시 데이터 제공, 서버 부담 감소.
* **적용 대상:** 자주 변하지 않는 사용자 프로필, 설정, 제품 목록 등.

> **TIP:** TTL(만료 시간)과 무효화 전략을 함께 설계하세요.

### 2.3 요청 중복 제거

* **원칙:** 동일 요청이 동시에 여러 번 발생하면 첫 요청 결과를 재사용.
* **효과:** 빠른 연속 클릭이나 자동 호출로 인한 중복 방지.
* **적용 대상:** 버튼 클릭 호출, 자동 새로고침 등.

> **TIP:** Promise 캐시 패턴으로 간편 구현 가능합니다.

---

## 3. 상황별 추가 기법

* **스로틀링:** 짧은 주기(예: 200ms)마다 최대 한 번 호출. 스크롤 이벤트 등에 유용.
* **요청 배치:** 여러 요청을 모아 한번에 처리해 HTTP 오버헤드를 줄입니다.
* **HTTP 캐싱:** `Cache-Control`, `ETag`, `Last-Modified` 헤더 활용.
* **Service Worker:** 네트워크 요청 가로채 고급 캐싱 및 오프라인 지원 구현.
* **메모이제이션:** 결과가 변하지 않는 순수함수에 캐시 적용.
* **GraphQL 쿼리 배칭/지속 쿼리:** 요청 횟수 최소화.
* **프리패치/프리렌더:** 사용 패턴 기반으로 데이터·페이지 선로드.
* **레이지 로딩:** 필수 리소스만 우선 로드.
* **페이지네이션/무한 스크롤:** 대량 데이터를 나눠 불러오기.
* **ISR:** 정적 재생성과 동적 업데이트를 결합.
* **CDN 캐싱:** API 응답을 엣지에 분산 배포.
* **요청 조건부 처리:** `If-None-Match`, `If-Modified-Since`로 304 상태 활용.
* **연결 재사용:** HTTP Keep-Alive로 핸드셰이크 비용 절감.
* **페이로드 압축:** Gzip, Brotli 적용.
* **델타 동기화:** 변경 부분만 교환.
* **회로 차단기:** 장애 시 빠른 실패 처리.
* **재시도 백오프:** 지수 백오프 전략으로 재시도.
* **로드 셰딩:** 과부하 시 트래픽 일부 거부로 안정성 유지.

---

## 4. 코딩 가이드라인

API 관련 코드를 작성하거나 검토할 때는 다음을 기본으로 삼으세요.

1. **최적화는 기본**

   * 디바운싱, 클라이언트 캐싱, 요청 중복 제거를 우선 구현합니다.
2. **데이터 효율**

   * 대량 데이터는 페이지네이션 또는 레이지 로딩 적용.
   * GraphQL 사용 시 필드 최소화, 쿼리 배칭/지속 쿼리 권장.
3. **네트워크 효율**

   * 요청 배치와 HTTP 캐싱을 적극 활용.
4. **안정성**

   * 실패 시 지수 백오프 재시도 로직 포함.
   * 레이트 리밋 준수 로직 구현.

항상 최신 버전을 참고하고, 새 호출 로직을 만들 때마다 이 가이드를 점검하세요. 고성능 API는 작은 실천에서 시작됩니다!
